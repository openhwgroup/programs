===============================================================================
Module : uvma_obi_memory_1p2_assert
===============================================================================
SCORE  LINE   COND   ASSERT 
 50.00 --     --      50.00 

Source File(s) : 

cva6/verif/sim//../core-v-verif/lib/uvm_agents/uvma_obi_memory/src/uvma_obi_memory_1p2_assert.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                      
 50.00 --     --      50.00 uvmt_cva6_tb.cva6_dut_wrap.obi_fetch_assert.u_assert.gen_1p2.u_1p2_assert 
 50.00 --     --      50.00 uvmt_cva6_tb.cva6_dut_wrap.obi_store_assert.u_assert.gen_1p2.u_1p2_assert 
 50.00 --     --      50.00 uvmt_cva6_tb.cva6_dut_wrap.obi_load_assert.u_assert.gen_1p2.u_1p2_assert  



-------------------------------------------------------------------------------
Assert Coverage for Module : uvma_obi_memory_1p2_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 20    20        100.00  10                50.00   
Cover sequences  0     0                 0                         
Total            20    20        100.00  10                50.00   



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                        Attempts  Matches  Incomplete 
c_achk_stable               153606204 9882679  1155       
c_aid_stable                153606204 9882679  1155       
c_atomic_addr_aligned       153606204 0        0          
c_atop_stable               153606204 9882679  1155       
c_auser_stable              153606204 9882679  1155       
c_err_stable                153606204 0        0          
c_exokay_lr_sc              153606204 0        0          
c_exokay_stable             153606204 0        0          
c_memtype_stable            153606204 9882679  1155       
c_one_atomic_trn            153606204 28548535 0          
c_prot_stable               153606204 9882679  1155       
c_rchk_stable               153606204 0        0          
c_rdata_stable              153606204 0        0          
c_req_until_gnt             153606204 9882679  1155       
c_rid_follows_aid           153606204 18662331 0          
c_rid_stable                153606204 0        0          
c_rready_assert_no_rvalid   153606204 0        0          
c_rready_deassert_no_rvalid 153606204 0        5764       
c_ruser_stable              153606204 0        0          
c_wuser_stable              153606204 9882679  1155       


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_fetch_assert.u_assert.gen_1p2.u_1p2_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 50.00 --     --      50.00 


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 50.00 --     --      50.00 


Module : 

SCORE  LINE   COND   ASSERT NAME                       
 50.00 --     --      50.00 uvma_obi_memory_1p2_assert 


Parent : 

SCORE  LINE   COND   ASSERT NAME     
 81.82 --     --      81.82 u_assert 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Assert Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_fetch_assert.u_assert.gen_1p2.u_1p2_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 20    20        100.00  10                50.00   
Cover sequences  0     0                 0                         
Total            20    20        100.00  10                50.00   



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                        Attempts Matches  Incomplete 
c_achk_stable               51202068 8238280  905        
c_aid_stable                51202068 8238280  905        
c_atomic_addr_aligned       51202068 0        0          
c_atop_stable               51202068 8238280  905        
c_auser_stable              51202068 8238280  905        
c_err_stable                51202068 0        0          
c_exokay_lr_sc              51202068 0        0          
c_exokay_stable             51202068 0        0          
c_memtype_stable            51202068 8238280  905        
c_one_atomic_trn            51202068 24112278 0          
c_prot_stable               51202068 8238280  905        
c_rchk_stable               51202068 0        0          
c_rdata_stable              51202068 0        0          
c_req_until_gnt             51202068 8238280  905        
c_rid_follows_aid           51202068 15871660 0          
c_rid_stable                51202068 0        0          
c_rready_assert_no_rvalid   51202068 0        0          
c_rready_deassert_no_rvalid 51202068 0        1469       
c_ruser_stable              51202068 0        0          
c_wuser_stable              51202068 8238280  905        


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_store_assert.u_assert.gen_1p2.u_1p2_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 50.00 --     --      50.00 


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 50.00 --     --      50.00 


Module : 

SCORE  LINE   COND   ASSERT NAME                       
 50.00 --     --      50.00 uvma_obi_memory_1p2_assert 


Parent : 

SCORE  LINE   COND   ASSERT NAME     
 81.82 --     --      81.82 u_assert 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Assert Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_store_assert.u_assert.gen_1p2.u_1p2_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 20    20        100.00  10                50.00   
Cover sequences  0     0                 0                         
Total            20    20        100.00  10                50.00   



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                        Attempts Matches Incomplete 
c_achk_stable               51202068 651997  250        
c_aid_stable                51202068 651997  250        
c_atomic_addr_aligned       51202068 0       0          
c_atop_stable               51202068 651997  250        
c_auser_stable              51202068 651997  250        
c_err_stable                51202068 0       0          
c_exokay_lr_sc              51202068 0       0          
c_exokay_stable             51202068 0       0          
c_memtype_stable            51202068 651997  250        
c_one_atomic_trn            51202068 2059374 0          
c_prot_stable               51202068 651997  250        
c_rchk_stable               51202068 0       0          
c_rdata_stable              51202068 0       0          
c_req_until_gnt             51202068 651997  250        
c_rid_follows_aid           51202068 1406193 0          
c_rid_stable                51202068 0       0          
c_rready_assert_no_rvalid   51202068 0       0          
c_rready_deassert_no_rvalid 51202068 0       1942       
c_ruser_stable              51202068 0       0          
c_wuser_stable              51202068 651997  250        


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_load_assert.u_assert.gen_1p2.u_1p2_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 50.00 --     --      50.00 


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 50.00 --     --      50.00 


Module : 

SCORE  LINE   COND   ASSERT NAME                       
 50.00 --     --      50.00 uvma_obi_memory_1p2_assert 


Parent : 

SCORE  LINE   COND   ASSERT NAME     
 81.82 --     --      81.82 u_assert 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Assert Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_load_assert.u_assert.gen_1p2.u_1p2_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 20    20        100.00  10                50.00   
Cover sequences  0     0                 0                         
Total            20    20        100.00  10                50.00   



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                        Attempts Matches Incomplete 
c_achk_stable               51202068 992402  0          
c_aid_stable                51202068 992402  0          
c_atomic_addr_aligned       51202068 0       0          
c_atop_stable               51202068 992402  0          
c_auser_stable              51202068 992402  0          
c_err_stable                51202068 0       0          
c_exokay_lr_sc              51202068 0       0          
c_exokay_stable             51202068 0       0          
c_memtype_stable            51202068 992402  0          
c_one_atomic_trn            51202068 2376883 0          
c_prot_stable               51202068 992402  0          
c_rchk_stable               51202068 0       0          
c_rdata_stable              51202068 0       0          
c_req_until_gnt             51202068 992402  0          
c_rid_follows_aid           51202068 1384478 0          
c_rid_stable                51202068 0       0          
c_rready_assert_no_rvalid   51202068 0       0          
c_rready_deassert_no_rvalid 51202068 0       2353       
c_ruser_stable              51202068 0       0          
c_wuser_stable              51202068 992402  0          


===============================================================================
Module : uvma_obi_memory_assert
===============================================================================
SCORE  LINE   COND   ASSERT 
 81.82 --     --      81.82 

Source File(s) : 

cva6/verif/sim//../core-v-verif/lib/uvm_agents/uvma_obi_memory/src/uvma_obi_memory_assert.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                 
 81.82 --     --      81.82 uvmt_cva6_tb.cva6_dut_wrap.obi_fetch_assert.u_assert 
 81.82 --     --      81.82 uvmt_cva6_tb.cva6_dut_wrap.obi_store_assert.u_assert 
 81.82 --     --      81.82 uvmt_cva6_tb.cva6_dut_wrap.obi_load_assert.u_assert  



-------------------------------------------------------------------------------
Assert Coverage for Module : uvma_obi_memory_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 11    11        100.00  9                 81.82   
Cover sequences  0     0                 0                         
Total            11    11        100.00  9                 81.82   



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                  Attempts  Matches  Incomplete 
c_addr_be_consistent  153606204 28550891 0          
c_addr_stable         153606204 9882679  1155       
c_be_contiguous       153606204 28548535 0          
c_be_not_zero         153606204 28548535 0          
c_be_stable           153606204 9882679  1155       
c_gnt_assert_no_req   153606204 0        4490       
c_gnt_deassert_no_req 153606204 0        585        
c_r_after_a           153606204 18662331 0          
c_req_until_gnt       153606204 9882679  1155       
c_wdata_stable        153606204 9882679  1155       
c_we_stable           153606204 9882679  1155       


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_fetch_assert.u_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 81.82 --     --      81.82 


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 61.29 --     --      61.29 


Module : 

SCORE  LINE   COND   ASSERT NAME                   
 81.82 --     --      81.82 uvma_obi_memory_assert 


Parent : 

SCORE  LINE   COND   ASSERT NAME             
--     --     --     --     obi_fetch_assert 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                 
 50.00 --     --      50.00 gen_1p2.u_1p2_assert 



-------------------------------------------------------------------------------
Assert Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_fetch_assert.u_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 11    11        100.00  9                 81.82   
Cover sequences  0     0                 0                         
Total            11    11        100.00  9                 81.82   



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                  Attempts Matches  Incomplete 
c_addr_be_consistent  51202068 24114634 0          
c_addr_stable         51202068 8238280  905        
c_be_contiguous       51202068 24112278 0          
c_be_not_zero         51202068 24112278 0          
c_be_stable           51202068 8238280  905        
c_gnt_assert_no_req   51202068 0        703        
c_gnt_deassert_no_req 51202068 0        17         
c_r_after_a           51202068 15871660 0          
c_req_until_gnt       51202068 8238280  905        
c_wdata_stable        51202068 8238280  905        
c_we_stable           51202068 8238280  905        


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_store_assert.u_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 81.82 --     --      81.82 


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 61.29 --     --      61.29 


Module : 

SCORE  LINE   COND   ASSERT NAME                   
 81.82 --     --      81.82 uvma_obi_memory_assert 


Parent : 

SCORE  LINE   COND   ASSERT NAME             
--     --     --     --     obi_store_assert 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                 
 50.00 --     --      50.00 gen_1p2.u_1p2_assert 



-------------------------------------------------------------------------------
Assert Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_store_assert.u_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 11    11        100.00  9                 81.82   
Cover sequences  0     0                 0                         
Total            11    11        100.00  9                 81.82   



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                  Attempts Matches Incomplete 
c_addr_be_consistent  51202068 2059374 0          
c_addr_stable         51202068 651997  250        
c_be_contiguous       51202068 2059374 0          
c_be_not_zero         51202068 2059374 0          
c_be_stable           51202068 651997  250        
c_gnt_assert_no_req   51202068 0       1717       
c_gnt_deassert_no_req 51202068 0       285        
c_r_after_a           51202068 1406193 0          
c_req_until_gnt       51202068 651997  250        
c_wdata_stable        51202068 651997  250        
c_we_stable           51202068 651997  250        


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_load_assert.u_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 81.82 --     --      81.82 


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 61.29 --     --      61.29 


Module : 

SCORE  LINE   COND   ASSERT NAME                   
 81.82 --     --      81.82 uvma_obi_memory_assert 


Parent : 

SCORE  LINE   COND   ASSERT NAME            
--     --     --     --     obi_load_assert 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                 
 50.00 --     --      50.00 gen_1p2.u_1p2_assert 



-------------------------------------------------------------------------------
Assert Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_load_assert.u_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 11    11        100.00  9                 81.82   
Cover sequences  0     0                 0                         
Total            11    11        100.00  9                 81.82   



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                  Attempts Matches Incomplete 
c_addr_be_consistent  51202068 2376883 0          
c_addr_stable         51202068 992402  0          
c_be_contiguous       51202068 2376883 0          
c_be_not_zero         51202068 2376883 0          
c_be_stable           51202068 992402  0          
c_gnt_assert_no_req   51202068 0       2070       
c_gnt_deassert_no_req 51202068 0       283        
c_r_after_a           51202068 1384478 0          
c_req_until_gnt       51202068 992402  0          
c_wdata_stable        51202068 992402  0          
c_we_stable           51202068 992402  0          


===============================================================================
Module : uvma_cvxif_assert
===============================================================================
SCORE  LINE   COND   ASSERT 
 92.31 --     --      92.31 

Source File(s) : 

cva6/verif/sim//../core-v-verif/lib/uvm_agents/uvma_cvxif/src/uvma_cvxif_assert.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                    
 92.31 --     --      92.31 uvmt_cva6_tb.cva6_dut_wrap.cvxif_assert 



-------------------------------------------------------------------------------
Assert Coverage for Module : uvma_cvxif_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 13    13        100.00  12                92.31   
Cover sequences  0     0                 0                         
Total            13    13        100.00  12                92.31   



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                  Attempts Matches Incomplete 
cov_commit_for_issue  51202068 92906   0          
cov_commit_one_cycle  51202068 92906   0          
cov_compressed_instr  51202068 164164  0          
cov_reject_issue_req  51202068 33794   0          
cov_result_for_commit 51202068 59255   33651      
cov_result_stable     51202068 0       0          
cov_result_trn_end    51202068 59255   0          
cov_stable_issue      51202068 55459   0          
cov_uncompressed_resp 51202068 29335   0          
gen0[0].cov_rs        51202068 55423   0          
gen0[0].cov_rs_valid  51202068 55459   0          
gen0[1].cov_rs        51202068 55437   0          
gen0[1].cov_rs_valid  51202068 55459   0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cvxif_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 92.31 --     --      92.31 


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 92.31 --     --      92.31 


Module : 

SCORE  LINE   COND   ASSERT NAME              
 92.31 --     --      92.31 uvma_cvxif_assert 


Parent : 

SCORE  LINE   COND   ASSERT NAME          
--     --     --     --     cva6_dut_wrap 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : rr_arb_tree
===============================================================================
SCORE  LINE   COND   ASSERT 
 94.19 --      94.19 --     

Source File(s) : 

cva6/vendor/pulp-platform/common_cells/src/rr_arb_tree.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                                     
 94.19 --      94.19 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.genblk5[0].i_sel_rs1 
 94.19 --      94.19 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.genblk5[0].i_sel_rs2 
 94.19 --      94.19 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.genblk5[0].i_sel_rs3 



-------------------------------------------------------------------------------
Cond Coverage for Module : rr_arb_tree

               Total   Covered  Percent
Conditions        155      146    94.19
Logical           155      146    94.19
Non-Logical         0        0
Event               0        0

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 0)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 0)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[0].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(0))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(0))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[0].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[0].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx0] & gen_arbiter.gen_levels[0].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[1].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx0] & gen_arbiter.gen_levels[1].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[1].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[1].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx0] & ((~gen_arbiter.gen_levels[1].gen_level[1].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx0] & gen_arbiter.gen_levels[1].gen_level[1].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx0] & gen_arbiter.gen_levels[2].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[1].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[1].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[1].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx0] & gen_arbiter.gen_levels[2].gen_level[1].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[2].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[2].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[2].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Not Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx0] & gen_arbiter.gen_levels[2].gen_level[2].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Not Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Unreachable

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[3].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Unreachable
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[3].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1])

-1- Status
 0  Unreachable
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[3].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx0] & gen_arbiter.gen_levels[2].gen_level[3].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(0 * 2)] | gen_arbiter.req_d[((0 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(0 * 2)])) | (gen_arbiter.req_d[((0 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((0 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[0].sel ? data_i[((0 * 2) + 1)] : data_i[(0 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[0].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(0 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[0].sel)))

-1- -2- -3- Status
 0   1   1  Not Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[0].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((0 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[0].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(1 * 2)] | gen_arbiter.req_d[((1 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Not Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(1 * 2)])) | (gen_arbiter.req_d[((1 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((1 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Not Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[1].sel ? data_i[((1 * 2) + 1)] : data_i[(1 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[1].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(1 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[1].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Not Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[1].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((1 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[1].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Not Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(2 * 2)] | gen_arbiter.req_d[((2 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(2 * 2)])) | (gen_arbiter.req_d[((2 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((2 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[2].sel ? data_i[((2 * 2) + 1)] : data_i[(2 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[2].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(2 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[2].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[2].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((2 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[2].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(3 * 2)] | gen_arbiter.req_d[((3 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(3 * 2)])) | (gen_arbiter.req_d[((3 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((3 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[3].sel ? data_i[((3 * 2) + 1)] : data_i[(3 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[3].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(3 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[3].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[3].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((3 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[3].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       282
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[4].Idx0] & ((AxiVldRdy | gen_arbiter.req_d[(4 * 2)])))
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.genblk5[0].i_sel_rs1
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 94.19 --      94.19 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 94.19 --      94.19 --     


Module : 

SCORE  LINE   COND   ASSERT NAME        
 94.19 --      94.19 --     rr_arb_tree 


Parent : 

SCORE  LINE   COND   ASSERT NAME                  
100.00 100.00 100.00 --     i_issue_read_operands 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Cond Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.genblk5[0].i_sel_rs1

               Total   Covered  Percent
Conditions        155      146    94.19
Logical           155      146    94.19
Non-Logical         0        0
Event               0        0

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 0)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 0)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[0].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(0))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(0))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[0].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[0].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx0] & gen_arbiter.gen_levels[0].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[1].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx0] & gen_arbiter.gen_levels[1].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[1].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[1].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx0] & ((~gen_arbiter.gen_levels[1].gen_level[1].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx0] & gen_arbiter.gen_levels[1].gen_level[1].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx0] & gen_arbiter.gen_levels[2].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[1].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[1].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[1].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx0] & gen_arbiter.gen_levels[2].gen_level[1].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[2].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[2].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[2].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Not Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx0] & gen_arbiter.gen_levels[2].gen_level[2].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Not Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Unreachable

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[3].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Unreachable
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[3].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1])

-1- Status
 0  Unreachable
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[3].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx0] & gen_arbiter.gen_levels[2].gen_level[3].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(0 * 2)] | gen_arbiter.req_d[((0 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(0 * 2)])) | (gen_arbiter.req_d[((0 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((0 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[0].sel ? data_i[((0 * 2) + 1)] : data_i[(0 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[0].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(0 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[0].sel)))

-1- -2- -3- Status
 0   1   1  Not Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[0].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((0 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[0].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(1 * 2)] | gen_arbiter.req_d[((1 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Not Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(1 * 2)])) | (gen_arbiter.req_d[((1 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((1 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Not Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[1].sel ? data_i[((1 * 2) + 1)] : data_i[(1 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[1].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(1 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[1].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Not Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[1].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((1 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[1].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Not Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(2 * 2)] | gen_arbiter.req_d[((2 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(2 * 2)])) | (gen_arbiter.req_d[((2 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((2 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[2].sel ? data_i[((2 * 2) + 1)] : data_i[(2 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[2].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(2 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[2].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[2].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((2 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[2].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(3 * 2)] | gen_arbiter.req_d[((3 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(3 * 2)])) | (gen_arbiter.req_d[((3 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((3 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[3].sel ? data_i[((3 * 2) + 1)] : data_i[(3 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[3].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(3 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[3].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[3].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((3 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[3].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       282
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[4].Idx0] & ((AxiVldRdy | gen_arbiter.req_d[(4 * 2)])))
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.genblk5[0].i_sel_rs2
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 94.19 --      94.19 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 94.19 --      94.19 --     


Module : 

SCORE  LINE   COND   ASSERT NAME        
 94.19 --      94.19 --     rr_arb_tree 


Parent : 

SCORE  LINE   COND   ASSERT NAME                  
100.00 100.00 100.00 --     i_issue_read_operands 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Cond Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.genblk5[0].i_sel_rs2

               Total   Covered  Percent
Conditions        155      146    94.19
Logical           155      146    94.19
Non-Logical         0        0
Event               0        0

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 0)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 0)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[0].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(0))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(0))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[0].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[0].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx0] & gen_arbiter.gen_levels[0].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[1].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx0] & gen_arbiter.gen_levels[1].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[1].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[1].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx0] & ((~gen_arbiter.gen_levels[1].gen_level[1].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx0] & gen_arbiter.gen_levels[1].gen_level[1].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx0] & gen_arbiter.gen_levels[2].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[1].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[1].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[1].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx0] & gen_arbiter.gen_levels[2].gen_level[1].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[2].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[2].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[2].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Not Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx0] & gen_arbiter.gen_levels[2].gen_level[2].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Not Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Unreachable

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[3].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Unreachable
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[3].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1])

-1- Status
 0  Unreachable
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[3].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx0] & gen_arbiter.gen_levels[2].gen_level[3].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(0 * 2)] | gen_arbiter.req_d[((0 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(0 * 2)])) | (gen_arbiter.req_d[((0 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((0 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[0].sel ? data_i[((0 * 2) + 1)] : data_i[(0 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[0].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(0 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[0].sel)))

-1- -2- -3- Status
 0   1   1  Not Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[0].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((0 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[0].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(1 * 2)] | gen_arbiter.req_d[((1 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Not Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(1 * 2)])) | (gen_arbiter.req_d[((1 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((1 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Not Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[1].sel ? data_i[((1 * 2) + 1)] : data_i[(1 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[1].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(1 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[1].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Not Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[1].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((1 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[1].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Not Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(2 * 2)] | gen_arbiter.req_d[((2 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(2 * 2)])) | (gen_arbiter.req_d[((2 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((2 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[2].sel ? data_i[((2 * 2) + 1)] : data_i[(2 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[2].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(2 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[2].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[2].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((2 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[2].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(3 * 2)] | gen_arbiter.req_d[((3 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(3 * 2)])) | (gen_arbiter.req_d[((3 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((3 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[3].sel ? data_i[((3 * 2) + 1)] : data_i[(3 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[3].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(3 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[3].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[3].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((3 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[3].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       282
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[4].Idx0] & ((AxiVldRdy | gen_arbiter.req_d[(4 * 2)])))
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.genblk5[0].i_sel_rs3
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 94.19 --      94.19 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 94.19 --      94.19 --     


Module : 

SCORE  LINE   COND   ASSERT NAME        
 94.19 --      94.19 --     rr_arb_tree 


Parent : 

SCORE  LINE   COND   ASSERT NAME                  
100.00 100.00 100.00 --     i_issue_read_operands 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Cond Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.genblk5[0].i_sel_rs3

               Total   Covered  Percent
Conditions        155      146    94.19
Logical           155      146    94.19
Non-Logical         0        0
Event               0        0

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 0)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 0)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[0].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(0))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(0))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[0].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[0].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[0].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[0].gen_level[0].Idx0] & gen_arbiter.gen_levels[0].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[1].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[1].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[0].Idx0] & gen_arbiter.gen_levels[1].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 1)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[1].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1][((gen_arbiter.NumLevels - (unsigned'(1))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[1].gen_level[1].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[1].gen_level[1].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx0] & ((~gen_arbiter.gen_levels[1].gen_level[1].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[1].gen_level[1].Idx0] & gen_arbiter.gen_levels[1].gen_level[1].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[0].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[0].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[0].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[0].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[0].Idx0] & gen_arbiter.gen_levels[2].gen_level[0].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[1].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[1].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[1].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[1].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[1].Idx0] & gen_arbiter.gen_levels[2].gen_level[1].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[2].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Covered
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[2].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[2].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx1])

-1- Status
 0  Covered
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[2].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Covered
 1   0  Not Covered
 1   1  Covered

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[2].Idx0] & gen_arbiter.gen_levels[2].gen_level[2].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Not Covered

 LINE       293
 EXPRESSION (gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1] | gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)])
             ---------------------------------1--------------------------------   ------------------------------------2-----------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Unreachable

 LINE       296
 EXPRESSION 
 Number  Term
      1  ((~gen_arbiter.req_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1])) | 
      2  (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)]))

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Covered

 LINE       296
 SUB-EXPRESSION (gen_arbiter.req_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 2)])
                 ------------------------------------1-----------------------------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       298
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[3].sel ? (idx_t'({1'b1, gen_arbiter.index_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})) : (idx_t'({1'b0, gen_arbiter.index_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1][((gen_arbiter.NumLevels - (unsigned'(2))) - 2):0]})))

-1- Status
 0  Unreachable
 1  Covered

 LINE       302
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gen_levels[2].gen_level[3].sel ? gen_arbiter.data_nodes[(gen_arbiter.gen_levels[2].gen_level[3].Idx1 + 1)] : gen_arbiter.data_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx1])

-1- Status
 0  Unreachable
 1  Covered

 LINE       303
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx0] & ((~gen_arbiter.gen_levels[2].gen_level[3].sel)))
             ---------------------------------1--------------------------------   -----------------------2-----------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       304
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[2].gen_level[3].Idx0] & gen_arbiter.gen_levels[2].gen_level[3].sel)
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(0 * 2)] | gen_arbiter.req_d[((0 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(0 * 2)])) | (gen_arbiter.req_d[((0 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((0 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[0].sel ? data_i[((0 * 2) + 1)] : data_i[(0 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[0].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(0 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[0].sel)))

-1- -2- -3- Status
 0   1   1  Not Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[0].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((0 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[0].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(1 * 2)] | gen_arbiter.req_d[((1 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Not Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(1 * 2)])) | (gen_arbiter.req_d[((1 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((1 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Not Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[1].sel ? data_i[((1 * 2) + 1)] : data_i[(1 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[1].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(1 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[1].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Not Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[1].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((1 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[1].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Not Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(2 * 2)] | gen_arbiter.req_d[((2 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(2 * 2)])) | (gen_arbiter.req_d[((2 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((2 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[2].sel ? data_i[((2 * 2) + 1)] : data_i[(2 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[2].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(2 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[2].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[2].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((2 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[2].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       267
 EXPRESSION (gen_arbiter.req_d[(3 * 2)] | gen_arbiter.req_d[((3 * 2) + 1)])
             -------------1------------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       270
 EXPRESSION (((~gen_arbiter.req_d[(3 * 2)])) | (gen_arbiter.req_d[((3 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)]))
             ---------------1---------------   --------------------------------------------2-------------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       270
 SUB-EXPRESSION (gen_arbiter.req_d[((3 * 2) + 1)] & gen_arbiter.rr_q[((gen_arbiter.NumLevels - 1) - 3)])
                 ----------------1---------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Unreachable

 LINE       273
 EXPRESSION (gen_arbiter.gen_levels[3].gen_level[3].sel ? data_i[((3 * 2) + 1)] : data_i[(3 * 2)])
             ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[3].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[(3 * 2)])) & 
      3  ((~gen_arbiter.gen_levels[3].gen_level[3].sel)))

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       275
 EXPRESSION 
 Number  Term
      1  gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[3].Idx0] & 
      2  ((AxiVldRdy | gen_arbiter.req_d[((3 * 2) + 1)])) & 
      3  gen_arbiter.gen_levels[3].gen_level[3].sel)

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       282
 EXPRESSION (gen_arbiter.gnt_nodes[gen_arbiter.gen_levels[3].gen_level[4].Idx0] & ((AxiVldRdy | gen_arbiter.req_d[(4 * 2)])))
             ---------------------------------1--------------------------------   ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

===============================================================================
Module : scoreboard
===============================================================================
SCORE  LINE   COND   ASSERT 
 97.78  98.18  97.37 --     

Source File(s) : 

cva6/core/scoreboard.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                       
 97.78  98.18  97.37 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_scoreboard 



-------------------------------------------------------------------------------
Line Coverage for Module : scoreboard

             Line No.   Total   Covered  Percent
TOTAL                       55       54    98.18
ALWAYS            139        0        0
ALWAYS            139        4        4   100.00
ALWAYS            153        6        6   100.00
ALWAYS            168       34       33    97.06
ALWAYS            280        3        3   100.00
ALWAYS            307        8        8   100.00
INITIAL           325        0        0

138                       always_comb begin : commit_ports
139        1/1              for (int unsigned i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin
140        1/1                commit_instr_o[i] = mem_q[commit_pointer_q[i]].sbe;
141        1/1                commit_instr_o[i].trans_id = commit_pointer_q[i];
142        1/1                commit_drop_o[i] = mem_q[commit_pointer_q[i]].cancelled;
143                         end
144                       end
145                     
146                       assign issue_pointer[0] = issue_pointer_q;
147                       for (genvar i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
148                         assign issue_pointer[i+1] = issue_pointer[i] + 'd1;
149                       end
150                     
151                       // an instruction is ready for issue if we have place in the issue FIFO and it the decoder says it is valid
152                       always_comb begin
153        1/1              issue_instr_o = decoded_instr_i;
154        1/1              orig_instr_o  = orig_instr_i;
155        1/1              for (int unsigned i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
156                           // make sure we assign the correct trans ID
157        1/1                issue_instr_o[i].trans_id = issue_pointer[i];
158                     
159        1/1                issue_instr_valid_o[i]    = decoded_instr_valid_i[i] & ~issue_full[i];
160        1/1                decoded_instr_ack_o[i]    = issue_ack_i[i] & ~issue_full[i];
161                         end
162                       end
163                     
164                       // maintain a FIFO with issued instructions
165                       // keep track of all issued instructions
166                       always_comb begin : issue_fifo
167                         // default assignment
168        1/1              mem_n     = mem_q;
169        1/1              num_issue = '0;
170                     
171                         // if we got a acknowledge from the issue stage, put this scoreboard entry in the queue
172        1/1              for (int unsigned i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
173        1/1                if (decoded_instr_valid_i[i] && decoded_instr_ack_o[i] && !flush_unissued_instr_i) begin
174                             // the decoded instruction we put in there is valid (1st bit)
175                             // increase the issue counter and advance issue pointer
176        1/1                  num_issue += 'd1;
177        1/1                  mem_n[issue_pointer[i]] = '{
178                                 issued: 1'b1,
179                                 cancelled: 1'b0,
180                                 is_rd_fpr_flag: CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(decoded_instr_i[i].op),
181                                 sbe: decoded_instr_i[i]
182                             };
183                           end
                        MISSING_ELSE
184                         end
185                     
186                         // ------------
187                         // FU NONE
188                         // ------------
189        1/1              for (int unsigned i = 0; i < CVA6Cfg.NR_SB_ENTRIES; i++) begin
190                           // The FU is NONE -> this instruction is valid immediately
191        1/2     ==>        if (mem_q[i].sbe.fu == ariane_pkg::NONE && mem_q[i].issued) mem_n[i].sbe.valid = 1'b1;
                        MISSING_ELSE
192                         end
193                     
194                         // ------------
195                         // Write Back
196                         // ------------
197        1/1              for (int unsigned i = 0; i < CVA6Cfg.NrWbPorts; i++) begin
198                           // check if this instruction was issued (e.g.: it could happen after a flush that there is still
199                           // something in the pipeline e.g. an incomplete memory operation)
200        1/1                if (wt_valid_i[i] && mem_q[trans_id_i[i]].issued) begin
201        1/1                  if (CVA6Cfg.RVZCMP && mem_q[trans_id_i[i]].sbe.is_double_rd_macro_instr && mem_q[trans_id_i[i]].sbe.is_macro_instr) begin
202        unreachable            if (mem_q[trans_id_i[i]].sbe.is_last_macro_instr) begin
203        unreachable              mem_n[trans_id_i[i]].sbe.valid = 1'b1;
204        unreachable              mem_n[8'(trans_id_i[i])-1].sbe.valid = 1'b1;
205                               end else begin
206        unreachable              mem_n[trans_id_i[i]].sbe.valid = 1'b0;
207                               end
208                             end else begin
209        1/1                    mem_n[trans_id_i[i]].sbe.valid = 1'b1;
210                             end
211        1/1                  mem_n[trans_id_i[i]].sbe.result = wbdata_i[i];
212                             // save the target address of a branch (needed for debug in commit stage)
213        1/1                  if (CVA6Cfg.DebugEn) begin
214        unreachable            mem_n[trans_id_i[i]].sbe.bp.predict_address = resolved_branch_i.target_address;
215                             end
                        MISSING_ELSE
216        1/1                  if (mem_n[trans_id_i[i]].sbe.fu == ariane_pkg::CVXIF) begin
217        2/2                    if (x_we_i) mem_n[trans_id_i[i]].sbe.rd = x_rd_i;
218        1/1                    else mem_n[trans_id_i[i]].sbe.rd = 5'b0;
219                             end
                        MISSING_ELSE
220                             // write the exception back if it is valid
221        2/2                  if (ex_i[i].valid) mem_n[trans_id_i[i]].sbe.ex = ex_i[i];
222                             // write the fflags back from the FPU (exception valid is never set), leave tval intact
223        1/1                  else if(CVA6Cfg.FpPresent && (mem_q[trans_id_i[i]].sbe.fu == ariane_pkg::FPU || mem_q[trans_id_i[i]].sbe.fu == ariane_pkg::FPU_VEC)) begin
224        unreachable            mem_n[trans_id_i[i]].sbe.ex.cause = ex_i[i].cause;
225                             end
                        MISSING_ELSE
226                           end
                        MISSING_ELSE
227                         end
228                     
229                         // ------------
230                         // Cancel
231                         // ------------
232        1/1              if (CVA6Cfg.SpeculativeSb) begin
233        unreachable        if (bmiss) begin
234        unreachable          if (after_flu_wb != issue_pointer[0]) begin
235        unreachable            mem_n[after_flu_wb].cancelled = 1'b1;
236                             end
                   ==>  MISSING_ELSE
237                           end
                   ==>  MISSING_ELSE
238                         end
                        MISSING_ELSE
239                     
240                         // ------------
241                         // Commit Port
242                         // ------------
243                         // we've got an acknowledge from commit
244        1/1              for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin
245        1/1                if (commit_ack_i[i]) begin
246                             // this instruction is no longer in issue e.g.: it is considered finished
247        1/1                  mem_n[commit_pointer_q[i]].issued    = 1'b0;
248        1/1                  mem_n[commit_pointer_q[i]].cancelled = 1'b0;
249        1/1                  mem_n[commit_pointer_q[i]].sbe.valid = 1'b0;
250                           end
                        MISSING_ELSE
251                         end
252                     
253                         // ------
254                         // Flush
255                         // ------
256        1/1              if (flush_i) begin
257        1/1                for (int unsigned i = 0; i < CVA6Cfg.NR_SB_ENTRIES; i++) begin
258                             // set all valid flags for all entries to zero
259        1/1                  mem_n[i].issued       = 1'b0;
260        1/1                  mem_n[i].cancelled    = 1'b0;
261        1/1                  mem_n[i].sbe.valid    = 1'b0;
262        1/1                  mem_n[i].sbe.ex.valid = 1'b0;
263                           end
264                         end
                        MISSING_ELSE
265                       end
266                     
267                       assign bmiss = resolved_branch_i.is_mispredict;
268                       assign after_flu_wb = trans_id_i[ariane_pkg::FLU_WB] + 'd1;
269                     
270                       // FIFO counter updates
271                       if (CVA6Cfg.NrCommitPorts == 2) begin : gen_commit_ports
272                         assign num_commit = commit_ack_i[1] + commit_ack_i[0];
273                       end else begin : gen_one_commit_port
274                         assign num_commit = commit_ack_i[0];
275                       end
276                     
277                       assign commit_pointer_n[0] = (flush_i) ? '0 : commit_pointer_q[0] + num_commit;
278                     
279                       always_comb begin : assign_issue_pointer_n
280        1/1              issue_pointer_n = issue_pointer[num_issue];
281        2/2              if (flush_i) issue_pointer_n = '0;
                        MISSING_ELSE
282                       end
283                     
284                       // precompute offsets for commit slots
285                       for (genvar k = 1; k < CVA6Cfg.NrCommitPorts; k++) begin : gen_cnt_incr
286                         assign commit_pointer_n[k] = (flush_i) ? '0 : commit_pointer_n[0] + unsigned'(k);
287                       end
288                     
289                       // Forwarding logic
290                       writeback_t [CVA6Cfg.NrWbPorts-1:0] wb;
291                       for (genvar i = 0; i < CVA6Cfg.NrWbPorts; i++) begin
292                         assign wb[i].valid = wt_valid_i[i];
293                         assign wb[i].data = wbdata_i[i];
294                         assign wb[i].ex_valid = ex_i[i].valid;
295                         assign wb[i].trans_id = trans_id_i[i];
296                       end
297                     
298                       assign fwd_o.still_issued = still_issued;
299                       assign fwd_o.issue_pointer = issue_pointer;
300                       assign fwd_o.wb = wb;
301                       for (genvar i = 0; i < CVA6Cfg.NR_SB_ENTRIES; i++) begin
302                         assign fwd_o.sbe[i] = mem_q[i].sbe;
303                       end
304                     
305                       // sequential process
306                       always_ff @(posedge clk_i or negedge rst_ni) begin : regs
307        1/1              if (!rst_ni) begin
308        1/1                mem_q            <= '{default: sb_mem_t'(0)};
309        1/1                commit_pointer_q <= '0;
310        1/1                issue_pointer_q  <= '0;
311                         end else begin
312        1/1                issue_pointer_q <= issue_pointer_n;
313        1/1                mem_q <= mem_n;
314        1/1                mem_q[x_id_i].sbe.rd <= (x_transaction_accepted_i && ~x_issue_writeback_i) ? 5'b0 : mem_n[x_id_i].sbe.rd;
315        1/1                commit_pointer_q <= commit_pointer_n;

-------------------------------------------------------------------------------
Cond Coverage for Module : scoreboard

               Total   Covered  Percent
Conditions         38       37    97.37
Logical            38       37    97.37
Non-Logical         0        0
Event               0        0

 LINE       159
 EXPRESSION (decoded_instr_valid_i[i] & ((~issue_full[i])))
             ------------1-----------   ---------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       160
 EXPRESSION (issue_ack_i[i] & ((~issue_full[i])))
             -------1------   ---------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       173
 EXPRESSION (decoded_instr_valid_i[i] && decoded_instr_ack_o[i] && ((!flush_unissued_instr_i)))
             ------------1-----------    -----------2----------    -------------3-------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       191
 EXPRESSION ((mem_q[i].sbe.fu == NONE) && mem_q[i].issued)
             ------------1------------    -------2-------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Not Covered

 LINE       191
 SUB-EXPRESSION (mem_q[i].sbe.fu == NONE)
                ------------1------------

-1- Status
 0  Covered
 1  Covered

 LINE       200
 EXPRESSION (wt_valid_i[i] && mem_q[trans_id_i[i]].issued)
             ------1------    -------------2-------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       216
 EXPRESSION (mem_n[trans_id_i[i]].sbe.fu == CVXIF)
            -------------------1------------------

-1- Status
 0  Covered
 1  Covered

 LINE       234
 EXPRESSION (after_flu_wb != issue_pointer[0])
            -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       314
 EXPRESSION ((x_transaction_accepted_i && ((~x_issue_writeback_i))) ? 5'b0 : mem_n[x_id_i].sbe.rd)
             ---------------------------1--------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       314
 SUB-EXPRESSION (x_transaction_accepted_i && ((~x_issue_writeback_i)))
                 ------------1-----------    ------------2-----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       128
 EXPRESSION (((&issued_instrs_even_odd[0])) && ((&issued_instrs_even_odd[1])))
             ---------------1--------------    ---------------2--------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       277
 EXPRESSION (flush_i ? '0 : ((commit_pointer_q[0] + num_commit)))
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       120
 EXPRESSION (mem_q[0].issued & ((~(1'b0 & mem_q[0].cancelled))))
             -------1-------   ----------------2---------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       120
 EXPRESSION (mem_q[1].issued & ((~(1'b0 & mem_q[1].cancelled))))
             -------1-------   ----------------2---------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       120
 EXPRESSION (mem_q[2].issued & ((~(1'b0 & mem_q[2].cancelled))))
             -------1-------   ----------------2---------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       120
 EXPRESSION (mem_q[3].issued & ((~(1'b0 & mem_q[3].cancelled))))
             -------1-------   ----------------2---------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_scoreboard
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 97.78  98.18  97.37 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 97.78  98.18  97.37 --     


Module : 

SCORE  LINE   COND   ASSERT NAME       
 97.78  98.18  97.37 --     scoreboard 


Parent : 

SCORE  LINE   COND   ASSERT NAME          
100.00 --     100.00 --     issue_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : load_store_unit
===============================================================================
SCORE  LINE   COND   ASSERT 
 98.75  97.50 100.00 --     

Source File(s) : 

cva6/core/load_store_unit.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                             
 98.75  97.50 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i 



-------------------------------------------------------------------------------
Line Coverage for Module : load_store_unit

             Line No.   Total   Covered  Percent
TOTAL                       40       39    97.50
ALWAYS            514       17       17   100.00
ALWAYS            598       23       22    95.65

513                     
514        1/1              ld_valid_i        = 1'b0;
515        1/1              st_valid_i        = 1'b0;
516                     
517        1/1              translation_req   = 1'b0;
518        1/1              mmu_vaddr         = {CVA6Cfg.VLEN{1'b0}};
519        1/1              mmu_tinst         = {32{1'b0}};
520        1/1              mmu_hs_ld_st_inst = 1'b0;
521        1/1              mmu_hlvx_inst     = 1'b0;
522                     
523                         // check the operation to activate the right functional unit accordingly
524        1/1              unique case (lsu_ctrl.fu)
525                           // all loads go here
526                           LOAD: begin
527        1/1                  ld_valid_i      = lsu_ctrl.valid;
528        1/1                  translation_req = ld_translation_req;
529        1/1                  mmu_vaddr       = ld_vaddr;
530        1/1                  if (CVA6Cfg.RVH) begin
531        unreachable            mmu_tinst         = ld_tinst;
532        unreachable            mmu_hs_ld_st_inst = ld_hs_ld_st_inst;
533        unreachable            mmu_hlvx_inst     = ld_hlvx_inst;
534                             end
                        MISSING_ELSE
535                           end
536                           // all stores go here
537                           STORE: begin
538        1/1                  st_valid_i      = lsu_ctrl.valid;
539        1/1                  translation_req = st_translation_req;
540        1/1                  mmu_vaddr       = st_vaddr;
541        1/1                  if (CVA6Cfg.RVH) begin
542        unreachable            mmu_tinst         = st_tinst;
543        unreachable            mmu_hs_ld_st_inst = st_hs_ld_st_inst;
544        unreachable            mmu_hlvx_inst     = st_hlvx_inst;
545                             end
                        MISSING_ELSE
546                           end
547                           // not relevant for the LSU
548        1/1                default: ;
549                         endcase
550                       end
551                     
552                       // ------------------------
553                       // Hypervisor Load/Store
554                       // ------------------------
555                       // determine whether this is a hypervisor load or store
556                       if (CVA6Cfg.RVH) begin
557                         always_comb begin : hyp_ld_st
558                           // check the operator to activate the right functional unit accordingly
559                           hs_ld_st_inst = 1'b0;
560                           hlvx_inst     = 1'b0;
561                           case (lsu_ctrl.operation)
562                             // all loads go here
563                             HLV_B, HLV_BU, HLV_H, HLV_HU, HLV_W, HSV_B, HSV_H, HSV_W, HLV_WU, HLV_D, HSV_D: begin
564                               hs_ld_st_inst = 1'b1;
565                             end
566                             HLVX_WU, HLVX_HU: begin
567                               hs_ld_st_inst = 1'b1;
568                               hlvx_inst     = 1'b1;
569                             end
570                             default: ;
571                           endcase
572                         end
573                       end else begin
574                         assign hs_ld_st_inst = 1'b0;
575                         assign hlvx_inst     = 1'b0;
576                       end
577                     
578                       // ---------------
579                       // Byte Enable
580                       // ---------------
581                       // we can generate the byte enable from the virtual address since the last
582                       // 12 bit are the same anyway
583                       // and we can always generate the byte enable from the address at hand
584                     
585                       if (CVA6Cfg.IS_XLEN64) begin : gen_8b_be
586                         assign be_i = be_gen(vaddr_i[2:0], extract_transfer_size(fu_data_i.operation));
587                       end else begin : gen_4b_be
588                         assign be_i = be_gen_32(vaddr_i[1:0], extract_transfer_size(fu_data_i.operation));
589                       end
590                     
591                       // ------------------------
592                       // Misaligned Exception
593                       // ------------------------
594                       // we can detect a misaligned exception immediately
595                       // the misaligned exception is passed to the functional unit via the MMU, which in case
596                       // can augment the exception if other memory related exceptions like a page fault or access errors
597                       always_comb begin : data_misaligned_detection
598        1/1              misaligned_exception = {
599                           {CVA6Cfg.XLEN{1'b0}}, {CVA6Cfg.XLEN{1'b0}}, {CVA6Cfg.GPLEN{1'b0}}, {32{1'b0}}, 1'b0, 1'b0
600                         };
601        1/1              data_misaligned = 1'b0;
602                     
603        1/1              if (lsu_ctrl.valid) begin
604        1/1                if (CVA6Cfg.IS_XLEN64) begin
605        unreachable          case (lsu_ctrl.operation)
606                               // double word
607                               LD, SD, FLD, FSD,
608                                       AMO_LRD, AMO_SCD,
609                                       AMO_SWAPD, AMO_ADDD, AMO_ANDD, AMO_ORD,
610                                       AMO_XORD, AMO_MAXD, AMO_MAXDU, AMO_MIND,
611                                       AMO_MINDU, HLV_D, HSV_D: begin
612        unreachable              if (lsu_ctrl.vaddr[2:0] != 3'b000) begin
613        unreachable                data_misaligned = 1'b1;
614                                 end
                   ==>  MISSING_ELSE
615                               end
616        unreachable            default: ;
617                             endcase
618                           end
                        MISSING_ELSE
619        1/1                case (lsu_ctrl.operation)
620                             // word
621                             LW, LWU, SW, FLW, FSW,
622                                     AMO_LRW, AMO_SCW,
623                                     AMO_SWAPW, AMO_ADDW, AMO_ANDW, AMO_ORW,
624                                     AMO_XORW, AMO_MAXW, AMO_MAXWU, AMO_MINW,
625                                     AMO_MINWU, HLV_W, HLV_WU, HLVX_WU, HSV_W: begin
626        1/1                    if (lsu_ctrl.vaddr[1:0] != 2'b00) begin
627        1/1                      data_misaligned = 1'b1;
628                               end
                        MISSING_ELSE
629                             end
630                             // half word
631                             LH, LHU, SH, FLH, FSH, HLV_H, HLV_HU, HLVX_HU, HSV_H: begin
632        1/1                    if (lsu_ctrl.vaddr[0] != 1'b0) begin
633        1/1                      data_misaligned = 1'b1;
634                               end
                        MISSING_ELSE
635                             end
636                             // byte -> is always aligned
637        1/1                  default: ;
638                           endcase
639                         end
                        MISSING_ELSE
640                     
641        1/1              if (data_misaligned) begin
642        1/1                case (lsu_ctrl.fu)
643                             LOAD: begin
644        1/1                    misaligned_exception.cause = riscv::LD_ADDR_MISALIGNED;
645        1/1                    misaligned_exception.valid = 1'b1;
646        1/1                    if (CVA6Cfg.TvalEn)
647        unreachable              misaligned_exception.tval = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, lsu_ctrl.vaddr};
                        MISSING_ELSE
648        1/1                    if (CVA6Cfg.RVH) begin
649        unreachable              misaligned_exception.tval2 = '0;
650        unreachable              misaligned_exception.tinst = lsu_ctrl.tinst;
651        unreachable              misaligned_exception.gva   = ld_st_v_i;
652                               end
                        MISSING_ELSE
653                             end
654                             STORE: begin
655                     
656        1/1                    misaligned_exception.cause = riscv::ST_ADDR_MISALIGNED;
657        1/1                    misaligned_exception.valid = 1'b1;
658        1/1                    if (CVA6Cfg.TvalEn)
659        unreachable              misaligned_exception.tval = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, lsu_ctrl.vaddr};
                        MISSING_ELSE
660        1/1                    if (CVA6Cfg.RVH) begin
661        unreachable              misaligned_exception.tval2 = '0;
662        unreachable              misaligned_exception.tinst = lsu_ctrl.tinst;
663        unreachable              misaligned_exception.gva   = ld_st_v_i;
664                               end
                        MISSING_ELSE
665                             end
666        0/1     ==>          default: ;
667                           endcase
668                         end
                        MISSING_ELSE
669                     
670        1/1              if (CVA6Cfg.MmuPresent && en_ld_st_translation_i && lsu_ctrl.overflow) begin
671                     
672        unreachable        case (lsu_ctrl.fu)
673                             LOAD: begin
674        unreachable            misaligned_exception.cause = riscv::LOAD_PAGE_FAULT;
675        unreachable            misaligned_exception.valid = 1'b1;
676        unreachable            if (CVA6Cfg.TvalEn)
677        unreachable              misaligned_exception.tval = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, lsu_ctrl.vaddr};
                   ==>  MISSING_ELSE
678        unreachable            if (CVA6Cfg.RVH) begin
679        unreachable              misaligned_exception.tval2 = '0;
680        unreachable              misaligned_exception.tinst = lsu_ctrl.tinst;
681        unreachable              misaligned_exception.gva   = ld_st_v_i;
682                               end
                   ==>  MISSING_ELSE
683                             end
684                             STORE: begin
685        unreachable            misaligned_exception.cause = riscv::STORE_PAGE_FAULT;
686        unreachable            misaligned_exception.valid = 1'b1;
687        unreachable            if (CVA6Cfg.TvalEn)
688        unreachable              misaligned_exception.tval = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, lsu_ctrl.vaddr};
                   ==>  MISSING_ELSE
689        unreachable            if (CVA6Cfg.RVH) begin
690        unreachable              misaligned_exception.tval2 = '0;
691        unreachable              misaligned_exception.tinst = lsu_ctrl.tinst;
692        unreachable              misaligned_exception.gva   = ld_st_v_i;
693                               end
                   ==>  MISSING_ELSE
694                             end
695        unreachable          default: ;
696                           endcase
697                         end
                        MISSING_ELSE
698                     
699        1/1              if (CVA6Cfg.MmuPresent && CVA6Cfg.RVH && en_ld_st_g_translation_i && !en_ld_st_translation_i && lsu_ctrl.g_overflow) begin
700                     
701        unreachable        case (lsu_ctrl.fu)
702                             LOAD: begin
703        unreachable            misaligned_exception.cause = riscv::LOAD_GUEST_PAGE_FAULT;
704        unreachable            misaligned_exception.valid = 1'b1;
705        unreachable            if (CVA6Cfg.TvalEn)
706        unreachable              misaligned_exception.tval = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, lsu_ctrl.vaddr};
                   ==>  MISSING_ELSE
707        unreachable            if (CVA6Cfg.RVH) begin
708        unreachable              misaligned_exception.tval2 = '0;
709        unreachable              misaligned_exception.tinst = lsu_ctrl.tinst;
710        unreachable              misaligned_exception.gva   = ld_st_v_i;
711                               end
                   ==>  MISSING_ELSE
712                             end
713                             STORE: begin
714        unreachable            misaligned_exception.cause = riscv::STORE_GUEST_PAGE_FAULT;
715        unreachable            misaligned_exception.valid = 1'b1;
716        unreachable            if (CVA6Cfg.TvalEn)
717        unreachable              misaligned_exception.tval = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, lsu_ctrl.vaddr};
                   ==>  MISSING_ELSE
718        unreachable            if (CVA6Cfg.RVH) begin
719        unreachable              misaligned_exception.tval2 = '0;
720        unreachable              misaligned_exception.tinst = lsu_ctrl.tinst;
721        unreachable              misaligned_exception.gva   = ld_st_v_i;
722                               end
                   ==>  MISSING_ELSE
723                             end
724        unreachable          default: ;
725                           endcase
726                         end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : load_store_unit

               Total   Covered  Percent
Conditions          4        4   100.00
Logical             4        4   100.00
Non-Logical         0        0
Event               0        0

 LINE       612
 EXPRESSION (lsu_ctrl.vaddr[2:0] != 3'b0)
            --------------1--------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       626
 EXPRESSION (lsu_ctrl.vaddr[1:0] != 2'b0)
            --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       632
 EXPRESSION (lsu_ctrl.vaddr[0] != 1'b0)
            -------------1-------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 98.75  97.50 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.83  99.65 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME            
 98.75  97.50 100.00 --     load_store_unit 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     ex_stage_i 


Subtrees :

SCORE  LINE   COND   ASSERT NAME         
100.00 100.00 100.00 --     i_load_unit  
100.00 100.00 100.00 --     i_store_unit 
100.00 100.00 100.00 --     lsu_bypass_i 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : csr_regfile
===============================================================================
SCORE  LINE   COND   ASSERT 
 98.78 100.00  97.56 --     

Source File(s) : 

cva6/core/csr_regfile.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                          
 98.78 100.00  97.56 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.csr_regfile_i 



-------------------------------------------------------------------------------
Line Coverage for Module : csr_regfile

             Line No.   Total   Covered  Percent
TOTAL                      549      549   100.00
ALWAYS            379      159      159   100.00
ALWAYS            933      272      272   100.00
ALWAYS           2239       21       21   100.00
ALWAYS           2303        8        8   100.00
ALWAYS           2415        8        8   100.00
ALWAYS           2448        5        5   100.00
ALWAYS           2462       10       10   100.00
ALWAYS           2518        5        5   100.00
ALWAYS           2616       57       57   100.00
ALWAYS           2781        0        0
ALWAYS           2781        4        4   100.00

378                         // a read access exception can only occur if we attempt to read a CSR which does not exist
379        1/1              read_access_exception = 1'b0;
380        1/1              virtual_read_access_exception = 1'b0;
381        1/1              csr_rdata = '0;
382        1/1              perf_addr_o = csr_addr.address[11:0];
383        1/1              if (csr_read) begin
384        1/1                unique case (conv_csr_addr.address)
385                             riscv::CSR_FFLAGS: begin
386        1/1                    if (fp_csrs_usable) begin
387        unreachable              csr_rdata = {{CVA6Cfg.XLEN - 5{1'b0}}, fcsr_q.fflags};
388                               end else begin
389        1/1                      read_access_exception = 1'b1;
390                               end
391                             end
392                             riscv::CSR_FRM: begin
393        1/1                    if (fp_csrs_usable) begin
394        unreachable              csr_rdata = {{CVA6Cfg.XLEN - 3{1'b0}}, fcsr_q.frm};
395                               end else begin
396        1/1                      read_access_exception = 1'b1;
397                               end
398                             end
399                             riscv::CSR_FCSR: begin
400        1/1                    if (fp_csrs_usable) begin
401        unreachable              csr_rdata = {{CVA6Cfg.XLEN - 8{1'b0}}, fcsr_q.frm, fcsr_q.fflags};
402                               end else begin
403        1/1                      read_access_exception = 1'b1;
404                               end
405                             end
406                             riscv::CSR_JVT: begin
407        1/1                    if (CVA6Cfg.RVZCMT) begin
408        unreachable              csr_rdata = {jvt_q.base, jvt_q.mode};
409                               end else begin
410        1/1                      read_access_exception = 1'b1;
411                               end
412                             end
413                             // non-standard extension
414                             riscv::CSR_FTRAN: begin
415        1/1                    if (fp_csrs_usable) begin
416        unreachable              csr_rdata = {{CVA6Cfg.XLEN - 7{1'b0}}, fcsr_q.fprec};
417                               end else begin
418        1/1                      read_access_exception = 1'b1;
419                               end
420                             end
421                             // debug registers
422                             riscv::CSR_DCSR:
423        1/1(1 unreachable)          if (CVA6Cfg.DebugEn) csr_rdata = {{CVA6Cfg.XLEN - 32{1'b0}}, dcsr_q};
424        1/1                  else read_access_exception = 1'b1;
425                             riscv::CSR_DPC:
426        1/1(1 unreachable)          if (CVA6Cfg.DebugEn) csr_rdata = dpc_q;
427        1/1                  else read_access_exception = 1'b1;
428                             riscv::CSR_DSCRATCH0:
429        1/1(1 unreachable)          if (CVA6Cfg.DebugEn) csr_rdata = dscratch0_q;
430        1/1                  else read_access_exception = 1'b1;
431                             riscv::CSR_DSCRATCH1:
432        1/1(1 unreachable)          if (CVA6Cfg.DebugEn) csr_rdata = dscratch1_q;
433        1/1                  else read_access_exception = 1'b1;
434                             // trigger module registers
435        1/1                  riscv::CSR_TSELECT: read_access_exception = 1'b1;  // not implemented
436        1/1                  riscv::CSR_TDATA1: read_access_exception = 1'b1;  // not implemented
437        1/1                  riscv::CSR_TDATA2: read_access_exception = 1'b1;  // not implemented
438        1/1                  riscv::CSR_TDATA3: read_access_exception = 1'b1;  // not implemented
439                             riscv::CSR_VSSTATUS:
440        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = vsstatus_extended;
441        1/1                  else read_access_exception = 1'b1;
442                             riscv::CSR_VSIE:
443        1/1                  if (CVA6Cfg.RVH)
444        unreachable            csr_rdata = (mie_q & VS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0] & hideleg_q) >> 1;
445        1/1                  else read_access_exception = 1'b1;
446                             riscv::CSR_VSIP:
447        1/1                  if (CVA6Cfg.RVH)
448        unreachable            csr_rdata = (mip_q & VS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0] & hideleg_q) >> 1;
449        1/1                  else read_access_exception = 1'b1;
450                             riscv::CSR_VSTVEC:
451        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = vstvec_q;
452        1/1                  else read_access_exception = 1'b1;
453                             riscv::CSR_VSSCRATCH:
454        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = vsscratch_q;
455        1/1                  else read_access_exception = 1'b1;
456                             riscv::CSR_VSEPC:
457        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = vsepc_q;
458        1/1                  else read_access_exception = 1'b1;
459                             riscv::CSR_VSCAUSE:
460        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = vscause_q;
461        1/1                  else read_access_exception = 1'b1;
462                             riscv::CSR_VSTVAL:
463        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = vstval_q;
464        1/1                  else read_access_exception = 1'b1;
465                             riscv::CSR_VSATP:
466                             // intercept reads to VSATP if in VS-Mode and VTVM is enabled
467        1/1                  if (CVA6Cfg.RVH) begin
468        unreachable            if (priv_lvl_o == riscv::PRIV_LVL_S && hstatus_q.vtvm && v_q)
469        unreachable              virtual_read_access_exception = 1'b1;
470        unreachable            else csr_rdata = vsatp_q;
471                             end else begin
472        1/1                    read_access_exception = 1'b1;
473                             end
474                             // supervisor registers
475                             riscv::CSR_SSTATUS: begin
476        1/1(1 unreachable)            if (CVA6Cfg.RVS) csr_rdata = mstatus_extended & SMODE_STATUS_READ_MASK[CVA6Cfg.XLEN-1:0];
477        1/1                    else read_access_exception = 1'b1;
478                             end
479                             riscv::CSR_SIE:
480        1/1                  if (CVA6Cfg.RVS)
481        unreachable            csr_rdata = (CVA6Cfg.RVH) ? mie_q & mideleg_q & ~HS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0] : mie_q & mideleg_q;
482        1/1                  else read_access_exception = 1'b1;
483                             riscv::CSR_SIP:
484        1/1                  if (CVA6Cfg.RVS)
485        unreachable            csr_rdata = (CVA6Cfg.RVH) ? mip_q & mideleg_q & ~HS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0] : mip_q & mideleg_q;
486        1/1                  else read_access_exception = 1'b1;
487                             riscv::CSR_STVEC:
488        1/1(1 unreachable)          if (CVA6Cfg.RVS) csr_rdata = stvec_q;
489        1/1                  else read_access_exception = 1'b1;
490                             riscv::CSR_SCOUNTEREN:
491        1/1(1 unreachable)          if (CVA6Cfg.RVS) csr_rdata = scounteren_q;
492        1/1                  else read_access_exception = 1'b1;
493                             riscv::CSR_SSCRATCH:
494        1/1(1 unreachable)          if (CVA6Cfg.RVS) csr_rdata = sscratch_q;
495        1/1                  else read_access_exception = 1'b1;
496                             riscv::CSR_SEPC:
497        1/1(1 unreachable)          if (CVA6Cfg.RVS) csr_rdata = sepc_q;
498        1/1                  else read_access_exception = 1'b1;
499                             riscv::CSR_SCAUSE:
500        1/1(1 unreachable)          if (CVA6Cfg.RVS) csr_rdata = scause_q;
501        1/1                  else read_access_exception = 1'b1;
502                             riscv::CSR_STVAL:
503        1/1(1 unreachable)          if (CVA6Cfg.RVS) csr_rdata = stval_q;
504        1/1                  else read_access_exception = 1'b1;
505                             riscv::CSR_SATP: begin
506        1/1                    if (CVA6Cfg.RVS) begin
507                                 // intercept reads to SATP if in S-Mode and TVM is enabled
508        unreachable              if (priv_lvl_o == riscv::PRIV_LVL_S && mstatus_q.tvm) begin
509        unreachable                read_access_exception = 1'b1;
510                                 end else begin
511        unreachable                csr_rdata = satp_q;
512                                 end
513                               end else begin
514        1/1                      read_access_exception = 1'b1;
515                               end
516                             end
517                             riscv::CSR_SENVCFG:
518        1/1(1 unreachable)          if (CVA6Cfg.RVS) csr_rdata = '0 | fiom_q;
519        1/1                  else read_access_exception = 1'b1;
520                             // hypervisor mode registers
521                             riscv::CSR_HSTATUS:
522        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = hstatus_q[CVA6Cfg.XLEN-1:0];
523        1/1                  else read_access_exception = 1'b1;
524                             riscv::CSR_HEDELEG:
525        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = hedeleg_q;
526        1/1                  else read_access_exception = 1'b1;
527                             riscv::CSR_HIDELEG:
528        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = hideleg_q;
529        1/1                  else read_access_exception = 1'b1;
530                             riscv::CSR_HIE:
531        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = mie_q & HS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0];
532        1/1                  else read_access_exception = 1'b1;
533                             riscv::CSR_HIP:
534        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = mip_q & HS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0];
535        1/1                  else read_access_exception = 1'b1;
536                             riscv::CSR_HVIP:
537        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = mip_q & VS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0];
538        1/1                  else read_access_exception = 1'b1;
539                             riscv::CSR_HCOUNTEREN:
540        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = hcounteren_q;
541        1/1                  else read_access_exception = 1'b1;
542                             riscv::CSR_HTVAL:
543        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = htval_q;
544        1/1                  else read_access_exception = 1'b1;
545                             riscv::CSR_HTINST:
546        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = htinst_q;
547        1/1                  else read_access_exception = 1'b1;
548                             riscv::CSR_HGEIE:
549        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = '0;
550        1/1                  else read_access_exception = 1'b1;
551                             riscv::CSR_HGEIP:
552        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = '0;
553        1/1                  else read_access_exception = 1'b1;
554                             riscv::CSR_HENVCFG:
555        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = '0 | {{CVA6Cfg.XLEN - 1{1'b0}}, fiom_q};
556        1/1                  else read_access_exception = 1'b1;
557                             riscv::CSR_HGATP: begin
558        1/1                    if (CVA6Cfg.RVH) begin
559                                 // intercept reads to HGATP if in HS-Mode and TVM is enabled
560        unreachable              if (priv_lvl_o == riscv::PRIV_LVL_S && !v_q && mstatus_q.tvm) begin
561        unreachable                read_access_exception = 1'b1;
562                                 end else begin
563        unreachable                csr_rdata = hgatp_q;
564                                 end
565                               end else begin
566        1/1                      read_access_exception = 1'b1;
567                               end
568                             end
569                     
570                             // machine mode registers
571        1/1                  riscv::CSR_MSTATUS: csr_rdata = mstatus_extended;
572                             riscv::CSR_MSTATUSH:
573        2/2                  if (CVA6Cfg.XLEN == 32) csr_rdata = '0;
574        unreachable          else read_access_exception = 1'b1;
575        1/1                  riscv::CSR_MISA: csr_rdata = IsaCode;
576                             riscv::CSR_MEDELEG:
577        1/1(1 unreachable)          if (CVA6Cfg.RVS) csr_rdata = medeleg_q;
578        1/1                  else read_access_exception = 1'b1;
579                             riscv::CSR_MIDELEG:
580        1/1(1 unreachable)          if (CVA6Cfg.RVS) csr_rdata = mideleg_q;
581        1/1                  else read_access_exception = 1'b1;
582        1/1                  riscv::CSR_MIE: csr_rdata = mie_q;
583        1/1                  riscv::CSR_MTVEC: csr_rdata = mtvec_q;
584                             riscv::CSR_MCOUNTEREN:
585        1/1(1 unreachable)          if (CVA6Cfg.RVU) csr_rdata = mcounteren_q;
586        1/1                  else read_access_exception = 1'b1;
587        1/1                  riscv::CSR_MSCRATCH: csr_rdata = mscratch_q;
588        1/1                  riscv::CSR_MEPC: csr_rdata = mepc_q;
589        1/1                  riscv::CSR_MCAUSE: csr_rdata = mcause_q;
590                             riscv::CSR_MTVAL:
591        1/1(1 unreachable)          if (CVA6Cfg.TvalEn) csr_rdata = mtval_q;
592        1/1                  else csr_rdata = '0;
593                             riscv::CSR_MTINST:
594        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = mtinst_q;
595        1/1                  else read_access_exception = 1'b1;
596                             riscv::CSR_MTVAL2:
597        1/1(1 unreachable)          if (CVA6Cfg.RVH) csr_rdata = mtval2_q;
598        1/1                  else read_access_exception = 1'b1;
599        1/1                  riscv::CSR_MIP: csr_rdata = mip_q;
600                             riscv::CSR_MENVCFG: begin
601        1/1(1 unreachable)            if (CVA6Cfg.RVU) csr_rdata = '0 | fiom_q;
602        1/1                    else read_access_exception = 1'b1;
603                             end
604                             riscv::CSR_MENVCFGH: begin
605        1/1(1 unreachable)            if (CVA6Cfg.RVU && CVA6Cfg.XLEN == 32) csr_rdata = '0;
606        1/1                    else read_access_exception = 1'b1;
607                             end
608        1/1                  riscv::CSR_MVENDORID: csr_rdata = {{CVA6Cfg.XLEN - 32{1'b0}}, OPENHWGROUP_MVENDORID};
609        1/1                  riscv::CSR_MARCHID: csr_rdata = {{CVA6Cfg.XLEN - 32{1'b0}}, ARIANE_MARCHID};
610        1/1                  riscv::CSR_MIMPID: csr_rdata = '0;  // not implemented
611        1/1                  riscv::CSR_MHARTID: csr_rdata = hart_id_i;
612        1/1                  riscv::CSR_MCONFIGPTR: csr_rdata = '0;  // not implemented
613                             riscv::CSR_MCOUNTINHIBIT:
614        1/1                  csr_rdata = {{(CVA6Cfg.XLEN - (MHPMCounterNum + 3)) {1'b0}}, mcountinhibit_q};
615                             // Counters and Timers
616        1/1                  riscv::CSR_MCYCLE: csr_rdata = cycle_q[CVA6Cfg.XLEN-1:0];
617                             riscv::CSR_MCYCLEH:
618        2/2                  if (CVA6Cfg.XLEN == 32) csr_rdata = cycle_q[63:32];
619        unreachable          else read_access_exception = 1'b1;
620        1/1                  riscv::CSR_MINSTRET: csr_rdata = instret_q[CVA6Cfg.XLEN-1:0];
621                             riscv::CSR_MINSTRETH:
622        2/2                  if (CVA6Cfg.XLEN == 32) csr_rdata = instret_q[63:32];
623        unreachable          else read_access_exception = 1'b1;
624                             riscv::CSR_CYCLE:
625        1/1(1 unreachable)          if (CVA6Cfg.RVZicntr) csr_rdata = cycle_q[CVA6Cfg.XLEN-1:0];
626        1/1                  else read_access_exception = 1'b1;
627                             riscv::CSR_CYCLEH:
628        1/1                  if (CVA6Cfg.RVZicntr)
629        unreachable            if (CVA6Cfg.XLEN == 32) csr_rdata = cycle_q[63:32];
630        unreachable            else read_access_exception = 1'b1;
631        1/1                  else read_access_exception = 1'b1;
632                             riscv::CSR_INSTRET:
633        1/1(1 unreachable)          if (CVA6Cfg.RVZicntr) csr_rdata = instret_q[CVA6Cfg.XLEN-1:0];
634        1/1                  else read_access_exception = 1'b1;
635                             riscv::CSR_INSTRETH:
636        1/1                  if (CVA6Cfg.RVZicntr)
637        unreachable            if (CVA6Cfg.XLEN == 32) csr_rdata = instret_q[63:32];
638        unreachable            else read_access_exception = 1'b1;
639        1/1                  else read_access_exception = 1'b1;
640                             //Event Selector
641                             riscv::CSR_MHPM_EVENT_3,
642                                     riscv::CSR_MHPM_EVENT_4,
643                                     riscv::CSR_MHPM_EVENT_5,
644                                     riscv::CSR_MHPM_EVENT_6,
645                                     riscv::CSR_MHPM_EVENT_7,
646                                     riscv::CSR_MHPM_EVENT_8,
647                                     riscv::CSR_MHPM_EVENT_9,
648                                     riscv::CSR_MHPM_EVENT_10,
649                                     riscv::CSR_MHPM_EVENT_11,
650                                     riscv::CSR_MHPM_EVENT_12,
651                                     riscv::CSR_MHPM_EVENT_13,
652                                     riscv::CSR_MHPM_EVENT_14,
653                                     riscv::CSR_MHPM_EVENT_15,
654                                     riscv::CSR_MHPM_EVENT_16,
655                                     riscv::CSR_MHPM_EVENT_17,
656                                     riscv::CSR_MHPM_EVENT_18,
657                                     riscv::CSR_MHPM_EVENT_19,
658                                     riscv::CSR_MHPM_EVENT_20,
659                                     riscv::CSR_MHPM_EVENT_21,
660                                     riscv::CSR_MHPM_EVENT_22,
661                                     riscv::CSR_MHPM_EVENT_23,
662                                     riscv::CSR_MHPM_EVENT_24,
663                                     riscv::CSR_MHPM_EVENT_25,
664                                     riscv::CSR_MHPM_EVENT_26,
665                                     riscv::CSR_MHPM_EVENT_27,
666                                     riscv::CSR_MHPM_EVENT_28,
667                                     riscv::CSR_MHPM_EVENT_29,
668                                     riscv::CSR_MHPM_EVENT_30,
669                                     riscv::CSR_MHPM_EVENT_31 :
670        1/1                  csr_rdata = perf_data_i;
671                     
672                             riscv::CSR_MHPM_COUNTER_3,
673                                     riscv::CSR_MHPM_COUNTER_4,
674                                     riscv::CSR_MHPM_COUNTER_5,
675                                     riscv::CSR_MHPM_COUNTER_6,
676                                     riscv::CSR_MHPM_COUNTER_7,
677                                     riscv::CSR_MHPM_COUNTER_8,
678                                     riscv::CSR_MHPM_COUNTER_9,
679                                     riscv::CSR_MHPM_COUNTER_10,
680                                     riscv::CSR_MHPM_COUNTER_11,
681                                     riscv::CSR_MHPM_COUNTER_12,
682                                     riscv::CSR_MHPM_COUNTER_13,
683                                     riscv::CSR_MHPM_COUNTER_14,
684                                     riscv::CSR_MHPM_COUNTER_15,
685                                     riscv::CSR_MHPM_COUNTER_16,
686                                     riscv::CSR_MHPM_COUNTER_17,
687                                     riscv::CSR_MHPM_COUNTER_18,
688                                     riscv::CSR_MHPM_COUNTER_19,
689                                     riscv::CSR_MHPM_COUNTER_20,
690                                     riscv::CSR_MHPM_COUNTER_21,
691                                     riscv::CSR_MHPM_COUNTER_22,
692                                     riscv::CSR_MHPM_COUNTER_23,
693                                     riscv::CSR_MHPM_COUNTER_24,
694                                     riscv::CSR_MHPM_COUNTER_25,
695                                     riscv::CSR_MHPM_COUNTER_26,
696                                     riscv::CSR_MHPM_COUNTER_27,
697                                     riscv::CSR_MHPM_COUNTER_28,
698                                     riscv::CSR_MHPM_COUNTER_29,
699                                     riscv::CSR_MHPM_COUNTER_30,
700                                     riscv::CSR_MHPM_COUNTER_31 :
701        1/1                  csr_rdata = perf_data_i;
702                     
703                             riscv::CSR_MHPM_COUNTER_3H,
704                                     riscv::CSR_MHPM_COUNTER_4H,
705                                     riscv::CSR_MHPM_COUNTER_5H,
706                                     riscv::CSR_MHPM_COUNTER_6H,
707                                     riscv::CSR_MHPM_COUNTER_7H,
708                                     riscv::CSR_MHPM_COUNTER_8H,
709                                     riscv::CSR_MHPM_COUNTER_9H,
710                                     riscv::CSR_MHPM_COUNTER_10H,
711                                     riscv::CSR_MHPM_COUNTER_11H,
712                                     riscv::CSR_MHPM_COUNTER_12H,
713                                     riscv::CSR_MHPM_COUNTER_13H,
714                                     riscv::CSR_MHPM_COUNTER_14H,
715                                     riscv::CSR_MHPM_COUNTER_15H,
716                                     riscv::CSR_MHPM_COUNTER_16H,
717                                     riscv::CSR_MHPM_COUNTER_17H,
718                                     riscv::CSR_MHPM_COUNTER_18H,
719                                     riscv::CSR_MHPM_COUNTER_19H,
720                                     riscv::CSR_MHPM_COUNTER_20H,
721                                     riscv::CSR_MHPM_COUNTER_21H,
722                                     riscv::CSR_MHPM_COUNTER_22H,
723                                     riscv::CSR_MHPM_COUNTER_23H,
724                                     riscv::CSR_MHPM_COUNTER_24H,
725                                     riscv::CSR_MHPM_COUNTER_25H,
726                                     riscv::CSR_MHPM_COUNTER_26H,
727                                     riscv::CSR_MHPM_COUNTER_27H,
728                                     riscv::CSR_MHPM_COUNTER_28H,
729                                     riscv::CSR_MHPM_COUNTER_29H,
730                                     riscv::CSR_MHPM_COUNTER_30H,
731                                     riscv::CSR_MHPM_COUNTER_31H :
732        2/2                  if (CVA6Cfg.XLEN == 32) csr_rdata = perf_data_i;
733        unreachable          else read_access_exception = 1'b1;
734                     
735                             // Performance counters (User Mode - R/O Shadows)
736                             riscv::CSR_HPM_COUNTER_3,
737                                     riscv::CSR_HPM_COUNTER_4,
738                                     riscv::CSR_HPM_COUNTER_5,
739                                     riscv::CSR_HPM_COUNTER_6,
740                                     riscv::CSR_HPM_COUNTER_7,
741                                     riscv::CSR_HPM_COUNTER_8,
742                                     riscv::CSR_HPM_COUNTER_9,
743                                     riscv::CSR_HPM_COUNTER_10,
744                                     riscv::CSR_HPM_COUNTER_11,
745                                     riscv::CSR_HPM_COUNTER_12,
746                                     riscv::CSR_HPM_COUNTER_13,
747                                     riscv::CSR_HPM_COUNTER_14,
748                                     riscv::CSR_HPM_COUNTER_15,
749                                     riscv::CSR_HPM_COUNTER_16,
750                                     riscv::CSR_HPM_COUNTER_17,
751                                     riscv::CSR_HPM_COUNTER_18,
752                                     riscv::CSR_HPM_COUNTER_19,
753                                     riscv::CSR_HPM_COUNTER_20,
754                                     riscv::CSR_HPM_COUNTER_21,
755                                     riscv::CSR_HPM_COUNTER_22,
756                                     riscv::CSR_HPM_COUNTER_23,
757                                     riscv::CSR_HPM_COUNTER_24,
758                                     riscv::CSR_HPM_COUNTER_25,
759                                     riscv::CSR_HPM_COUNTER_26,
760                                     riscv::CSR_HPM_COUNTER_27,
761                                     riscv::CSR_HPM_COUNTER_28,
762                                     riscv::CSR_HPM_COUNTER_29,
763                                     riscv::CSR_HPM_COUNTER_30,
764                                     riscv::CSR_HPM_COUNTER_31 :
765        1/1                  if (CVA6Cfg.RVZihpm) begin
766        unreachable            csr_rdata = perf_data_i;
767                             end else begin
768        1/1                    read_access_exception = 1'b1;
769                             end
770                     
771                             riscv::CSR_HPM_COUNTER_3H,
772                                     riscv::CSR_HPM_COUNTER_4H,
773                                     riscv::CSR_HPM_COUNTER_5H,
774                                     riscv::CSR_HPM_COUNTER_6H,
775                                     riscv::CSR_HPM_COUNTER_7H,
776                                     riscv::CSR_HPM_COUNTER_8H,
777                                     riscv::CSR_HPM_COUNTER_9H,
778                                     riscv::CSR_HPM_COUNTER_10H,
779                                     riscv::CSR_HPM_COUNTER_11H,
780                                     riscv::CSR_HPM_COUNTER_12H,
781                                     riscv::CSR_HPM_COUNTER_13H,
782                                     riscv::CSR_HPM_COUNTER_14H,
783                                     riscv::CSR_HPM_COUNTER_15H,
784                                     riscv::CSR_HPM_COUNTER_16H,
785                                     riscv::CSR_HPM_COUNTER_17H,
786                                     riscv::CSR_HPM_COUNTER_18H,
787                                     riscv::CSR_HPM_COUNTER_19H,
788                                     riscv::CSR_HPM_COUNTER_20H,
789                                     riscv::CSR_HPM_COUNTER_21H,
790                                     riscv::CSR_HPM_COUNTER_22H,
791                                     riscv::CSR_HPM_COUNTER_23H,
792                                     riscv::CSR_HPM_COUNTER_24H,
793                                     riscv::CSR_HPM_COUNTER_25H,
794                                     riscv::CSR_HPM_COUNTER_26H,
795                                     riscv::CSR_HPM_COUNTER_27H,
796                                     riscv::CSR_HPM_COUNTER_28H,
797                                     riscv::CSR_HPM_COUNTER_29H,
798                                     riscv::CSR_HPM_COUNTER_30H,
799                                     riscv::CSR_HPM_COUNTER_31H :
800        1/1                  if (CVA6Cfg.RVZihpm) begin
801        unreachable            if (CVA6Cfg.XLEN == 32) csr_rdata = perf_data_i;
802        unreachable            else read_access_exception = 1'b1;
803                             end else begin
804        1/1                    read_access_exception = 1'b1;
805                             end
806                     
807                             // custom (non RISC-V) cache control
808        1/1                  riscv::CSR_DCACHE: csr_rdata = dcache_q;
809        1/1                  riscv::CSR_ICACHE: csr_rdata = icache_q;
810                             // custom (non RISC-V) accelerator memory consistency mode
811                             riscv::CSR_ACC_CONS: begin
812        1/1                    if (CVA6Cfg.EnableAccelerator) begin
813        unreachable              csr_rdata = acc_cons_q;
814                               end else begin
815        1/1                      read_access_exception = 1'b1;
816                               end
817                             end
818                             // PMPs
819                             riscv::CSR_PMPCFG0,
820                                     riscv::CSR_PMPCFG1,
821                                     riscv::CSR_PMPCFG2,
822                                     riscv::CSR_PMPCFG3,
823                                     riscv::CSR_PMPCFG4,
824                                     riscv::CSR_PMPCFG5,
825                                     riscv::CSR_PMPCFG6,
826                                     riscv::CSR_PMPCFG7,
827                                     riscv::CSR_PMPCFG8,
828                                     riscv::CSR_PMPCFG9,
829                                     riscv::CSR_PMPCFG10,
830                                     riscv::CSR_PMPCFG11,
831                                     riscv::CSR_PMPCFG12,
832                                     riscv::CSR_PMPCFG13,
833                                     riscv::CSR_PMPCFG14,
834                                     riscv::CSR_PMPCFG15: begin
835                               // index is calculated using PMPCFG0 as the offset
836        1/1                    automatic logic [11:0] index = csr_addr.address[11:0] - riscv::CSR_PMPCFG0;
837                     
838                               // if index is not even and XLEN==64, raise exception
839        1/1(1 unreachable)            if (CVA6Cfg.XLEN == 64 && index[0] == 1'b1) read_access_exception = 1'b1;
840                               else begin
841        1/1                      csr_rdata = pmpcfg_q[index*4+:CVA6Cfg.XLEN/8];
842                               end
843                             end
844                             // PMPADDR
845                             riscv::CSR_PMPADDR0,
846                                     riscv::CSR_PMPADDR1,
847                                     riscv::CSR_PMPADDR2,
848                                     riscv::CSR_PMPADDR3,
849                                     riscv::CSR_PMPADDR4,
850                                     riscv::CSR_PMPADDR5,
851                                     riscv::CSR_PMPADDR6,
852                                     riscv::CSR_PMPADDR7,
853                                     riscv::CSR_PMPADDR8,
854                                     riscv::CSR_PMPADDR9,
855                                     riscv::CSR_PMPADDR10,
856                                     riscv::CSR_PMPADDR11,
857                                     riscv::CSR_PMPADDR12,
858                                     riscv::CSR_PMPADDR13,
859                                     riscv::CSR_PMPADDR14,
860                                     riscv::CSR_PMPADDR15,
861                                     riscv::CSR_PMPADDR16,
862                                     riscv::CSR_PMPADDR17,
863                                     riscv::CSR_PMPADDR18,
864                                     riscv::CSR_PMPADDR19,
865                                     riscv::CSR_PMPADDR20,
866                                     riscv::CSR_PMPADDR21,
867                                     riscv::CSR_PMPADDR22,
868                                     riscv::CSR_PMPADDR23,
869                                     riscv::CSR_PMPADDR24,
870                                     riscv::CSR_PMPADDR25,
871                                     riscv::CSR_PMPADDR26,
872                                     riscv::CSR_PMPADDR27,
873                                     riscv::CSR_PMPADDR28,
874                                     riscv::CSR_PMPADDR29,
875                                     riscv::CSR_PMPADDR30,
876                                     riscv::CSR_PMPADDR31,
877                                     riscv::CSR_PMPADDR32,
878                                     riscv::CSR_PMPADDR33,
879                                     riscv::CSR_PMPADDR34,
880                                     riscv::CSR_PMPADDR35,
881                                     riscv::CSR_PMPADDR36,
882                                     riscv::CSR_PMPADDR37,
883                                     riscv::CSR_PMPADDR38,
884                                     riscv::CSR_PMPADDR39,
885                                     riscv::CSR_PMPADDR40,
886                                     riscv::CSR_PMPADDR41,
887                                     riscv::CSR_PMPADDR42,
888                                     riscv::CSR_PMPADDR43,
889                                     riscv::CSR_PMPADDR44,
890                                     riscv::CSR_PMPADDR45,
891                                     riscv::CSR_PMPADDR46,
892                                     riscv::CSR_PMPADDR47,
893                                     riscv::CSR_PMPADDR48,
894                                     riscv::CSR_PMPADDR49,
895                                     riscv::CSR_PMPADDR50,
896                                     riscv::CSR_PMPADDR51,
897                                     riscv::CSR_PMPADDR52,
898                                     riscv::CSR_PMPADDR53,
899                                     riscv::CSR_PMPADDR54,
900                                     riscv::CSR_PMPADDR55,
901                                     riscv::CSR_PMPADDR56,
902                                     riscv::CSR_PMPADDR57,
903                                     riscv::CSR_PMPADDR58,
904                                     riscv::CSR_PMPADDR59,
905                                     riscv::CSR_PMPADDR60,
906                                     riscv::CSR_PMPADDR61,
907                                     riscv::CSR_PMPADDR62,
908                                     riscv::CSR_PMPADDR63: begin
909                               // index is calculated using PMPADDR0 as the offset
910        1/1                    automatic logic [11:0] index = csr_addr.address[11:0] - riscv::CSR_PMPADDR0;
911                               // Important: we only support granularity 8 bytes (G=1)
912                               // -> last bit of pmpaddr must be set 0/1 based on the mode:
913                               // NA4, NAPOT: 1
914                               // TOR, OFF:   0
915        1/1                    if (CVA6Cfg.PMPNapotEn && pmpcfg_q[index].addr_mode[1] == 1'b1)
916        unreachable              csr_rdata = {pmpaddr_q[index][CVA6Cfg.PLEN-3:1], 1'b1};
917        1/1                    else csr_rdata = {pmpaddr_q[index][CVA6Cfg.PLEN-3:1], 1'b0};
918                             end
919        1/1                  default: read_access_exception = 1'b1;
920                           endcase
921                         end
                        MISSING_ELSE
922                       end
923                       // ---------------------------
924                       // CSR Write and update logic
925                       // ---------------------------
926                       logic [CVA6Cfg.XLEN-1:0] mask;
927                       always_comb begin : csr_update
928                         automatic satp_t satp;
929                         automatic satp_t vsatp;
930                         automatic hgatp_t hgatp;
931                         automatic logic [63:0] instret;
932                     
933        1/1              if (CVA6Cfg.RVS) begin
934        unreachable        satp = satp_q;
935                         end
                        MISSING_ELSE
936        1/1              if (CVA6Cfg.RVH) begin
937        unreachable        hgatp = hgatp_q;
938        unreachable        vsatp = vsatp_q;
939                         end
                        MISSING_ELSE
940        1/1              instret         = instret_q;
941                     
942        1/1              mcountinhibit_d = mcountinhibit_q;
943                     
944                         // --------------------
945                         // Counters
946                         // --------------------
947        1/1              cycle_d         = cycle_q;
948        1/1              instret_d       = instret_q;
949        1/1              if (!(debug_mode)) begin
950                           // increase instruction retired counter
951        1/1                if (commit_ack_i[0] && !(ex_i.valid && CVA6Cfg.SpeculativeSb) && (!CVA6Cfg.PerfCounterEn || (CVA6Cfg.PerfCounterEn && !mcountinhibit_q[2])))
952        1/1                  instret++;
                        MISSING_ELSE
953        1/1                if (CVA6Cfg.NrCommitPorts != 1)
954        unreachable          for (int i = 1; i < CVA6Cfg.NrCommitPorts; i++) begin
955        unreachable            if (commit_ack_i[i] && !ex_i.valid && (!CVA6Cfg.PerfCounterEn || (CVA6Cfg.PerfCounterEn && !mcountinhibit_q[2])))
956        unreachable              instret++;
                   ==>  MISSING_ELSE
957                             end
958                           instret_d = instret;
                        MISSING_ELSE
958        1/1                instret_d = instret;
959                           // increment the cycle count
960        1/1                if (!CVA6Cfg.PerfCounterEn || (CVA6Cfg.PerfCounterEn && !mcountinhibit_q[0]))
961        1/1                  cycle_d = cycle_q + 1'b1;
962        unreachable        else cycle_d = cycle_q;
963                         end
                   ==>  MISSING_ELSE
964                     
965        1/1              eret_o                          = 1'b0;
966        1/1              flush_o                         = 1'b0;
967        1/1              update_access_exception         = 1'b0;
968        1/1              virtual_update_access_exception = 1'b0;
969                     
970        1/1              set_debug_pc_o                  = 1'b0;
971                     
972        1/1              perf_we_o                       = 1'b0;
973        1/1              perf_data_o                     = 'b0;
974        1/1              if (CVA6Cfg.RVZCMT) begin
975        unreachable        jvt_d = jvt_q;
976                         end
                        MISSING_ELSE
977        1/1              fcsr_d       = fcsr_q;
978                     
979        1/1              priv_lvl_d   = priv_lvl_q;
980        1/1              if (CVA6Cfg.RVH) begin
981        unreachable        v_d        = v_q;
982                         end
                        MISSING_ELSE
983        1/1              if (CVA6Cfg.DebugEn) begin
984        unreachable        debug_mode_d = debug_mode_q;
985                         end
                        MISSING_ELSE
986                     
987        1/1              if (CVA6Cfg.DebugEn) begin
988        unreachable        dcsr_d      = dcsr_q;
989        unreachable        dpc_d       = dpc_q;
990        unreachable        dscratch0_d = dscratch0_q;
991        unreachable        dscratch1_d = dscratch1_q;
992                         end
                        MISSING_ELSE
993        1/1              mstatus_d = mstatus_q;
994        1/1              if (CVA6Cfg.RVH) begin
995        unreachable        hstatus_d  = hstatus_q;
996        unreachable        vsstatus_d = vsstatus_q;
997                         end
                        MISSING_ELSE
998                     
999                         // check whether we come out of reset
1000                        // this is a workaround. some tools have issues
1001                        // having boot_addr_i in the asynchronous
1002                        // reset assignment to mtvec_d, even though
1003                        // boot_addr_i will be assigned a constant
1004                        // on the top-level.
1005       1/1              if (mtvec_rst_load_q) begin
1006       1/1                mtvec_d = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, boot_addr_i} + 'h40;
1007                        end else begin
1008       1/1                mtvec_d = mtvec_q;
1009                        end
1010                    
1011       1/1              if (CVA6Cfg.RVS) begin
1012       unreachable        medeleg_d = medeleg_q;
1013       unreachable        mideleg_d = mideleg_q;
1014                        end
                        MISSING_ELSE
1015       1/1              mip_d        = mip_q;
1016       1/1              mie_d        = mie_q;
1017       1/1              mepc_d       = mepc_q;
1018       1/1              mcause_d     = mcause_q;
1019       1/1              mcounteren_d = mcounteren_q;
1020       1/1              mscratch_d   = mscratch_q;
1021       1/1(1 unreachable)      if (CVA6Cfg.TvalEn) mtval_d = mtval_q;
                        MISSING_ELSE
1022       1/1              if (CVA6Cfg.RVH) begin
1023       unreachable        mtinst_d = mtinst_q;
1024       unreachable        mtval2_d = mtval2_q;
1025                        end
                        MISSING_ELSE
1026                    
1027       1/1              fiom_d     = fiom_q;
1028       1/1              dcache_d   = dcache_q;
1029       1/1              icache_d   = icache_q;
1030       1/1              acc_cons_d = acc_cons_q;
1031                    
1032       1/1              if (CVA6Cfg.RVH) begin
1033       unreachable        vstvec_d                 = vstvec_q;
1034       unreachable        vsscratch_d              = vsscratch_q;
1035       unreachable        vsepc_d                  = vsepc_q;
1036       unreachable        vscause_d                = vscause_q;
1037       unreachable        vstval_d                 = vstval_q;
1038       unreachable        vsatp_d                  = vsatp_q;
1039       unreachable        hgatp_d                  = hgatp_q;
1040       unreachable        hedeleg_d                = hedeleg_q;
1041       unreachable        hideleg_d                = hideleg_q;
1042       unreachable        hgeie_d                  = hgeie_q;
1043       unreachable        hcounteren_d             = hcounteren_q;
1044       unreachable        htinst_d                 = htinst_q;
1045       unreachable        htval_d                  = htval_q;
1046       unreachable        en_ld_st_g_translation_d = en_ld_st_g_translation_q;
1047                        end
                        MISSING_ELSE
1048                    
1049       1/1              if (CVA6Cfg.RVS) begin
1050       unreachable        sepc_d       = sepc_q;
1051       unreachable        scause_d     = scause_q;
1052       unreachable        stvec_d      = stvec_q;
1053       unreachable        scounteren_d = scounteren_q;
1054       unreachable        sscratch_d   = sscratch_q;
1055       unreachable        stval_d      = stval_q;
1056       unreachable        satp_d       = satp_q;
1057                        end
                        MISSING_ELSE
1058                    
1059       1/1              en_ld_st_translation_d = en_ld_st_translation_q;
1060       1/1              dirty_fp_state_csr     = 1'b0;
1061                    
1062       1/1              pmpcfg_d               = pmpcfg_q;
1063       1/1              pmpaddr_d              = pmpaddr_q;
1064                    
1065                        // check for correct access rights and that we are writing
1066       1/1              if (csr_we) begin
1067       1/1                unique case (conv_csr_addr.address)
1068                            // Floating-Point
1069                            riscv::CSR_FFLAGS: begin
1070       1/1                    if (fp_csrs_usable) begin
1071       unreachable              dirty_fp_state_csr = 1'b1;
1072       unreachable              fcsr_d.fflags = csr_wdata[4:0];
1073                                // this instruction has side-effects
1074       unreachable              flush_o = 1'b1;
1075                              end else begin
1076       1/1                      update_access_exception = 1'b1;
1077                              end
1078                            end
1079                            riscv::CSR_FRM: begin
1080       1/1                    if (fp_csrs_usable) begin
1081       unreachable              dirty_fp_state_csr = 1'b1;
1082       unreachable              fcsr_d.frm    = csr_wdata[2:0];
1083                                // this instruction has side-effects
1084       unreachable              flush_o = 1'b1;
1085                              end else begin
1086       1/1                      update_access_exception = 1'b1;
1087                              end
1088                            end
1089                            riscv::CSR_FCSR: begin
1090       1/1                    if (fp_csrs_usable) begin
1091       unreachable              dirty_fp_state_csr = 1'b1;
1092       unreachable              fcsr_d[7:0] = csr_wdata[7:0];  // ignore writes to reserved space
1093                                // this instruction has side-effects
1094       unreachable              flush_o = 1'b1;
1095                              end else begin
1096       1/1                      update_access_exception = 1'b1;
1097                              end
1098                            end
1099                            riscv::CSR_FTRAN: begin
1100       1/1                    if (fp_csrs_usable) begin
1101       unreachable              dirty_fp_state_csr = 1'b1;
1102       unreachable              fcsr_d.fprec = csr_wdata[6:0];  // ignore writes to reserved space
1103                                // this instruction has side-effects
1104       unreachable              flush_o = 1'b1;
1105                              end else begin
1106       1/1                      update_access_exception = 1'b1;
1107                              end
1108                            end
1109                            // debug CSR
1110                            riscv::CSR_DCSR: begin
1111       1/1                    if (CVA6Cfg.DebugEn) begin
1112       unreachable              dcsr_d           = csr_wdata[31:0];
1113                                // debug is implemented
1114       unreachable              dcsr_d.xdebugver = 4'h4;
1115                                // currently not supported
1116       unreachable              dcsr_d.nmip      = 1'b0;
1117       unreachable              dcsr_d.stopcount = 1'b0;
1118       unreachable              dcsr_d.stoptime  = 1'b0;
1119                              end else begin
1120       1/1                      update_access_exception = 1'b1;
1121                              end
1122                            end
1123                            riscv::CSR_DPC:
1124       1/1(1 unreachable)          if (CVA6Cfg.DebugEn) dpc_d = csr_wdata;
1125       1/1                  else update_access_exception = 1'b1;
1126                            riscv::CSR_DSCRATCH0:
1127       1/1(1 unreachable)          if (CVA6Cfg.DebugEn) dscratch0_d = csr_wdata;
1128       1/1                  else update_access_exception = 1'b1;
1129                            riscv::CSR_DSCRATCH1:
1130       1/1(1 unreachable)          if (CVA6Cfg.DebugEn) dscratch1_d = csr_wdata;
1131       1/1                  else update_access_exception = 1'b1;
1132                            riscv::CSR_JVT: begin
1133       1/1                    if (CVA6Cfg.RVZCMT) begin
1134       unreachable              jvt_d.base = csr_wdata[CVA6Cfg.XLEN-1:6];
1135       unreachable              jvt_d.mode = 6'b000000;
1136                              end else begin
1137       1/1                      update_access_exception = 1'b1;
1138                              end
1139                            end
1140                            // trigger module CSRs
1141       1/1                  riscv::CSR_TSELECT: update_access_exception = 1'b1;  // not implemented
1142       1/1                  riscv::CSR_TDATA1: update_access_exception = 1'b1;  // not implemented
1143       1/1                  riscv::CSR_TDATA2: update_access_exception = 1'b1;  // not implemented
1144       1/1                  riscv::CSR_TDATA3: update_access_exception = 1'b1;  // not implemented
1145                            // virtual supervisor registers
1146                            riscv::CSR_VSSTATUS: begin
1147       1/1                    if (CVA6Cfg.RVH) begin
1148       unreachable              mask = ariane_pkg::SMODE_STATUS_WRITE_MASK[CVA6Cfg.XLEN-1:0];
1149       unreachable              vsstatus_d = (vsstatus_q & ~{{64-CVA6Cfg.XLEN{1'b0}}, mask}) | {{64-CVA6Cfg.XLEN{1'b0}}, (csr_wdata & mask)};
1150                                // hardwire to zero if floating point extension is not present
1151       unreachable              vsstatus_d.xs = riscv::Off;
1152       unreachable              if (!CVA6Cfg.FpPresent) begin
1153       unreachable                vsstatus_d.fs = riscv::Off;
1154                                end
                   ==>  MISSING_ELSE
1155                                // this instruction has side-effects
1156       unreachable              flush_o = 1'b1;
1157                              end else begin
1158       1/1                      update_access_exception = 1'b1;
1159                              end
1160                            end
1161                            riscv::CSR_VSIE:
1162       1/1(1 unreachable)          if (CVA6Cfg.RVH) mie_d = (mie_q & ~hideleg_q) | ((csr_wdata << 1) & hideleg_q);
1163       1/1                  else update_access_exception = 1'b1;
1164                            riscv::CSR_VSIP: begin
1165       1/1                    if (CVA6Cfg.RVH) begin
1166                                // only the virtual supervisor software interrupt is write-able, iff delegated
1167       unreachable              mask  = CVA6Cfg.XLEN'(riscv::MIP_VSSIP) & hideleg_q;
1168       unreachable              mip_d = (mip_q & ~mask) | ((csr_wdata << 1) & mask);
1169                              end else begin
1170       1/1                      update_access_exception = 1'b1;
1171                              end
1172                            end
1173                            riscv::CSR_VSTVEC: begin
1174       1/1                    if (CVA6Cfg.RVH) begin
1175       unreachable              vstvec_d = {csr_wdata[CVA6Cfg.XLEN-1:2], 1'b0, csr_wdata[0]};
1176                              end else begin
1177       1/1                      update_access_exception = 1'b1;
1178                              end
1179                            end
1180                            riscv::CSR_VSSCRATCH:
1181       1/1(1 unreachable)          if (CVA6Cfg.RVH) vsscratch_d = csr_wdata;
1182       1/1                  else update_access_exception = 1'b1;
1183                            riscv::CSR_VSEPC:
1184       1/1(1 unreachable)          if (CVA6Cfg.RVH) vsepc_d = {csr_wdata[CVA6Cfg.XLEN-1:1], 1'b0};
1185       1/1                  else update_access_exception = 1'b1;
1186                            riscv::CSR_VSCAUSE:
1187       1/1(1 unreachable)          if (CVA6Cfg.RVH) vscause_d = csr_wdata;
1188       1/1                  else update_access_exception = 1'b1;
1189                            riscv::CSR_VSTVAL:
1190       1/1(1 unreachable)          if (CVA6Cfg.RVH) vstval_d = csr_wdata;
1191       1/1                  else update_access_exception = 1'b1;
1192                            // virtual supervisor address translation and protection
1193                            riscv::CSR_VSATP: begin
1194       1/1                    if (CVA6Cfg.RVH) begin
1195       unreachable              if (priv_lvl_o == riscv::PRIV_LVL_S && hstatus_q.vtvm && v_q) begin
1196       unreachable                virtual_update_access_exception = 1'b1;
1197                                end else begin
1198       unreachable                vsatp = satp_t'(csr_wdata);
1199                                  // only make ASID_LEN - 1 bit stick, that way software can figure out how many ASID bits are supported
1200       unreachable                vsatp.asid = vsatp.asid & {{(CVA6Cfg.ASIDW - CVA6Cfg.ASID_WIDTH) {1'b0}}, {CVA6Cfg.ASID_WIDTH{1'b1}}};
1201                                  // only update if we actually support this mode
1202       unreachable                if (config_pkg::vm_mode_t'(vsatp.mode) == config_pkg::ModeOff ||
1203                                                    config_pkg::vm_mode_t'(vsatp.mode) == CVA6Cfg.MODE_SV)
1204       unreachable                  vsatp_d = vsatp;
                   ==>  MISSING_ELSE
1205                                end
1206                                // changing the mode can have side-effects on address translation (e.g.: other instructions), re-fetch
1207                                // the next instruction by executing a flush
1208       unreachable              flush_o = 1'b1;
1209                              end else begin
1210       1/1                      update_access_exception = 1'b1;
1211                              end
1212                            end
1213                            // sstatus is a subset of mstatus - mask it accordingly
1214                            riscv::CSR_SSTATUS: begin
1215       1/1                    if (CVA6Cfg.RVS) begin
1216       unreachable              mask = ariane_pkg::SMODE_STATUS_WRITE_MASK[CVA6Cfg.XLEN-1:0];
1217       unreachable              mstatus_d = (mstatus_q & ~{{64-CVA6Cfg.XLEN{1'b0}}, mask}) | {{64-CVA6Cfg.XLEN{1'b0}}, (csr_wdata & mask)};
1218                                // hardwire to zero if floating point extension is not present
1219       unreachable              if (!CVA6Cfg.FpPresent) begin
1220       unreachable                mstatus_d.fs = riscv::Off;
1221                                end
                   ==>  MISSING_ELSE
1222                                // hardwire to zero if vector extension is not present
1223       unreachable              if (!CVA6Cfg.RVV) begin
1224       unreachable                mstatus_d.vs = riscv::Off;
1225                                end
                   ==>  MISSING_ELSE
1226                                // If h-extension is not enabled, priv level HS is reserved
1227       unreachable              if (!CVA6Cfg.RVH) begin
1228       unreachable                if (mstatus_d.mpp == riscv::PRIV_LVL_HS) begin
1229       unreachable                  mstatus_d.mpp = mstatus_q.mpp;
1230                                  end
                   ==>  MISSING_ELSE
1231                                end
                   ==>  MISSING_ELSE
1232                                // this instruction has side-effects
1233       unreachable              flush_o = 1'b1;
1234                              end else begin
1235       1/1                      update_access_exception = 1'b1;
1236                              end
1237                            end
1238                            // even machine mode interrupts can be visible and set-able to supervisor
1239                            // if the corresponding bit in mideleg is set
1240                            riscv::CSR_SIE: begin
1241       1/1                    if (CVA6Cfg.RVS) begin
1242       unreachable              mask  = (CVA6Cfg.RVH) ? mideleg_q & ~HS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0] : mideleg_q;
1243                                // the mideleg makes sure only delegate-able register (and therefore also only implemented registers) are written
1244       unreachable              mie_d = (mie_q & ~mask) | (csr_wdata & mask);
1245                              end else begin
1246       1/1                      update_access_exception = 1'b1;
1247                              end
1248                            end
1249                    
1250                            riscv::CSR_SIP: begin
1251       1/1                    if (CVA6Cfg.RVS) begin
1252                                // only the supervisor software interrupt is write-able, iff delegated
1253       unreachable              mask  = CVA6Cfg.XLEN'(riscv::MIP_SSIP) & mideleg_q;
1254       unreachable              mip_d = (mip_q & ~mask) | (csr_wdata & mask);
1255                              end else begin
1256       1/1                      update_access_exception = 1'b1;
1257                              end
1258                            end
1259                    
1260                            riscv::CSR_STVEC:
1261       1/1(1 unreachable)          if (CVA6Cfg.RVS) stvec_d = {csr_wdata[CVA6Cfg.XLEN-1:2], 1'b0, csr_wdata[0]};
1262       1/1                  else update_access_exception = 1'b1;
1263                            riscv::CSR_SCOUNTEREN:
1264       1/1(1 unreachable)          if (CVA6Cfg.RVS) scounteren_d = {{CVA6Cfg.XLEN - 32{1'b0}}, csr_wdata[31:0]};
1265       1/1                  else update_access_exception = 1'b1;
1266                            riscv::CSR_SSCRATCH:
1267       1/1(1 unreachable)          if (CVA6Cfg.RVS) sscratch_d = csr_wdata;
1268       1/1                  else update_access_exception = 1'b1;
1269                            riscv::CSR_SEPC:
1270       1/1(1 unreachable)          if (CVA6Cfg.RVS) sepc_d = {csr_wdata[CVA6Cfg.XLEN-1:1], 1'b0};
1271       1/1                  else update_access_exception = 1'b1;
1272                            riscv::CSR_SCAUSE:
1273       1/1(1 unreachable)          if (CVA6Cfg.RVS) scause_d = csr_wdata;
1274       1/1                  else update_access_exception = 1'b1;
1275                            riscv::CSR_STVAL:
1276       1/1(1 unreachable)          if (CVA6Cfg.RVS && CVA6Cfg.TvalEn) stval_d = csr_wdata;
1277       1/1                  else update_access_exception = 1'b1;
1278                            // supervisor address translation and protection
1279                            riscv::CSR_SATP: begin
1280       1/1                    if (CVA6Cfg.RVS) begin
1281                                // intercept SATP writes if in S-Mode and TVM is enabled
1282       unreachable              if (priv_lvl_o == riscv::PRIV_LVL_S && mstatus_q.tvm) update_access_exception = 1'b1;
1283                                else begin
1284       unreachable                satp = satp_t'(csr_wdata);
1285                                  // only make ASID_LEN - 1 bit stick, that way software can figure out how many ASID bits are supported
1286       unreachable                satp.asid = satp.asid & {{(CVA6Cfg.ASIDW - CVA6Cfg.ASID_WIDTH) {1'b0}}, {CVA6Cfg.ASID_WIDTH{1'b1}}};
1287                                  // only update if we actually support this mode
1288       unreachable                if (config_pkg::vm_mode_t'(satp.mode) == config_pkg::ModeOff ||
1289                                                    config_pkg::vm_mode_t'(satp.mode) == CVA6Cfg.MODE_SV)
1290       unreachable                  satp_d = satp;
                   ==>  MISSING_ELSE
1291                                end
1292                                // changing the mode can have side-effects on address translation (e.g.: other instructions), re-fetch
1293                                // the next instruction by executing a flush
1294       unreachable              flush_o = 1'b1;
1295                              end else begin
1296       1/1                      update_access_exception = 1'b1;
1297                              end
1298                            end
1299                            riscv::CSR_SENVCFG:
1300       1/1(1 unreachable)          if (CVA6Cfg.RVU) fiom_d = csr_wdata[0];
1301       1/1                  else update_access_exception = 1'b1;
1302                            //hypervisor mode registers
1303                            riscv::CSR_HSTATUS: begin
1304       1/1                    if (CVA6Cfg.RVH) begin
1305       unreachable              mask = ariane_pkg::HSTATUS_WRITE_MASK[CVA6Cfg.XLEN-1:0];
1306       unreachable              hstatus_d = (hstatus_q & ~{{64-CVA6Cfg.XLEN{1'b0}}, mask}) | {{64-CVA6Cfg.XLEN{1'b0}}, (csr_wdata & mask)};
1307                                // this instruction has side-effects
1308       unreachable              flush_o = 1'b1;
1309                              end else begin
1310       1/1                      update_access_exception = 1'b1;
1311                              end
1312                            end
1313                            riscv::CSR_HEDELEG: begin
1314       1/1                    if (CVA6Cfg.RVH) begin
1315       unreachable              mask = (1 << riscv::INSTR_ADDR_MISALIGNED) |
1316                                   (1 << riscv::INSTR_ACCESS_FAULT) |
1317                                   (1 << riscv::ILLEGAL_INSTR) |
1318                                   (1 << riscv::BREAKPOINT) |
1319                                   (1 << riscv::LD_ADDR_MISALIGNED) |
1320                                   (1 << riscv::LD_ACCESS_FAULT) |
1321                                   (1 << riscv::ST_ADDR_MISALIGNED) |
1322                                   (1 << riscv::ST_ACCESS_FAULT) |
1323                                   (1 << riscv::ENV_CALL_UMODE) |
1324                                   (1 << riscv::INSTR_PAGE_FAULT) |
1325                                   (1 << riscv::LOAD_PAGE_FAULT) |
1326                                   (1 << riscv::STORE_PAGE_FAULT);
1327       unreachable              hedeleg_d = (hedeleg_q & ~mask) | (csr_wdata & mask);
1328                              end else begin
1329       1/1                      update_access_exception = 1'b1;
1330                              end
1331                            end
1332                            riscv::CSR_HIDELEG: begin
1333       1/1                    if (CVA6Cfg.RVH) begin
1334       unreachable              hideleg_d = (hideleg_q & ~VS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0]) | (csr_wdata & VS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0]);
1335                              end else begin
1336       1/1                      update_access_exception = 1'b1;
1337                              end
1338                            end
1339                            riscv::CSR_HIE: begin
1340       1/1                    if (CVA6Cfg.RVH) begin
1341       unreachable              mask  = HS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0];
1342       unreachable              mie_d = (mie_q & ~mask) | (csr_wdata & mask);
1343                              end else begin
1344       1/1                      update_access_exception = 1'b1;
1345                              end
1346                            end
1347                            riscv::CSR_HIP: begin
1348       1/1                    if (CVA6Cfg.RVH) begin
1349       unreachable              mask  = CVA6Cfg.XLEN'(riscv::MIP_VSSIP);
1350       unreachable              mip_d = (mip_q & ~mask) | (csr_wdata & mask);
1351                              end else begin
1352       1/1                      update_access_exception = 1'b1;
1353                              end
1354                            end
1355                            riscv::CSR_HVIP: begin
1356       1/1                    if (CVA6Cfg.RVH) begin
1357       unreachable              mask  = VS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0];
1358       unreachable              mip_d = (mip_q & ~mask) | (csr_wdata & mask);
1359                              end else begin
1360       1/1                      update_access_exception = 1'b1;
1361                              end
1362                            end
1363                            riscv::CSR_HCOUNTEREN: begin
1364       1/1                    if (CVA6Cfg.RVH) begin
1365       unreachable              hcounteren_d = {{CVA6Cfg.XLEN - 32{1'b0}}, csr_wdata[31:0]};
1366                              end else begin
1367       1/1                      update_access_exception = 1'b1;
1368                              end
1369                            end
1370                            riscv::CSR_HTVAL: begin
1371       1/1                    if (CVA6Cfg.RVH) begin
1372       unreachable              htval_d = csr_wdata;
1373                              end else begin
1374       1/1                      update_access_exception = 1'b1;
1375                              end
1376                            end
1377                            riscv::CSR_HTINST: begin
1378       1/1                    if (CVA6Cfg.RVH) begin
1379       unreachable              htinst_d = {{CVA6Cfg.XLEN - 32{1'b0}}, csr_wdata[31:0]};
1380                              end else begin
1381       1/1                      update_access_exception = 1'b1;
1382                              end
1383                            end
1384                            //TODO Hyp: implement hgeie write
1385                            riscv::CSR_HGEIE: begin
1386       1/1                    if (!CVA6Cfg.RVH) begin
1387       1/1                      update_access_exception = 1'b1;
1388                              end
                   ==>  MISSING_ELSE
1389                            end
1390                            riscv::CSR_HGATP: begin
1391       1/1                    if (CVA6Cfg.RVH) begin
1392                                // intercept HGATP writes if in HS-Mode and TVM is enabled
1393       unreachable              if (priv_lvl_o == riscv::PRIV_LVL_S && !v_q && mstatus_q.tvm)
1394       unreachable                update_access_exception = 1'b1;
1395                                else begin
1396       unreachable                hgatp = hgatp_t'(csr_wdata);
1397                                  //hardwire PPN[1:0] to zero
1398       unreachable                hgatp[1:0] = 2'b0;
1399                                  // only make VMID_LEN - 1 bit stick, that way software can figure out how many VMID bits are supported
1400       unreachable                hgatp.vmid = hgatp.vmid & {{(CVA6Cfg.VMIDW - CVA6Cfg.VMID_WIDTH) {1'b0}}, {CVA6Cfg.VMID_WIDTH{1'b1}}};
1401                                  // only update if we actually support this mode
1402       unreachable                if (config_pkg::vm_mode_t'(hgatp.mode) == config_pkg::ModeOff ||
1403                                                config_pkg::vm_mode_t'(hgatp.mode) == CVA6Cfg.MODE_SV)
1404       unreachable                  hgatp_d = hgatp;
                   ==>  MISSING_ELSE
1405                                end
1406                                // changing the mode can have side-effects on address translation (e.g.: other instructions), re-fetch
1407                                // the next instruction by executing a flush
1408       unreachable              flush_o = 1'b1;
1409                              end else begin
1410       1/1                      update_access_exception = 1'b1;
1411                              end
1412                            end
1413                            riscv::CSR_HENVCFG:
1414       1/1(1 unreachable)          if (CVA6Cfg.RVH) fiom_d = csr_wdata[0];
1415       1/1                  else update_access_exception = 1'b1;
1416                            riscv::CSR_MSTATUS: begin
1417       1/1                    mstatus_d    = {{64 - CVA6Cfg.XLEN{1'b0}}, csr_wdata};
1418       1/1                    mstatus_d.xs = riscv::Off;
1419       1/1                    if (!CVA6Cfg.FpPresent) begin
1420       1/1                      mstatus_d.fs = riscv::Off;
1421                              end
                   ==>  MISSING_ELSE
1422       1/1                    if (!CVA6Cfg.RVV) begin
1423       1/1                      mstatus_d.vs = riscv::Off;
1424                              end
                   ==>  MISSING_ELSE
1425       1/1                    if (!CVA6Cfg.RVS) begin
1426       1/1                      mstatus_d.sie  = riscv::Off;
1427       1/1                      mstatus_d.spie = riscv::Off;
1428       1/1                      mstatus_d.spp  = riscv::Off;
1429       1/1                      mstatus_d.sum  = riscv::Off;
1430       1/1                      mstatus_d.mxr  = riscv::Off;
1431       1/1                      mstatus_d.tvm  = riscv::Off;
1432       1/1                      mstatus_d.tsr  = riscv::Off;
1433                              end
                   ==>  MISSING_ELSE
1434       1/1                    if (!CVA6Cfg.RVU) begin
1435       1/1                      mstatus_d.tw   = riscv::Off;
1436       1/1                      mstatus_d.mprv = riscv::Off;
1437                              end
                   ==>  MISSING_ELSE
1438       1/1                    if ((!CVA6Cfg.RVH & mstatus_d.mpp == riscv::PRIV_LVL_HS) |
1439                                  (!CVA6Cfg.RVS & mstatus_d.mpp == riscv::PRIV_LVL_S) |
1440                                  (!CVA6Cfg.RVU & mstatus_d.mpp == riscv::PRIV_LVL_U)) begin
1441       1/1                      mstatus_d.mpp = mstatus_q.mpp;
1442                              end
                        MISSING_ELSE
1443       1/1                    mstatus_d.wpri3 = 9'b0;
1444       1/1                    mstatus_d.wpri1 = 1'b0;
1445       1/1                    mstatus_d.wpri2 = 1'b0;
1446       1/1                    mstatus_d.wpri0 = 1'b0;
1447       1/1                    mstatus_d.ube   = 1'b0;  // CVA6 is little-endian
1448                              // this register has side-effects on other registers, flush the pipeline
1449       1/1                    flush_o         = 1'b1;
1450                            end
1451       1/1(1 unreachable)          riscv::CSR_MSTATUSH: if (CVA6Cfg.XLEN != 32) update_access_exception = 1'b1;
                        MISSING_ELSE
1452                            // MISA is WARL (Write Any Value, Reads Legal Value)
1453       1/1                  riscv::CSR_MISA: ;
1454                            // machine exception delegation register
1455                            // 0 - 15 exceptions supported
1456                            riscv::CSR_MEDELEG: begin
1457       1/1                    if (CVA6Cfg.RVS) begin
1458       unreachable              mask = (1 << riscv::INSTR_ADDR_MISALIGNED) |
1459                                                 (1 << riscv::INSTR_ACCESS_FAULT) |
1460                                                 (1 << riscv::ILLEGAL_INSTR) |
1461                                                 (1 << riscv::BREAKPOINT) |
1462                                                 (1 << riscv::LD_ADDR_MISALIGNED) |
1463                                                 (1 << riscv::LD_ACCESS_FAULT) |
1464                                                 (1 << riscv::ST_ADDR_MISALIGNED) |
1465                                                 (1 << riscv::ST_ACCESS_FAULT) |
1466                                                 (1 << riscv::ENV_CALL_UMODE) |
1467                                                 ((CVA6Cfg.RVH ? 1 : 0) << riscv::ENV_CALL_VSMODE) |
1468                                                 (1 << riscv::INSTR_PAGE_FAULT) |
1469                                                 (1 << riscv::LOAD_PAGE_FAULT) |
1470                                                 (1 << riscv::STORE_PAGE_FAULT) |
1471                                                 ((CVA6Cfg.RVH ? 1 : 0)  << riscv::INSTR_GUEST_PAGE_FAULT) |
1472                                                 ((CVA6Cfg.RVH ? 1 : 0)  << riscv::LOAD_GUEST_PAGE_FAULT) |
1473                                                 ((CVA6Cfg.RVH ? 1 : 0)  << riscv::VIRTUAL_INSTRUCTION) |
1474                                                 ((CVA6Cfg.RVH ? 1 : 0)  << riscv::STORE_GUEST_PAGE_FAULT);
1475       unreachable              medeleg_d = (medeleg_q & ~mask) | (csr_wdata & mask);
1476                              end else begin
1477       1/1                      update_access_exception = 1'b1;
1478                              end
1479                            end
1480                            // machine interrupt delegation register
1481                            // we do not support user interrupt delegation
1482                            riscv::CSR_MIDELEG: begin
1483       1/1                    if (CVA6Cfg.RVS) begin
1484       unreachable              mask = CVA6Cfg.XLEN'(riscv::MIP_SSIP)
1485                                        | CVA6Cfg.XLEN'(riscv::MIP_STIP)
1486                                        | CVA6Cfg.XLEN'(riscv::MIP_SEIP);
1487       unreachable              if (CVA6Cfg.RVH) begin
1488       unreachable                mideleg_d = (mideleg_q & ~mask) | (csr_wdata & mask) | HS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0];
1489                                end else begin
1490       unreachable                mideleg_d = (mideleg_q & ~mask) | (csr_wdata & mask);
1491                                end
1492                              end else begin
1493       1/1                      update_access_exception = 1'b1;
1494                              end
1495                            end
1496                            // mask the register so that unsupported interrupts can never be set
1497                            riscv::CSR_MIE: begin
1498       1/1                    if (CVA6Cfg.RVH) begin
1499       unreachable              mask = HS_DELEG_INTERRUPTS[CVA6Cfg.XLEN-1:0]
1500                                        | CVA6Cfg.XLEN'(riscv::MIP_SSIP)
1501                                        | CVA6Cfg.XLEN'(riscv::MIP_STIP)
1502                                        | CVA6Cfg.XLEN'(riscv::MIP_SEIP)
1503                                        | CVA6Cfg.XLEN'(riscv::MIP_MSIP)
1504                                        | CVA6Cfg.XLEN'(riscv::MIP_MTIP)
1505                                        | CVA6Cfg.XLEN'(riscv::MIP_MEIP);
1506                              end else begin
1507       1/1                      if (CVA6Cfg.RVS) begin
1508       unreachable                mask = CVA6Cfg.XLEN'(riscv::MIP_SSIP)
1509                                          | CVA6Cfg.XLEN'(riscv::MIP_STIP)
1510                                          | CVA6Cfg.XLEN'(riscv::MIP_SEIP)
1511                                          | CVA6Cfg.XLEN'(riscv::MIP_MSIP)
1512                                          | CVA6Cfg.XLEN'(riscv::MIP_MTIP)
1513                                          | CVA6Cfg.XLEN'(riscv::MIP_MEIP);
1514                                end else begin
1515       1/1                        if (CVA6Cfg.SoftwareInterruptEn) begin
1516       unreachable                  mask = CVA6Cfg.XLEN'(riscv::MIP_MSIP)  // same shift as MSIE
1517                                    | CVA6Cfg.XLEN'(riscv::MIP_MTIP)  // same shift as MTIE
1518                                    | CVA6Cfg.XLEN'(riscv::MIP_MEIP);  // same shift as MEIE
1519                                  end else begin
1520       1/1                          mask = CVA6Cfg.XLEN'(riscv::MIP_MTIP)  // same shift as MTIE
1521                                    | CVA6Cfg.XLEN'(riscv::MIP_MEIP);  // same shift as MEIE
1522                                  end
1523                                end
1524                              end
1525       1/1                    mie_d = (mie_q & ~mask) | (csr_wdata & mask); // we only support supervisor and M-mode interrupts
1526                            end
1527                    
1528                            riscv::CSR_MTVEC: begin
1529       2/2                    if (!Vectored) mtvec_d = {csr_wdata[CVA6Cfg.XLEN-1:2], 1'b0, Vectored};
1530                              // we are in vector mode, this implementation requires the additional
1531                              // alignment constraint of 64 * 4 bytes
1532                              else
1533       unreachable              mtvec_d = {csr_wdata[CVA6Cfg.XLEN-1:8], 7'b0, Vectored};
1534                            end
1535                            riscv::CSR_MCOUNTEREN: begin
1536       1/1(1 unreachable)            if (CVA6Cfg.RVU) mcounteren_d = {{CVA6Cfg.XLEN - 32{1'b0}}, csr_wdata[31:0]};
1537       1/1                    else update_access_exception = 1'b1;
1538                            end
1539                    
1540       1/1                  riscv::CSR_MSCRATCH: mscratch_d = csr_wdata;
1541       1/1                  riscv::CSR_MEPC: mepc_d = {csr_wdata[CVA6Cfg.XLEN-1:1], 1'b0};
1542       1/1                  riscv::CSR_MCAUSE: mcause_d = csr_wdata;
1543                            riscv::CSR_MTVAL: begin
1544       1/1(1 unreachable)            if (CVA6Cfg.TvalEn) mtval_d = csr_wdata;
                        MISSING_ELSE
1545                            end
1546                            riscv::CSR_MTINST:
1547       1/1(1 unreachable)          if (CVA6Cfg.RVH) mtinst_d = {{CVA6Cfg.XLEN - 32{1'b0}}, csr_wdata[31:0]};
1548       1/1                  else update_access_exception = 1'b1;
1549                            riscv::CSR_MTVAL2:
1550       1/1(1 unreachable)          if (CVA6Cfg.RVH) mtval2_d = csr_wdata;
1551       1/1                  else update_access_exception = 1'b1;
1552                            riscv::CSR_MIP: begin
1553       1/1                    if (CVA6Cfg.RVH) begin
1554       unreachable              mask = CVA6Cfg.XLEN'(riscv::MIP_SSIP)
1555                                        | CVA6Cfg.XLEN'(riscv::MIP_STIP)
1556                                        | CVA6Cfg.XLEN'(riscv::MIP_SEIP)
1557                                        | CVA6Cfg.XLEN'(riscv::MIP_VSSIP);
1558       1/1                    end else if (CVA6Cfg.RVS) begin
1559       unreachable              mask = CVA6Cfg.XLEN'(riscv::MIP_SSIP)
1560                                        | CVA6Cfg.XLEN'(riscv::MIP_STIP)
1561                                        | CVA6Cfg.XLEN'(riscv::MIP_SEIP);
1562                              end else begin
1563       1/1                      mask = '0;
1564                              end
1565       1/1                    mip_d = (mip_q & ~mask) | (csr_wdata & mask);
1566                            end
1567       1/1(1 unreachable)          riscv::CSR_MENVCFG: if (CVA6Cfg.RVU) fiom_d = csr_wdata[0];
                        MISSING_ELSE
1568                            riscv::CSR_MENVCFGH: begin
1569       2/2                    if (!CVA6Cfg.RVU || CVA6Cfg.XLEN != 32) update_access_exception = 1'b1;
                   ==>  MISSING_ELSE
1570                            end
1571                            riscv::CSR_MCOUNTINHIBIT:
1572       1/1                  if (CVA6Cfg.PerfCounterEn)
1573       unreachable            mcountinhibit_d = {csr_wdata[MHPMCounterNum+2:2], 1'b0, csr_wdata[0]};
1574       1/1                  else mcountinhibit_d = '0;
1575                            // performance counters
1576       1/1                  riscv::CSR_MCYCLE: cycle_d[CVA6Cfg.XLEN-1:0] = csr_wdata;
1577                            riscv::CSR_MCYCLEH:
1578       2/2                  if (CVA6Cfg.XLEN == 32) cycle_d[63:32] = csr_wdata;
1579       unreachable          else update_access_exception = 1'b1;
1580       1/1                  riscv::CSR_MINSTRET: instret_d[CVA6Cfg.XLEN-1:0] = csr_wdata;
1581                            riscv::CSR_MINSTRETH:
1582       2/2                  if (CVA6Cfg.XLEN == 32) instret_d[63:32] = csr_wdata;
1583       unreachable          else update_access_exception = 1'b1;
1584                            //Event Selector
1585                            riscv::CSR_MHPM_EVENT_3,
1586                                    riscv::CSR_MHPM_EVENT_4,
1587                                    riscv::CSR_MHPM_EVENT_5,
1588                                    riscv::CSR_MHPM_EVENT_6,
1589                                    riscv::CSR_MHPM_EVENT_7,
1590                                    riscv::CSR_MHPM_EVENT_8,
1591                                    riscv::CSR_MHPM_EVENT_9,
1592                                    riscv::CSR_MHPM_EVENT_10,
1593                                    riscv::CSR_MHPM_EVENT_11,
1594                                    riscv::CSR_MHPM_EVENT_12,
1595                                    riscv::CSR_MHPM_EVENT_13,
1596                                    riscv::CSR_MHPM_EVENT_14,
1597                                    riscv::CSR_MHPM_EVENT_15,
1598                                    riscv::CSR_MHPM_EVENT_16,
1599                                    riscv::CSR_MHPM_EVENT_17,
1600                                    riscv::CSR_MHPM_EVENT_18,
1601                                    riscv::CSR_MHPM_EVENT_19,
1602                                    riscv::CSR_MHPM_EVENT_20,
1603                                    riscv::CSR_MHPM_EVENT_21,
1604                                    riscv::CSR_MHPM_EVENT_22,
1605                                    riscv::CSR_MHPM_EVENT_23,
1606                                    riscv::CSR_MHPM_EVENT_24,
1607                                    riscv::CSR_MHPM_EVENT_25,
1608                                    riscv::CSR_MHPM_EVENT_26,
1609                                    riscv::CSR_MHPM_EVENT_27,
1610                                    riscv::CSR_MHPM_EVENT_28,
1611                                    riscv::CSR_MHPM_EVENT_29,
1612                                    riscv::CSR_MHPM_EVENT_30,
1613                                    riscv::CSR_MHPM_EVENT_31 :     begin
1614       1/1                    perf_we_o   = 1'b1;
1615       1/1                    perf_data_o = csr_wdata;
1616                            end
1617                    
1618                            riscv::CSR_MHPM_COUNTER_3,
1619                                    riscv::CSR_MHPM_COUNTER_4,
1620                                    riscv::CSR_MHPM_COUNTER_5,
1621                                    riscv::CSR_MHPM_COUNTER_6,
1622                                    riscv::CSR_MHPM_COUNTER_7,
1623                                    riscv::CSR_MHPM_COUNTER_8,
1624                                    riscv::CSR_MHPM_COUNTER_9,
1625                                    riscv::CSR_MHPM_COUNTER_10,
1626                                    riscv::CSR_MHPM_COUNTER_11,
1627                                    riscv::CSR_MHPM_COUNTER_12,
1628                                    riscv::CSR_MHPM_COUNTER_13,
1629                                    riscv::CSR_MHPM_COUNTER_14,
1630                                    riscv::CSR_MHPM_COUNTER_15,
1631                                    riscv::CSR_MHPM_COUNTER_16,
1632                                    riscv::CSR_MHPM_COUNTER_17,
1633                                    riscv::CSR_MHPM_COUNTER_18,
1634                                    riscv::CSR_MHPM_COUNTER_19,
1635                                    riscv::CSR_MHPM_COUNTER_20,
1636                                    riscv::CSR_MHPM_COUNTER_21,
1637                                    riscv::CSR_MHPM_COUNTER_22,
1638                                    riscv::CSR_MHPM_COUNTER_23,
1639                                    riscv::CSR_MHPM_COUNTER_24,
1640                                    riscv::CSR_MHPM_COUNTER_25,
1641                                    riscv::CSR_MHPM_COUNTER_26,
1642                                    riscv::CSR_MHPM_COUNTER_27,
1643                                    riscv::CSR_MHPM_COUNTER_28,
1644                                    riscv::CSR_MHPM_COUNTER_29,
1645                                    riscv::CSR_MHPM_COUNTER_30,
1646                                    riscv::CSR_MHPM_COUNTER_31 :  begin
1647       1/1                    perf_we_o   = 1'b1;
1648       1/1                    perf_data_o = csr_wdata;
1649                            end
1650                    
1651                            riscv::CSR_MHPM_COUNTER_3H,
1652                                    riscv::CSR_MHPM_COUNTER_4H,
1653                                    riscv::CSR_MHPM_COUNTER_5H,
1654                                    riscv::CSR_MHPM_COUNTER_6H,
1655                                    riscv::CSR_MHPM_COUNTER_7H,
1656                                    riscv::CSR_MHPM_COUNTER_8H,
1657                                    riscv::CSR_MHPM_COUNTER_9H,
1658                                    riscv::CSR_MHPM_COUNTER_10H,
1659                                    riscv::CSR_MHPM_COUNTER_11H,
1660                                    riscv::CSR_MHPM_COUNTER_12H,
1661                                    riscv::CSR_MHPM_COUNTER_13H,
1662                                    riscv::CSR_MHPM_COUNTER_14H,
1663                                    riscv::CSR_MHPM_COUNTER_15H,
1664                                    riscv::CSR_MHPM_COUNTER_16H,
1665                                    riscv::CSR_MHPM_COUNTER_17H,
1666                                    riscv::CSR_MHPM_COUNTER_18H,
1667                                    riscv::CSR_MHPM_COUNTER_19H,
1668                                    riscv::CSR_MHPM_COUNTER_20H,
1669                                    riscv::CSR_MHPM_COUNTER_21H,
1670                                    riscv::CSR_MHPM_COUNTER_22H,
1671                                    riscv::CSR_MHPM_COUNTER_23H,
1672                                    riscv::CSR_MHPM_COUNTER_24H,
1673                                    riscv::CSR_MHPM_COUNTER_25H,
1674                                    riscv::CSR_MHPM_COUNTER_26H,
1675                                    riscv::CSR_MHPM_COUNTER_27H,
1676                                    riscv::CSR_MHPM_COUNTER_28H,
1677                                    riscv::CSR_MHPM_COUNTER_29H,
1678                                    riscv::CSR_MHPM_COUNTER_30H,
1679                                    riscv::CSR_MHPM_COUNTER_31H :  begin
1680       1/1                    perf_we_o = 1'b1;
1681       2/2                    if (CVA6Cfg.XLEN == 32) perf_data_o = csr_wdata;
1682       unreachable            else update_access_exception = 1'b1;
1683                            end
1684                    
1685       1/1                  riscv::CSR_DCACHE: dcache_d = {{CVA6Cfg.XLEN - 1{1'b0}}, csr_wdata[0]};  // enable bit
1686       1/1                  riscv::CSR_ICACHE: icache_d = {{CVA6Cfg.XLEN - 1{1'b0}}, csr_wdata[0]};  // enable bit
1687                            riscv::CSR_ACC_CONS: begin
1688       1/1                    if (CVA6Cfg.EnableAccelerator) begin
1689       unreachable              acc_cons_d = {{CVA6Cfg.XLEN - 1{1'b0}}, csr_wdata[0]};  // enable bit
1690                              end else begin
1691       1/1                      update_access_exception = 1'b1;
1692                              end
1693                            end
1694                            // PMP locked logic
1695                            // 1. refuse to update any locked entry
1696                            // 2. also refuse to update the entry below a locked TOR entry
1697                            // Note that writes to pmpcfg below a locked TOR entry are valid
1698                            riscv::CSR_PMPCFG0,
1699                                    riscv::CSR_PMPCFG1,
1700                                    riscv::CSR_PMPCFG2,
1701                                    riscv::CSR_PMPCFG3,
1702                                    riscv::CSR_PMPCFG4,
1703                                    riscv::CSR_PMPCFG5,
1704                                    riscv::CSR_PMPCFG6,
1705                                    riscv::CSR_PMPCFG7,
1706                                    riscv::CSR_PMPCFG8,
1707                                    riscv::CSR_PMPCFG9,
1708                                    riscv::CSR_PMPCFG10,
1709                                    riscv::CSR_PMPCFG11,
1710                                    riscv::CSR_PMPCFG12,
1711                                    riscv::CSR_PMPCFG13,
1712                                    riscv::CSR_PMPCFG14,
1713                                    riscv::CSR_PMPCFG15: begin
1714                              // index is calculated using PMPCFG0 as the offset
1715       1/1                    automatic logic [11:0] index = csr_addr.address[11:0] - riscv::CSR_PMPCFG0;
1716                    
1717                              // if index is not even and XLEN==64, raise exception
1718       1/1(1 unreachable)            if (CVA6Cfg.XLEN == 64 && index[0] == 1'b1) update_access_exception = 1'b1;
1719                              else begin
1720       1/1                      for (int i = 0; i < CVA6Cfg.XLEN / 8; i++) begin
1721       2/2                        if (!pmpcfg_q[index*4+i].locked) pmpcfg_d[index*4+i] = csr_wdata[i*8+:8];
                   ==>  MISSING_ELSE
1722                                end
1723                              end
1724                            end
1725                            riscv::CSR_PMPADDR0,
1726                                    riscv::CSR_PMPADDR1,
1727                                    riscv::CSR_PMPADDR2,
1728                                    riscv::CSR_PMPADDR3,
1729                                    riscv::CSR_PMPADDR4,
1730                                    riscv::CSR_PMPADDR5,
1731                                    riscv::CSR_PMPADDR6,
1732                                    riscv::CSR_PMPADDR7,
1733                                    riscv::CSR_PMPADDR8,
1734                                    riscv::CSR_PMPADDR9,
1735                                    riscv::CSR_PMPADDR10,
1736                                    riscv::CSR_PMPADDR11,
1737                                    riscv::CSR_PMPADDR12,
1738                                    riscv::CSR_PMPADDR13,
1739                                    riscv::CSR_PMPADDR14,
1740                                    riscv::CSR_PMPADDR15,
1741                                    riscv::CSR_PMPADDR16,
1742                                    riscv::CSR_PMPADDR17,
1743                                    riscv::CSR_PMPADDR18,
1744                                    riscv::CSR_PMPADDR19,
1745                                    riscv::CSR_PMPADDR20,
1746                                    riscv::CSR_PMPADDR21,
1747                                    riscv::CSR_PMPADDR22,
1748                                    riscv::CSR_PMPADDR23,
1749                                    riscv::CSR_PMPADDR24,
1750                                    riscv::CSR_PMPADDR25,
1751                                    riscv::CSR_PMPADDR26,
1752                                    riscv::CSR_PMPADDR27,
1753                                    riscv::CSR_PMPADDR28,
1754                                    riscv::CSR_PMPADDR29,
1755                                    riscv::CSR_PMPADDR30,
1756                                    riscv::CSR_PMPADDR31,
1757                                    riscv::CSR_PMPADDR32,
1758                                    riscv::CSR_PMPADDR33,
1759                                    riscv::CSR_PMPADDR34,
1760                                    riscv::CSR_PMPADDR35,
1761                                    riscv::CSR_PMPADDR36,
1762                                    riscv::CSR_PMPADDR37,
1763                                    riscv::CSR_PMPADDR38,
1764                                    riscv::CSR_PMPADDR39,
1765                                    riscv::CSR_PMPADDR40,
1766                                    riscv::CSR_PMPADDR41,
1767                                    riscv::CSR_PMPADDR42,
1768                                    riscv::CSR_PMPADDR43,
1769                                    riscv::CSR_PMPADDR44,
1770                                    riscv::CSR_PMPADDR45,
1771                                    riscv::CSR_PMPADDR46,
1772                                    riscv::CSR_PMPADDR47,
1773                                    riscv::CSR_PMPADDR48,
1774                                    riscv::CSR_PMPADDR49,
1775                                    riscv::CSR_PMPADDR50,
1776                                    riscv::CSR_PMPADDR51,
1777                                    riscv::CSR_PMPADDR52,
1778                                    riscv::CSR_PMPADDR53,
1779                                    riscv::CSR_PMPADDR54,
1780                                    riscv::CSR_PMPADDR55,
1781                                    riscv::CSR_PMPADDR56,
1782                                    riscv::CSR_PMPADDR57,
1783                                    riscv::CSR_PMPADDR58,
1784                                    riscv::CSR_PMPADDR59,
1785                                    riscv::CSR_PMPADDR60,
1786                                    riscv::CSR_PMPADDR61,
1787                                    riscv::CSR_PMPADDR62,
1788                                    riscv::CSR_PMPADDR63: begin
1789                              // index is calculated using PMPADDR0 as the offset
1790       1/1                    automatic logic [11:0] index = csr_addr.address[11:0] - riscv::CSR_PMPADDR0;
1791                              // check if the entry or the entry above is locked
1792       1/1                    if (CVA6Cfg.NrPMPEntries == 0 || (!pmpcfg_q[index].locked && !(pmpcfg_q[index+1].locked && pmpcfg_q[index+1].addr_mode == riscv::TOR))) begin
1793       1/1                      pmpaddr_d[index] = csr_wdata[CVA6Cfg.PLEN-3:0];
1794                              end
                   ==>  MISSING_ELSE
1795                            end
1796       1/1                  default: update_access_exception = 1'b1;
1797                          endcase
1798                        end
                        MISSING_ELSE
1799       1/1              if (CVA6Cfg.IS_XLEN64) begin
1800       unreachable        mstatus_d.sxl = riscv::XLEN_64;
1801       unreachable        mstatus_d.uxl = riscv::XLEN_64;
1802                        end
                        MISSING_ELSE
1803       1/1              if (!CVA6Cfg.RVU) begin
1804       1/1                mstatus_d.mpp = riscv::PRIV_LVL_M;
1805                        end
                   ==>  MISSING_ELSE
1806                    
1807       1/1              if (CVA6Cfg.RVH) begin
1808       unreachable        hstatus_d.vsxl = riscv::XLEN_64;
1809       unreachable        vsstatus_d.uxl = riscv::XLEN_64;
1810                        end
                        MISSING_ELSE
1811                        // mark the floating point extension register as dirty
1812       1/1              if (CVA6Cfg.FpPresent && (dirty_fp_state_csr || dirty_fp_state_i)) begin
1813       unreachable        mstatus_d.fs = riscv::Dirty;
1814       unreachable        if (CVA6Cfg.RVH) begin
1815       unreachable          vsstatus_d.fs = v_q & riscv::Dirty;
1816                          end
                   ==>  MISSING_ELSE
1817                        end
                        MISSING_ELSE
1818                        // mark the vector extension register as dirty
1819       1/1              if (CVA6Cfg.RVV && dirty_v_state_i) begin
1820       unreachable        mstatus_d.vs = riscv::Dirty;
1821                        end
                        MISSING_ELSE
1822                        // hardwired extension registers
1823       1/1              if (CVA6Cfg.RVS || CVA6Cfg.RVF) begin
1824       unreachable        mstatus_d.sd = (mstatus_q.xs == riscv::Dirty) | (mstatus_q.fs == riscv::Dirty);
1825                        end else begin
1826       1/1                mstatus_d.sd = riscv::Off;
1827                        end
1828       1/1              if (CVA6Cfg.RVH) begin
1829       unreachable        vsstatus_d.sd = (vsstatus_q.xs == riscv::Dirty) | (vsstatus_q.fs == riscv::Dirty);
1830                        end
                        MISSING_ELSE
1831                    
1832                        // reserve PMPCFG bits 5 and 6 (hardwire to 0)
1833       1/1              if (CVA6Cfg.NrPMPEntries != 0)
1834       unreachable        for (int i = 0; i < CVA6Cfg.NrPMPEntries; i++) pmpcfg_d[i].reserved = 2'b0;
1835                    
1836                        // write the floating point status register
1837                        if (CVA6Cfg.FpPresent && csr_write_fflags_i) begin
                        MISSING_ELSE
1837       1/1              if (CVA6Cfg.FpPresent && csr_write_fflags_i) begin
1838       unreachable        fcsr_d.fflags = csr_wdata_i[4:0] | fcsr_q.fflags;
1839                        end
                        MISSING_ELSE
1840                    
1841                        // ----------------------------
1842                        // Accelerator FP imprecise exceptions
1843                        // ----------------------------
1844                    
1845                        // Update fflags as soon as a FP exception occurs in the accelerator
1846                        // The exception is imprecise, and the fcsr.fflags update always happens immediately
1847       1/1              if (CVA6Cfg.EnableAccelerator) begin
1848       unreachable        fcsr_d.fflags |= acc_fflags_ex_valid_i ? acc_fflags_ex_i : 5'b0;
1849                        end
                        MISSING_ELSE
1850                    
1851                        // ---------------------
1852                        // External Interrupts
1853                        // ---------------------
1854                        // Machine Mode External Interrupt Pending
1855       1/1              mip_d[riscv::IRQ_M_EXT] = irq_i[0];
1856                        // Machine software interrupt
1857       1/1              mip_d[riscv::IRQ_M_SOFT] = CVA6Cfg.SoftwareInterruptEn && ipi_i;
1858                        // Timer interrupt pending, coming from platform timer
1859       1/1              mip_d[riscv::IRQ_M_TIMER] = time_irq_i;
1860                    
1861                        // -----------------------
1862                        // Manage Exception Stack
1863                        // -----------------------
1864                        // update exception CSRs
1865                        // we got an exception update cause, pc and stval register
1866       1/1              trap_to_priv_lvl = riscv::PRIV_LVL_M;
1867       1/1              trap_to_v = 1'b0;
1868                        // Exception is taken and we are not in debug mode
1869                        // exceptions in debug mode don't update any fields
1870       1/1              if (!debug_mode && ex_cause_is_not_debug_request && ex_i.valid) begin
1871                          // do not flush, flush is reserved for CSR writes with side effects
1872       1/1                flush_o = 1'b0;
1873                          // figure out where to trap to
1874                          // a m-mode trap might be delegated if we are taking it in S mode
1875                          // first figure out if this was an exception or an interrupt e.g.: look at bit (XLEN-1)
1876                          // the cause register can only be $clog2(CVA6Cfg.XLEN) bits long (as we only support XLEN exceptions)
1877       1/1                if (CVA6Cfg.RVS) begin
1878       unreachable          if ((ex_i.cause[CVA6Cfg.XLEN-1] && mideleg_q[ex_i.cause[$clog2(
1879                                    CVA6Cfg.XLEN
1880                                )-1:0]]) || (~ex_i.cause[CVA6Cfg.XLEN-1] && medeleg_q[ex_i.cause[$clog2(
1881                                    CVA6Cfg.XLEN
1882                                )-1:0]])) begin
1883                              // traps never transition from a more-privileged mode to a less privileged mode
1884                              // so if we are already in M mode, stay there
1885       unreachable            trap_to_priv_lvl = (priv_lvl_o == riscv::PRIV_LVL_M) ? riscv::PRIV_LVL_M : riscv::PRIV_LVL_S;
1886       unreachable            if (CVA6Cfg.RVH) begin
1887       unreachable              if ((ex_i.cause[CVA6Cfg.XLEN-1] && hideleg_q[ex_i.cause[$clog2(
1888                                        CVA6Cfg.XLEN
1889                                    )-1:0]]) || (~ex_i.cause[CVA6Cfg.XLEN-1] && hedeleg_q[ex_i.cause[$clog2(
1890                                        CVA6Cfg.XLEN
1891                                    )-1:0]])) begin
1892                                  // trap to VS only if it is  the currently active mode
1893       unreachable                trap_to_v = v_q;
1894                                end
                   ==>  MISSING_ELSE
1895                              end
                   ==>  MISSING_ELSE
1896                            end
                   ==>  MISSING_ELSE
1897                          end
                        MISSING_ELSE
1898                    
1899                          // trap to supervisor mode
1900       1/1                if (CVA6Cfg.RVS && trap_to_priv_lvl == riscv::PRIV_LVL_S) begin
1901       unreachable          if (CVA6Cfg.RVH && trap_to_v) begin
1902                              // update sstatus
1903       unreachable            vsstatus_d.sie = 1'b0;
1904       unreachable            vsstatus_d.spie = (CVA6Cfg.RVH) ? vsstatus_q.sie : '0;
1905                              // this can either be user or supervisor mode
1906       unreachable            vsstatus_d.spp = priv_lvl_q[0];
1907                              // set cause
1908       unreachable            vscause_d = ex_i.cause[CVA6Cfg.XLEN-1] ? {ex_i.cause[CVA6Cfg.XLEN-1:2], 2'b01} : ex_i.cause;
1909                              // set epc
1910       unreachable            vsepc_d = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{pc_i[CVA6Cfg.VLEN-1]}}, pc_i};
1911                              // set vstval
1912       unreachable            vstval_d        = (ariane_pkg::ZERO_TVAL
1913                                                 && (ex_i.cause inside {
1914                                                 riscv::ILLEGAL_INSTR,
1915                                                 riscv::BREAKPOINT,
1916                                                 riscv::ENV_CALL_UMODE
1917                                                 } || ex_i.cause[CVA6Cfg.XLEN-1])) ? '0 : ex_i.tval;
1918                            end else begin
1919                              // update sstatus
1920       unreachable            mstatus_d.sie = 1'b0;
1921       unreachable            mstatus_d.spie = mstatus_q.sie;
1922                              // this can either be user or supervisor mode
1923       unreachable            mstatus_d.spp = priv_lvl_q[0];
1924                              // set cause
1925       unreachable            scause_d = ex_i.cause;
1926                              // set epc
1927       unreachable            sepc_d = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{pc_i[CVA6Cfg.VLEN-1]}}, pc_i};
1928                              // set mtval or stval
1929       unreachable            stval_d        = (ariane_pkg::ZERO_TVAL
1930                                                      && (ex_i.cause inside {
1931                                                        riscv::ILLEGAL_INSTR,
1932                                                        riscv::BREAKPOINT,
1933                                                        riscv::ENV_CALL_UMODE,
1934                                                        riscv::ENV_CALL_SMODE,
1935                                                        riscv::ENV_CALL_MMODE
1936                                                      } || ex_i.cause[CVA6Cfg.XLEN-1])) ? '0 : ex_i.tval;
1937       unreachable            if (CVA6Cfg.RVH) begin
1938       unreachable              htinst_d       = (ariane_pkg::ZERO_TVAL
1939                                                  && (ex_i.cause inside {
1940                                                    riscv::INSTR_ACCESS_FAULT,
1941                                                    riscv::ILLEGAL_INSTR,
1942                                                    riscv::BREAKPOINT,
1943                                                    riscv::ENV_CALL_UMODE,
1944                                                    riscv::ENV_CALL_SMODE,
1945                                                    riscv::ENV_CALL_MMODE,
1946                                                    riscv::INSTR_PAGE_FAULT,
1947                                                    riscv::INSTR_GUEST_PAGE_FAULT,
1948                                                    riscv::VIRTUAL_INSTRUCTION
1949                                                  } || ex_i.cause[CVA6Cfg.XLEN-1])) ? '0 : {{CVA6Cfg.XLEN - 32 {1'b0}}, ex_i.tinst};
1950       unreachable              hstatus_d.spvp = v_q ? priv_lvl_q[0] : hstatus_d.spvp;
1951       unreachable              htval_d = {{CVA6Cfg.XLEN - CVA6Cfg.GPLEN + 2{1'b0}}, ex_i.tval2[CVA6Cfg.GPLEN-1:2]};
1952       unreachable              hstatus_d.gva = ex_i.gva;
1953       unreachable              hstatus_d.spv = v_q;
1954                              end
                   ==>  MISSING_ELSE
1955                            end
1956                            // trap to machine mode
1957                          end else begin
1958                            // update mstatus
1959       1/1                  mstatus_d.mie = 1'b0;
1960       1/1                  mstatus_d.mpie = mstatus_q.mie;
1961                            // save the previous privilege mode
1962       1/1                  mstatus_d.mpp = priv_lvl_q;
1963       1/1                  mcause_d = ex_i.cause;
1964                            // set epc
1965       1/1                  mepc_d = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{pc_i[CVA6Cfg.VLEN-1]}}, pc_i};
1966                            // set mtval or stval
1967       1/1                  if (CVA6Cfg.TvalEn) begin
1968       unreachable            mtval_d        = (ariane_pkg::ZERO_TVAL
1969                                                        && (ex_i.cause inside {
1970                                                          riscv::ILLEGAL_INSTR,
1971                                                          riscv::BREAKPOINT,
1972                                                          riscv::ENV_CALL_UMODE,
1973                                                          riscv::ENV_CALL_SMODE,
1974                                                          riscv::ENV_CALL_MMODE
1975                                                        } || ex_i.cause[CVA6Cfg.GPLEN-1])) ? '0 : ex_i.tval;
1976                            end else begin
1977       1/1                    mtval_d = '0;
1978                            end
1979                    
1980       1/1                  if (CVA6Cfg.RVH) begin
1981                              // save previous virtualization mode
1982       unreachable            mstatus_d.mpv = v_q;
1983       unreachable            mtinst_d       = (ariane_pkg::ZERO_TVAL
1984                                                && (ex_i.cause inside {
1985                                                  riscv::INSTR_ADDR_MISALIGNED,
1986                                                  riscv::INSTR_ACCESS_FAULT,
1987                                                  riscv::ILLEGAL_INSTR,
1988                                                  riscv::BREAKPOINT,
1989                                                  riscv::ENV_CALL_UMODE,
1990                                                  riscv::ENV_CALL_SMODE,
1991                                                  riscv::ENV_CALL_MMODE,
1992                                                  riscv::INSTR_PAGE_FAULT,
1993                                                  riscv::INSTR_GUEST_PAGE_FAULT,
1994                                                  riscv::VIRTUAL_INSTRUCTION
1995                                                } || ex_i.cause[CVA6Cfg.XLEN-1])) ? '0 : {{CVA6Cfg.XLEN - 32 {1'b0}}, ex_i.tinst};
1996       unreachable            mtval2_d = {{CVA6Cfg.XLEN - CVA6Cfg.GPLEN + 2{1'b0}}, ex_i.tval2[CVA6Cfg.GPLEN-1:2]};
1997       unreachable            mstatus_d.gva = ex_i.gva;
1998                            end
                        MISSING_ELSE
1999                          end
2000                    
2001       1/1                priv_lvl_d = trap_to_priv_lvl;
2002       1/1                if (CVA6Cfg.RVH) begin
2003       unreachable          v_d = trap_to_v;
2004                          end
                        MISSING_ELSE
2005                        end
                        MISSING_ELSE
2006                    
2007                        // ------------------------------
2008                        // Debug
2009                        // ------------------------------
2010                        // Explains why Debug Mode was entered.
2011                        // When there are multiple reasons to enter Debug Mode in a single cycle, hardware should set cause to the cause with the highest priority.
2012                        // 1: An ebreak instruction was executed. (priority 3)
2013                        // 2: The Trigger Module caused a breakpoint exception. (priority 4)
2014                        // 3: The debugger requested entry to Debug Mode. (priority 2)
2015                        // 4: The hart single stepped because step was set. (priority 1)
2016                        // we are currently not in debug mode and could potentially enter
2017       1/1              if (CVA6Cfg.DebugEn) begin
2018       unreachable        if (!debug_mode) begin
2019       unreachable          dcsr_d.prv = priv_lvl_o;
2020                            // save virtualization mode bit
2021       unreachable          dcsr_d.v   = (!CVA6Cfg.RVH) ? 1'b0 : v_q;
2022                            // trigger module fired
2023                    
2024                            // caused by a breakpoint
2025       unreachable          if (ex_i.valid && ex_i.cause == riscv::BREAKPOINT) begin
2026       unreachable            dcsr_d.prv = priv_lvl_o;
2027                              // save virtualization mode bit
2028       unreachable            dcsr_d.v   = (!CVA6Cfg.RVH) ? 1'b0 : v_q;
2029                              // check that we actually want to enter debug depending on the privilege level we are currently in
2030       unreachable            unique case (priv_lvl_o)
2031                                riscv::PRIV_LVL_M: begin
2032       unreachable                debug_mode_d   = dcsr_q.ebreakm;
2033       unreachable                set_debug_pc_o = dcsr_q.ebreakm;
2034                                end
2035                                riscv::PRIV_LVL_S: begin
2036       unreachable                if (CVA6Cfg.RVS) begin
2037       unreachable                  debug_mode_d   = (CVA6Cfg.RVH && v_q) ? dcsr_q.ebreakvs : dcsr_q.ebreaks;
2038       unreachable                  set_debug_pc_o = (CVA6Cfg.RVH && v_q) ? dcsr_q.ebreakvs : dcsr_q.ebreaks;
2039                                  end
                   ==>  MISSING_ELSE
2040                                end
2041                                riscv::PRIV_LVL_U: begin
2042       unreachable                if (CVA6Cfg.RVU) begin
2043       unreachable                  debug_mode_d   = (CVA6Cfg.RVH && v_q) ? dcsr_q.ebreakvu : dcsr_q.ebreaku;
2044       unreachable                  set_debug_pc_o = (CVA6Cfg.RVH && v_q) ? dcsr_q.ebreakvu : dcsr_q.ebreaku;
2045                                  end
                   ==>  MISSING_ELSE
2046                                end
2047       unreachable              default: ;
2048                              endcase
2049                              // save PC of next this instruction e.g.: the next one to be executed
2050       unreachable            dpc_d = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{pc_i[CVA6Cfg.VLEN-1]}}, pc_i};
2051       unreachable            dcsr_d.cause = ariane_pkg::CauseBreakpoint;
2052                            end
                   ==>  MISSING_ELSE
2053                    
2054                            // we've got a debug request
2055       unreachable          if (ex_i.valid && ex_i.cause == riscv::DEBUG_REQUEST) begin
2056       unreachable            dcsr_d.prv = priv_lvl_o;
2057       unreachable            dcsr_d.v = (!CVA6Cfg.RVH) ? 1'b0 : v_q;
2058                              // save the PC
2059       unreachable            dpc_d = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{pc_i[CVA6Cfg.VLEN-1]}}, pc_i};
2060                              // enter debug mode
2061       unreachable            debug_mode_d = 1'b1;
2062                              // jump to the base address
2063       unreachable            set_debug_pc_o = 1'b1;
2064                              // save the cause as external debug request
2065       unreachable            dcsr_d.cause = ariane_pkg::CauseRequest;
2066                            end
                   ==>  MISSING_ELSE
2067                    
2068                            // single step enable and we just retired an instruction
2069       unreachable          if (dcsr_q.step && commit_ack_i[0]) begin
2070       unreachable            dcsr_d.prv = priv_lvl_o;
2071       unreachable            dcsr_d.v   = (!CVA6Cfg.RVH) ? 1'b0 : v_q;
2072                              // valid CTRL flow change
2073       unreachable            if (commit_instr_i.fu == CTRL_FLOW) begin
2074                                // we saved the correct target address during execute
2075       unreachable              dpc_d = {
2076                                  {CVA6Cfg.XLEN - CVA6Cfg.VLEN{commit_instr_i.bp.predict_address[CVA6Cfg.VLEN-1]}},
2077                                  commit_instr_i.bp.predict_address
2078                                };
2079                                // exception valid
2080       unreachable            end else if (ex_i.valid) begin
2081       unreachable              dpc_d = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, trap_vector_base_o};
2082                                // return from environment
2083       unreachable            end else if (eret_o) begin
2084       unreachable              dpc_d = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, epc_o};
2085                                // consecutive PC
2086                              end else begin
2087       unreachable              dpc_d = {
2088                                  {CVA6Cfg.XLEN - CVA6Cfg.VLEN{commit_instr_i.pc[CVA6Cfg.VLEN-1]}},
2089                                  commit_instr_i.pc + (commit_instr_i.is_compressed ? 'h2 : 'h4)
2090                                };
2091                              end
2092       unreachable            debug_mode_d   = 1'b1;
2093       unreachable            set_debug_pc_o = 1'b1;
2094       unreachable            dcsr_d.cause   = ariane_pkg::CauseSingleStep;
2095                            end
                   ==>  MISSING_ELSE
2096                          end
                   ==>  MISSING_ELSE
2097                          // go in halt-state again when we encounter an exception
2098       unreachable        if (debug_mode && ex_i.valid && ex_i.cause == riscv::BREAKPOINT) begin
2099       unreachable          set_debug_pc_o = 1'b1;
2100                          end
                   ==>  MISSING_ELSE
2101                        end
                        MISSING_ELSE
2102                    
2103                        // ------------------------------
2104                        // MPRV - Modify Privilege Level
2105                        // ------------------------------
2106                        // Set the address translation at which the load and stores should occur
2107                        // we can use the previous values since changing the address translation will always involve a pipeline flush
2108       1/1              if (CVA6Cfg.RVH) begin
2109       unreachable        if (mprv && (mstatus_q.mpv == 1'b0) && (config_pkg::vm_mode_t'(satp_q.mode) == CVA6Cfg.MODE_SV) && (mstatus_q.mpp != riscv::PRIV_LVL_M)) begin
2110       unreachable          en_ld_st_translation_d = 1'b1;
2111       unreachable        end else if (mprv && (mstatus_q.mpv == 1'b1)) begin
2112       unreachable          if (satp_mode_is_sv) begin
2113       unreachable            en_ld_st_translation_d = 1'b1;
2114                            end else begin
2115       unreachable            en_ld_st_translation_d = 1'b0;
2116                            end
2117                          end else begin  // otherwise we go with the regular settings
2118       unreachable          en_ld_st_translation_d = en_translation_o;
2119                          end
2120                    
2121       unreachable        if (mprv && (mstatus_q.mpv == 1'b1)) begin
2122       unreachable          if (config_pkg::vm_mode_t'(hgatp_q.mode) == CVA6Cfg.MODE_SV) begin
2123       unreachable            en_ld_st_g_translation_d = 1'b1;
2124                            end else begin
2125       unreachable            en_ld_st_g_translation_d = 1'b0;
2126                            end
2127                          end else begin
2128       unreachable          en_ld_st_g_translation_d = en_g_translation_o;
2129                          end
2130                    
2131       unreachable        if (csr_hs_ld_st_inst_i) ld_st_priv_lvl_o = riscv::priv_lvl_t'(hstatus_q.spvp);
2132       unreachable        else ld_st_priv_lvl_o = (mprv) ? mstatus_q.mpp : priv_lvl_o;
2133                    
2134       unreachable        ld_st_v_o = ((mprv ? mstatus_q.mpv : v_q) || (csr_hs_ld_st_inst_i));
2135                    
2136       unreachable        en_ld_st_translation_o = (en_ld_st_translation_q && !csr_hs_ld_st_inst_i) || (config_pkg::vm_mode_t'(vsatp_q.mode) == CVA6Cfg.MODE_SV && csr_hs_ld_st_inst_i);
2137                    
2138       unreachable        en_ld_st_g_translation_o = (en_ld_st_g_translation_q && !csr_hs_ld_st_inst_i) || (csr_hs_ld_st_inst_i && config_pkg::vm_mode_t'(hgatp_q.mode) == CVA6Cfg.MODE_SV && csr_hs_ld_st_inst_i);
2139                        end else begin
2140       1/1                if (CVA6Cfg.MmuPresent && mprv && satp_mode_is_sv && (mstatus_q.mpp != riscv::PRIV_LVL_M))
2141       unreachable          en_ld_st_translation_d = 1'b1;
2142                          else  // otherwise we go with the regular settings
2143       1/1                  en_ld_st_translation_d = en_translation_o;
2144                    
2145       1/1                if (CVA6Cfg.RVU) begin
2146       unreachable          ld_st_priv_lvl_o = (mprv) ? mstatus_q.mpp : priv_lvl_o;
2147                          end else begin
2148       1/1                  ld_st_priv_lvl_o = priv_lvl_o;
2149                          end
2150       1/1                en_ld_st_translation_o = en_ld_st_translation_q;
2151       1/1                ld_st_v_o = 1'b0;
2152       1/1                en_ld_st_g_translation_o = 1'b0;
2153                        end
2154                        // ------------------------------
2155                        // Return from Environment
2156                        // ------------------------------
2157                        // When executing an xRET instruction, supposing xPP holds the value y, xIE is set to xPIE; the privilege
2158                        // mode is changed to y; xPIE is set to 1; and xPP is set to U
2159       1/1              if (mret) begin
2160                          // return from exception, IF doesn't care from where we are returning
2161       1/1                eret_o        = 1'b1;
2162                          // return to the previous privilege level and restore all enable flags
2163                          // get the previous machine interrupt enable flag
2164       1/1                mstatus_d.mie = mstatus_q.mpie;
2165                          // restore the previous privilege level
2166       1/1                priv_lvl_d    = mstatus_q.mpp;
2167       1/1                mstatus_d.mpp = riscv::PRIV_LVL_M;
2168       1/1                if (CVA6Cfg.RVU) begin
2169                            // set mpp to user mode
2170       unreachable          mstatus_d.mpp = riscv::PRIV_LVL_U;
2171                          end
                        MISSING_ELSE
2172                          // set mpie to 1
2173       1/1                mstatus_d.mpie = 1'b1;
2174       1/1                if (CVA6Cfg.RVH) begin
2175                            // set virtualization mode
2176       unreachable          v_d           = mstatus_q.mpv;
2177                            //set mstatus mpv to false
2178       unreachable          mstatus_d.mpv = 1'b0;
2179       unreachable          if (mstatus_q.mpp != riscv::PRIV_LVL_M) mstatus_d.mprv = 1'b0;
                   ==>  MISSING_ELSE
2180                          end
                        MISSING_ELSE
2181                        end
                        MISSING_ELSE
2182                    
2183       1/1              if (CVA6Cfg.RVS && sret && virtualization_off) begin
2184                          // return from exception, IF doesn't care from where we are returning
2185       unreachable        eret_o         = 1'b1;
2186                          // return the previous supervisor interrupt enable flag
2187       unreachable        mstatus_d.sie  = mstatus_q.spie;
2188                          // restore the previous privilege level
2189       unreachable        priv_lvl_d     = riscv::priv_lvl_t'({1'b0, mstatus_q.spp});
2190                          // set spp to user mode
2191       unreachable        mstatus_d.spp  = 1'b0;
2192                          // set spie to 1
2193       unreachable        mstatus_d.spie = 1'b1;
2194       unreachable        if (CVA6Cfg.RVH) begin
2195                            // set virtualization mode
2196       unreachable          v_d            = hstatus_q.spv;
2197                            //set hstatus spv to false
2198       unreachable          hstatus_d.spv  = 1'b0;
2199       unreachable          mstatus_d.mprv = 1'b0;
2200                          end
                   ==>  MISSING_ELSE
2201                        end
                        MISSING_ELSE
2202                    
2203       1/1              if (CVA6Cfg.RVH) begin
2204       unreachable        if (sret && v_q) begin
2205                            // return from exception, IF doesn't care from where we are returning
2206       unreachable          eret_o          = 1'b1;
2207                            // return the previous supervisor interrupt enable flag
2208       unreachable          vsstatus_d.sie  = vsstatus_q.spie;
2209                            // restore the previous privilege level
2210       unreachable          priv_lvl_d      = riscv::priv_lvl_t'({1'b0, vsstatus_q.spp});
2211                            // set spp to user mode
2212       unreachable          vsstatus_d.spp  = 1'b0;
2213                            // set spie to 1
2214       unreachable          vsstatus_d.spie = 1'b1;
2215                          end
                   ==>  MISSING_ELSE
2216                        end
                        MISSING_ELSE
2217                    
2218                        // return from debug mode
2219       1/1              if (CVA6Cfg.DebugEn) begin
2220       unreachable        if (dret) begin
2221                            // return from exception, IF doesn't care from where we are returning
2222       unreachable          eret_o     = 1'b1;
2223                            // restore the previous privilege level
2224       unreachable          priv_lvl_d = riscv::priv_lvl_t'(dcsr_q.prv);
2225       unreachable          if (CVA6Cfg.RVH) begin
2226                              // restore the previous virtualization mode
2227       unreachable            v_d = dcsr_q.v;
2228                            end
                   ==>  MISSING_ELSE
2229                            // actually return from debug mode
2230       unreachable          debug_mode_d = 1'b0;
2231                          end
                   ==>  MISSING_ELSE
2232                        end
                        MISSING_ELSE
2233                      end
2234                    
2235                      // ---------------------------
2236                      // CSR OP Select Logic
2237                      // ---------------------------
2238                      always_comb begin : csr_op_logic
2239       1/1              csr_wdata = csr_wdata_i;
2240       1/1              csr_we    = 1'b1;
2241       1/1              csr_read  = 1'b1;
2242       1/1              mret      = 1'b0;
2243       1/1              sret      = 1'b0;
2244       1/1              dret      = 1'b0;
2245                    
2246       1/1              unique case (csr_op_i)
2247       1/1                CSR_WRITE: csr_wdata = csr_wdata_i;
2248       1/1                CSR_SET:   csr_wdata = csr_wdata_i | csr_rdata;
2249       1/1                CSR_CLEAR: csr_wdata = (~csr_wdata_i) & csr_rdata;
2250       1/1                CSR_READ:  csr_we = 1'b0;
2251                          MRET: begin
2252                            // the return should not have any write or read side-effects
2253       1/1                  csr_we   = 1'b0;
2254       1/1                  csr_read = 1'b0;
2255       1/1                  mret     = 1'b1;  // signal a return from machine mode
2256                          end
2257                          default: begin
2258       1/1                  if (CVA6Cfg.RVS && csr_op_i == SRET) begin
2259                              // the return should not have any write or read side-effects
2260       unreachable            csr_we   = 1'b0;
2261       unreachable            csr_read = 1'b0;
2262       unreachable            sret     = 1'b1;  // signal a return from supervisor mode
2263       1/1                  end else if (CVA6Cfg.DebugEn && csr_op_i == DRET) begin
2264                              // the return should not have any write or read side-effects
2265       unreachable            csr_we   = 1'b0;
2266       unreachable            csr_read = 1'b0;
2267       unreachable            dret     = 1'b1;  // signal a return from debug mode
2268                            end else begin
2269       1/1                    csr_we   = 1'b0;
2270       1/1                    csr_read = 1'b0;
2271                            end
2272                          end
2273                        endcase
2274                        // if we are violating our privilges do not update the architectural state
2275       1/1              if (privilege_violation) begin
2276       1/1                csr_we   = 1'b0;
2277       1/1                csr_read = 1'b0;
2278                        end
                        MISSING_ELSE
2279                      end
2280                    
2281                      assign irq_ctrl_o.mie = mie_q;
2282                      assign irq_ctrl_o.mip = mip_q;
2283                      if (CVA6Cfg.RVH) begin
2284                        assign irq_ctrl_o.sie = (v_q) ? vsstatus_q.sie : mstatus_q.sie;
2285                      end else begin
2286                        assign irq_ctrl_o.sie = mstatus_q.sie;
2287                      end
2288                      assign irq_ctrl_o.mideleg = (CVA6Cfg.RVS) ? mideleg_q : '0;
2289                      assign irq_ctrl_o.hideleg = (CVA6Cfg.RVH) ? hideleg_q : '0;
2290                    
2291                      // interrupts are enabled during single step or we are not stepping
2292                      // No need to check interrupts during single step if we don't support DEBUG mode
2293                      if (CVA6Cfg.DebugEn) begin
2294                        assign irq_ctrl_o.global_enable = ~(debug_mode) & (~dcsr_q.step | dcsr_q.stepie)
2295                                                          & ((mstatus_q.mie & (priv_lvl_o == riscv::PRIV_LVL_M | !CVA6Cfg.RVU))
2296                                                          | (CVA6Cfg.RVU & priv_lvl_o != riscv::PRIV_LVL_M));
2297                      end else begin
2298                        assign irq_ctrl_o.global_enable = (mstatus_q.mie & (priv_lvl_o == riscv::PRIV_LVL_M | !CVA6Cfg.RVU))
2299                                                          | (CVA6Cfg.RVU & priv_lvl_o != riscv::PRIV_LVL_M);
2300                      end
2301                    
2302                      always_comb begin : privilege_check
2303       1/1              if (CVA6Cfg.RVH) begin
2304                          automatic riscv::priv_lvl_t access_priv;
2305                          automatic riscv::priv_lvl_t curr_priv;
2306                          automatic logic [SELECT_COUNTER_WIDTH-1:0] sel_cnt_en;
2307                          // transforms S mode accesses into HS mode
2308       unreachable        access_priv = (priv_lvl_o == riscv::PRIV_LVL_S && !v_q) ? riscv::PRIV_LVL_HS : priv_lvl_o;
2309       unreachable        curr_priv = priv_lvl_o;
2310       unreachable        sel_cnt_en = {{SELECT_COUNTER_WIDTH - 5{1'b0}}, csr_addr_i[4:0]};
2311                          // -----------------
2312                          // Privilege Check
2313                          // -----------------
2314       unreachable        privilege_violation = 1'b0;
2315       unreachable        virtual_privilege_violation = 1'b0;
2316                          // if we are reading or writing, check for the correct privilege level this has
2317                          // precedence over interrupts
2318       unreachable        if (csr_op_i inside {CSR_WRITE, CSR_SET, CSR_CLEAR, CSR_READ}) begin
2319       unreachable          if (access_priv < csr_addr.csr_decode.priv_lvl) begin
2320       unreachable            if (v_q && csr_addr.csr_decode.priv_lvl <= riscv::PRIV_LVL_HS)
2321       unreachable              virtual_privilege_violation = 1'b1;
2322       unreachable            else privilege_violation = 1'b1;
2323                            end
                   ==>  MISSING_ELSE
2324                            // check access to debug mode only CSRs
2325       unreachable          if (!debug_mode && csr_addr_i[11:4] == 8'h7b) begin
2326       unreachable            privilege_violation = 1'b1;
2327                            end
                   ==>  MISSING_ELSE
2328                            // check counter-enabled counter CSR accesses
2329                            // counter address range is C00 to C1F
2330       unreachable          if (CVA6Cfg.RVZihpm) begin
2331       unreachable            if (csr_addr_i inside {[riscv::CSR_HPM_COUNTER_3 : riscv::CSR_HPM_COUNTER_31]} |
2332                                  csr_addr_i inside {[riscv::CSR_HPM_COUNTER_3H : riscv::CSR_HPM_COUNTER_31H]}) begin
2333       unreachable              if (curr_priv == riscv::PRIV_LVL_S && CVA6Cfg.RVS) begin
2334       unreachable                virtual_privilege_violation = v_q & mcounteren_q[sel_cnt_en] & ~hcounteren_q[sel_cnt_en];
2335       unreachable                privilege_violation = ~mcounteren_q[sel_cnt_en];
2336       unreachable              end else if (priv_lvl_o == riscv::PRIV_LVL_U && CVA6Cfg.RVU) begin
2337       unreachable                virtual_privilege_violation = v_q & mcounteren_q[sel_cnt_en] & ~hcounteren_q[sel_cnt_en];
2338       unreachable                if (v_q) begin
2339       unreachable                  privilege_violation = ~mcounteren_q[sel_cnt_en] & ~scounteren_q[sel_cnt_en] & hcounteren_q[sel_cnt_en];
2340                                  end else begin
2341       unreachable                  privilege_violation = ~mcounteren_q[sel_cnt_en] & ~scounteren_q[sel_cnt_en];
2342                                  end
2343       unreachable              end else if (priv_lvl_o == riscv::PRIV_LVL_M) begin
2344       unreachable                privilege_violation = 1'b0;
2345                                end
                   ==>  MISSING_ELSE
2346                              end
                   ==>  MISSING_ELSE
2347                            end
                   ==>  MISSING_ELSE
2348       unreachable          if (CVA6Cfg.RVZicntr) begin
2349       unreachable            if (csr_addr_i inside {[riscv::CSR_CYCLE : riscv::CSR_INSTRET]} |
2350                                  csr_addr_i inside {[riscv::CSR_CYCLEH : riscv::CSR_INSTRETH]}) begin
2351       unreachable              if (curr_priv == riscv::PRIV_LVL_S && CVA6Cfg.RVS) begin
2352       unreachable                virtual_privilege_violation = v_q & mcounteren_q[sel_cnt_en] & ~hcounteren_q[sel_cnt_en];
2353       unreachable                privilege_violation = ~mcounteren_q[sel_cnt_en];
2354       unreachable              end else if (priv_lvl_o == riscv::PRIV_LVL_U && CVA6Cfg.RVU) begin
2355       unreachable                virtual_privilege_violation = v_q & mcounteren_q[sel_cnt_en] & ~hcounteren_q[sel_cnt_en];
2356       unreachable                if (v_q) begin
2357       unreachable                  privilege_violation = ~mcounteren_q[sel_cnt_en] & ~scounteren_q[sel_cnt_en] & hcounteren_q[sel_cnt_en];
2358                                  end else begin
2359       unreachable                  privilege_violation = ~mcounteren_q[sel_cnt_en] & ~scounteren_q[sel_cnt_en];
2360                                  end
2361       unreachable              end else if (priv_lvl_o == riscv::PRIV_LVL_M) begin
2362       unreachable                privilege_violation = 1'b0;
2363                                end
                   ==>  MISSING_ELSE
2364                              end
                   ==>  MISSING_ELSE
2365                            end
                   ==>  MISSING_ELSE
2366                          end
                   ==>  MISSING_ELSE
2367                        end else begin
2368                          // -----------------
2369                          // Privilege Check
2370                          // -----------------
2371       1/1                privilege_violation = 1'b0;
2372                          // if we are reading or writing, check for the correct privilege level this has
2373                          // precedence over interrupts
2374       1/1                if (csr_op_i inside {CSR_WRITE, CSR_SET, CSR_CLEAR, CSR_READ}) begin
2375       1/1                  if (CVA6Cfg.RVU && (riscv::priv_lvl_t'(priv_lvl_o & csr_addr.csr_decode.priv_lvl) != csr_addr.csr_decode.priv_lvl)) begin
2376       unreachable            privilege_violation = 1'b1;
2377                            end
                        MISSING_ELSE
2378                            // check access to debug mode only CSRs
2379       1/1                  if (!debug_mode && csr_addr_i[11:4] == 8'h7b) begin
2380       1/1                    privilege_violation = 1'b1;
2381                            end
                        MISSING_ELSE
2382                            // check counter-enabled counter CSR accesses
2383                            // counter address range is C00 to C1F
2384       1/1                  if (CVA6Cfg.RVZihpm) begin
2385       unreachable            if (csr_addr_i inside {[riscv::CSR_HPM_COUNTER_3 : riscv::CSR_HPM_COUNTER_31]} |
2386                                  csr_addr_i inside {[riscv::CSR_HPM_COUNTER_3H : riscv::CSR_HPM_COUNTER_31H]}) begin
2387       unreachable              if (priv_lvl_o == riscv::PRIV_LVL_S && CVA6Cfg.RVS) begin
2388       unreachable                privilege_violation = ~mcounteren_q[csr_addr_i[4:0]];
2389       unreachable              end else if (priv_lvl_o == riscv::PRIV_LVL_U && CVA6Cfg.RVU) begin
2390       unreachable                privilege_violation = ~mcounteren_q[csr_addr_i[4:0]] | ~scounteren_q[csr_addr_i[4:0]];
2391       unreachable              end else if (priv_lvl_o == riscv::PRIV_LVL_M) begin
2392       unreachable                privilege_violation = 1'b0;
2393                                end
                   ==>  MISSING_ELSE
2394                              end
                   ==>  MISSING_ELSE
2395                            end
                        MISSING_ELSE
2396       1/1                  if (CVA6Cfg.RVZicntr) begin
2397       unreachable            if (csr_addr_i inside {[riscv::CSR_CYCLE : riscv::CSR_INSTRET]} |
2398                                  csr_addr_i inside {[riscv::CSR_CYCLEH : riscv::CSR_INSTRETH]}) begin
2399       unreachable              if (priv_lvl_o == riscv::PRIV_LVL_S && CVA6Cfg.RVS) begin
2400       unreachable                privilege_violation = ~mcounteren_q[csr_addr_i[4:0]];
2401       unreachable              end else if (priv_lvl_o == riscv::PRIV_LVL_U && CVA6Cfg.RVU) begin
2402       unreachable                privilege_violation = ~mcounteren_q[csr_addr_i[4:0]] | ~scounteren_q[csr_addr_i[4:0]];
2403       unreachable              end else if (priv_lvl_o == riscv::PRIV_LVL_M) begin
2404       unreachable                privilege_violation = 1'b0;
2405                                end
                   ==>  MISSING_ELSE
2406                              end
                   ==>  MISSING_ELSE
2407                            end
                        MISSING_ELSE
2408                          end
                        MISSING_ELSE
2409                        end
2410                      end
2411                      // ----------------------
2412                      // CSR Exception Control
2413                      // ----------------------
2414                      always_comb begin : exception_ctrl
2415       1/1              csr_exception_o = {
2416                          {CVA6Cfg.XLEN{1'b0}}, {CVA6Cfg.XLEN{1'b0}}, {CVA6Cfg.GPLEN{1'b0}}, {32{1'b0}}, 1'b0, 1'b0
2417                        };
2418                        // ----------------------------------
2419                        // Illegal Access (decode exception)
2420                        // ----------------------------------
2421                        // we got an exception in one of the processes above
2422                        // throw an illegal instruction exception
2423       1/1              if (update_access_exception || read_access_exception) begin
2424       1/1                csr_exception_o.cause = riscv::ILLEGAL_INSTR;
2425                          // we don't set the tval field as this will be set by the commit stage
2426                          // this spares the extra wiring from commit to CSR and back to commit
2427       1/1                csr_exception_o.valid = 1'b1;
2428                        end
                        MISSING_ELSE
2429                    
2430       1/1              if (privilege_violation) begin
2431       1/1                csr_exception_o.cause = riscv::ILLEGAL_INSTR;
2432       1/1                csr_exception_o.valid = 1'b1;
2433                        end
                        MISSING_ELSE
2434                    
2435       1/1              if (CVA6Cfg.RVH) begin
2436       unreachable        if (virtual_update_access_exception || virtual_read_access_exception || virtual_privilege_violation) begin
2437       unreachable        csr_exception_o.cause = riscv::VIRTUAL_INSTRUCTION;
2438       unreachable        csr_exception_o.valid = 1'b1;
2439                          end
                   ==>  MISSING_ELSE
2440                        end
                        MISSING_ELSE
2441                      end
2442                    
2443                      // -------------------
2444                      // Wait for Interrupt
2445                      // -------------------
2446                      always_comb begin : wfi_ctrl
2447                        // wait for interrupt register
2448       1/1              wfi_d = wfi_q;
2449                        // if there is any (enabled) interrupt pending un-stall the core
2450                        // also un-stall if we want to enter debug mode
2451       1/1              if (|(mip_q & mie_q) || (CVA6Cfg.DebugEn && debug_req_i) || irq_i[1]) begin
2452       1/1                wfi_d = 1'b0;
2453                          // or alternatively if there is no exception pending and we are not in debug mode wait here
2454                          // for the interrupt
2455       1/1              end else if (!debug_mode && csr_op_i == WFI && !ex_i.valid) begin
2456       1/1                wfi_d = 1'b1;
2457                        end
                        MISSING_ELSE
2458                      end
2459                    
2460                      // output assignments dependent on privilege mode
2461                      always_comb begin : priv_output
2462       1/1              trap_vector_base_o = {mtvec_q[CVA6Cfg.VLEN-1:2], 2'b0};
2463                        // output user mode stvec
2464       1/1              if (CVA6Cfg.RVS) begin
2465       unreachable        if (trap_to_priv_lvl == riscv::PRIV_LVL_S) begin
2466       unreachable          trap_vector_base_o = (CVA6Cfg.RVH && trap_to_v) ? {vstvec_q[CVA6Cfg.VLEN-1:2], 2'b0} : {stvec_q[CVA6Cfg.VLEN-1:2], 2'b0};
2467                          end
                   ==>  MISSING_ELSE
2468                        end
                        MISSING_ELSE
2469                    
2470                        // if we are in debug mode jump to a specific address
2471       1/1              if (debug_mode) begin
2472       unreachable        trap_vector_base_o = CVA6Cfg.DmBaseAddress[CVA6Cfg.VLEN-1:0] + CVA6Cfg.ExceptionAddress[CVA6Cfg.VLEN-1:0];
2473                        end
                        MISSING_ELSE
2474                    
2475                        // check if we are in vectored mode, if yes then do BASE + 4 * cause we
2476                        // are imposing an additional alignment-constraint of 64 * 4 bytes since
2477                        // we want to spare the costly addition. Furthermore check to which
2478                        // privilege level we are jumping and whether the vectored mode is
2479                        // activated for _that_ privilege level.
2480       1/1              if (ex_i.cause[CVA6Cfg.XLEN-1]) begin
2481       1/1                if (((CVA6Cfg.RVS || CVA6Cfg.RVU) && trap_to_priv_lvl == riscv::PRIV_LVL_M && (!CVA6Cfg.DirectVecOnly && mtvec_q[0])) || (!CVA6Cfg.RVS && !CVA6Cfg.RVU && (!CVA6Cfg.DirectVecOnly && mtvec_q[0]))) begin
2482       unreachable          trap_vector_base_o[7:2] = ex_i.cause[5:0];
2483                          end
                        MISSING_ELSE
2484       1/1                if (CVA6Cfg.RVS) begin
2485       unreachable          if (trap_to_priv_lvl == riscv::PRIV_LVL_S && !trap_to_v && stvec_q[0]) begin
2486       unreachable            trap_vector_base_o[7:2] = ex_i.cause[5:0];
2487                            end
                   ==>  MISSING_ELSE
2488                          end
                        MISSING_ELSE
2489       1/1                if (CVA6Cfg.RVH) begin
2490       unreachable          if (trap_to_priv_lvl == riscv::PRIV_LVL_S && trap_to_v && vstvec_q[0]) begin
2491       unreachable            trap_vector_base_o[7:2] = {ex_i.cause[5:2], 2'b01};
2492                            end
                   ==>  MISSING_ELSE
2493                          end
                        MISSING_ELSE
2494                        end
                        MISSING_ELSE
2495                    
2496       1/1              epc_o = mepc_q[CVA6Cfg.VLEN-1:0];
2497                        // we are returning from supervisor or virtual supervisor mode, so take the sepc register
2498       1/1              if (CVA6Cfg.RVS) begin
2499       unreachable        if (sret) begin
2500       unreachable          epc_o = (CVA6Cfg.RVH && v_q) ? vsepc_q[CVA6Cfg.VLEN-1:0] : sepc_q[CVA6Cfg.VLEN-1:0];
2501                          end
                   ==>  MISSING_ELSE
2502                        end
                        MISSING_ELSE
2503                        // we are returning from debug mode, to take the dpc register
2504       1/1              if (CVA6Cfg.DebugEn) begin
2505       unreachable        if (dret) begin
2506       unreachable          epc_o = dpc_q[CVA6Cfg.VLEN-1:0];
2507                          end
                   ==>  MISSING_ELSE
2508                        end
                        MISSING_ELSE
2509                      end
2510                    
2511                      // -------------------
2512                      // Output Assignments
2513                      // -------------------
2514                      always_comb begin
2515                        // When the SEIP bit is read with a CSRRW, CSRRS, or CSRRC instruction, the value
2516                        // returned in the rd destination register contains the logical-OR of the software-writable
2517                        // bit and the interrupt signal from the interrupt controller.
2518       1/1              csr_rdata_o = csr_rdata;
2519                    
2520       1/1              unique case (conv_csr_addr.address)
2521                          riscv::CSR_MIP:
2522       1/1                csr_rdata_o = csr_rdata | ({{CVA6Cfg.XLEN - 1{1'b0}}, CVA6Cfg.RVS && irq_i[1]} << riscv::IRQ_S_EXT);
2523                          // in supervisor mode we also need to check whether we delegated this bit
2524                          riscv::CSR_SIP: begin
2525       1/1                  if (CVA6Cfg.RVS) begin
2526       unreachable            csr_rdata_o = csr_rdata
2527                                                  | ({{CVA6Cfg.XLEN-1{1'b0}}, (irq_i[1] & mideleg_q[riscv::IRQ_S_EXT])} << riscv::IRQ_S_EXT);
2528                            end
                        MISSING_ELSE
2529                          end
2530       1/1                default: ;
2531                        endcase
2532                      end
2533                    
2534                      // in debug mode we execute with privilege level M
2535                      assign priv_lvl_o = debug_mode ? riscv::PRIV_LVL_M : priv_lvl_q;
2536                      assign v_o = CVA6Cfg.RVH ? v_q : 1'b0;
2537                      assign virtualization_off = CVA6Cfg.RVH ? !v_q : 1'b0;
2538                      // FPU outputs
2539                      assign fflags_o = fcsr_q.fflags;
2540                      assign frm_o = fcsr_q.frm;
2541                      assign fprec_o = fcsr_q.fprec;
2542                      //JVT outputs
2543                      if (CVA6Cfg.RVZCMT) begin
2544                        assign jvt_o.base = jvt_q.base;
2545                        assign jvt_o.mode = jvt_q.mode;
2546                      end else begin
2547                        assign jvt_o.base = '0;
2548                        assign jvt_o.mode = '0;
2549                      end
2550                      // MMU outputs
2551                      assign satp_ppn_o  = CVA6Cfg.RVS ? satp_q.ppn : '0;
2552                      assign vsatp_ppn_o = CVA6Cfg.RVH ? vsatp_q.ppn : '0;
2553                      assign hgatp_ppn_o = CVA6Cfg.RVH ? hgatp_q.ppn : '0;
2554                      if (CVA6Cfg.RVS) begin
2555                        assign asid_o = satp_q.asid[CVA6Cfg.ASID_WIDTH-1:0];
2556                      end else begin
2557                        assign asid_o = '0;
2558                      end
2559                      assign vs_asid_o = CVA6Cfg.RVH ? vsatp_q.asid[CVA6Cfg.ASID_WIDTH-1:0] : '0;
2560                      assign vmid_o = CVA6Cfg.RVH ? hgatp_q.vmid[CVA6Cfg.VMID_WIDTH-1:0] : '0;
2561                      assign sum_o = mstatus_q.sum;
2562                      assign vs_sum_o = CVA6Cfg.RVH ? vsstatus_q.sum : '0;
2563                      assign hu_o = CVA6Cfg.RVH ? hstatus_q.hu : '0;
2564                      // we support bare memory addressing and SV39
2565                      if (CVA6Cfg.RVH) begin
2566                        assign en_translation_o = (((config_pkg::vm_mode_t'(satp_q.mode) == CVA6Cfg.MODE_SV && !v_q) || (config_pkg::vm_mode_t'(vsatp_q.mode) == CVA6Cfg.MODE_SV && v_q)) &&
2567                                                   priv_lvl_o != riscv::PRIV_LVL_M)
2568                                                  ? 1'b1
2569                                                  : 1'b0;
2570                        assign en_g_translation_o = (config_pkg::vm_mode_t'(hgatp_q.mode) == CVA6Cfg.MODE_SV &&
2571                                                   priv_lvl_o != riscv::PRIV_LVL_M && v_q)
2572                                                  ? 1'b1
2573                                                  : 1'b0;
2574                      end else if (CVA6Cfg.RVU) begin
2575                        assign en_translation_o   = (satp_mode_is_sv && priv_lvl_o != riscv::PRIV_LVL_M) ? 1'b1 : 1'b0;
2576                        assign en_g_translation_o = 1'b0;
2577                      end else begin
2578                        assign en_translation_o   = 1'b0;
2579                        assign en_g_translation_o = 1'b0;
2580                      end
2581                      assign mxr_o  = mstatus_q.mxr;
2582                      assign vmxr_o = CVA6Cfg.RVH ? vsstatus_q.mxr : '0;
2583                      if (CVA6Cfg.RVH) begin
2584                        assign tvm_o = (v_q) ? hstatus_q.vtvm : mstatus_q.tvm;
2585                      end else begin
2586                        assign tvm_o = mstatus_q.tvm;
2587                      end
2588                      assign tw_o  = mstatus_q.tw;
2589                      assign vtw_o = CVA6Cfg.RVH ? hstatus_q.vtw : '0;
2590                      if (CVA6Cfg.RVH) begin
2591                        assign tsr_o = (v_q) ? hstatus_q.vtsr : mstatus_q.tsr;
2592                      end else begin
2593                        assign tsr_o = mstatus_q.tsr;
2594                      end
2595                      assign halt_csr_o = wfi_q;
2596                    `ifdef PITON_ARIANE
2597                      assign icache_en_o = icache_q[0];
2598                    `else
2599                      assign icache_en_o = icache_q[0] & ~debug_mode;
2600                    `endif
2601                      assign dcache_en_o = dcache_q[0];
2602                      assign acc_cons_en_o = CVA6Cfg.EnableAccelerator ? acc_cons_q[0] : 1'b0;
2603                    
2604                      // determine if mprv needs to be considered if in debug mode
2605                      if (CVA6Cfg.DebugEn) begin
2606                        assign mprv = (debug_mode && !dcsr_q.mprven) ? 1'b0 : mstatus_q.mprv;
2607                      end else begin
2608                        assign mprv = mstatus_q.mprv;
2609                      end
2610                      assign debug_mode_o = debug_mode;
2611                      assign single_step_o = CVA6Cfg.DebugEn ? dcsr_q.step : 1'b0;
2612                      assign mcountinhibit_o = {{29 - MHPMCounterNum{1'b0}}, mcountinhibit_q};
2613                    
2614                      // sequential process
2615                      always_ff @(posedge clk_i or negedge rst_ni) begin
2616       1/1              if (~rst_ni) begin
2617       1/1                priv_lvl_q <= riscv::PRIV_LVL_M;
2618                          // floating-point registers
2619       1/1                fcsr_q     <= '0;
2620       1/1                if (CVA6Cfg.RVZCMT) begin
2621       unreachable          jvt_q <= '0;
2622                          end
                        MISSING_ELSE
2623                          // debug signals
2624       1/1                if (CVA6Cfg.DebugEn) begin
2625       unreachable          debug_mode_q <= 1'b0;
2626       unreachable          dcsr_q       <= '{xdebugver: 4'h4, prv: riscv::PRIV_LVL_M, default: '0};
2627       unreachable          dpc_q        <= '0;
2628       unreachable          dscratch0_q  <= {CVA6Cfg.XLEN{1'b0}};
2629       unreachable          dscratch1_q  <= {CVA6Cfg.XLEN{1'b0}};
2630                          end
                        MISSING_ELSE
2631                          // machine mode registers
2632       1/1                mstatus_q        <= 64'b0;
2633                          // set to boot address + direct mode + 4 byte offset which is the initial trap
2634       1/1                mtvec_rst_load_q <= 1'b1;
2635       1/1                mtvec_q          <= '0;
2636       1/1                mip_q            <= {CVA6Cfg.XLEN{1'b0}};
2637       1/1                mie_q            <= {CVA6Cfg.XLEN{1'b0}};
2638       1/1                mepc_q           <= {CVA6Cfg.XLEN{1'b0}};
2639       1/1                mcause_q         <= {CVA6Cfg.XLEN{1'b0}};
2640       1/1                mcounteren_q     <= {CVA6Cfg.XLEN{1'b0}};
2641       1/1                mscratch_q       <= {CVA6Cfg.XLEN{1'b0}};
2642       1/1(1 unreachable)        if (CVA6Cfg.TvalEn) mtval_q <= {CVA6Cfg.XLEN{1'b0}};
                        MISSING_ELSE
2643       1/1                fiom_q          <= '0;
2644       1/1                dcache_q        <= {{CVA6Cfg.XLEN - 1{1'b0}}, 1'b1};
2645       1/1                icache_q        <= {{CVA6Cfg.XLEN - 1{1'b0}}, 1'b1};
2646       1/1                mcountinhibit_q <= '0;
2647       1/1                acc_cons_q      <= {{CVA6Cfg.XLEN - 1{1'b0}}, CVA6Cfg.EnableAccelerator};
2648                          // supervisor mode registers
2649       1/1                if (CVA6Cfg.RVS) begin
2650       unreachable          medeleg_q    <= {CVA6Cfg.XLEN{1'b0}};
2651       unreachable          mideleg_q    <= {CVA6Cfg.XLEN{1'b0}};
2652       unreachable          sepc_q       <= {CVA6Cfg.XLEN{1'b0}};
2653       unreachable          scause_q     <= {CVA6Cfg.XLEN{1'b0}};
2654       unreachable          stvec_q      <= {CVA6Cfg.XLEN{1'b0}};
2655       unreachable          scounteren_q <= {CVA6Cfg.XLEN{1'b0}};
2656       unreachable          sscratch_q   <= {CVA6Cfg.XLEN{1'b0}};
2657       unreachable          stval_q      <= {CVA6Cfg.XLEN{1'b0}};
2658       unreachable          satp_q       <= {CVA6Cfg.XLEN{1'b0}};
2659                          end
                        MISSING_ELSE
2660                    
2661       1/1                if (CVA6Cfg.RVH) begin
2662       unreachable          v_q                      <= '0;
2663       unreachable          mtval2_q                 <= {CVA6Cfg.XLEN{1'b0}};
2664       unreachable          mtinst_q                 <= {CVA6Cfg.XLEN{1'b0}};
2665       unreachable          hstatus_q                <= 64'b0;
2666       unreachable          hedeleg_q                <= {CVA6Cfg.XLEN{1'b0}};
2667       unreachable          hideleg_q                <= {CVA6Cfg.XLEN{1'b0}};
2668       unreachable          hgeie_q                  <= {CVA6Cfg.XLEN{1'b0}};
2669       unreachable          hgatp_q                  <= {CVA6Cfg.XLEN{1'b0}};
2670       unreachable          hcounteren_q             <= {CVA6Cfg.XLEN{1'b0}};
2671       unreachable          htval_q                  <= {CVA6Cfg.XLEN{1'b0}};
2672       unreachable          htinst_q                 <= {CVA6Cfg.XLEN{1'b0}};
2673                            // virtual supervisor mode registers
2674       unreachable          vsstatus_q               <= 64'b0;
2675       unreachable          vsepc_q                  <= {CVA6Cfg.XLEN{1'b0}};
2676       unreachable          vscause_q                <= {CVA6Cfg.XLEN{1'b0}};
2677       unreachable          vstvec_q                 <= {CVA6Cfg.XLEN{1'b0}};
2678       unreachable          vsscratch_q              <= {CVA6Cfg.XLEN{1'b0}};
2679       unreachable          vstval_q                 <= {CVA6Cfg.XLEN{1'b0}};
2680       unreachable          vsatp_q                  <= {CVA6Cfg.XLEN{1'b0}};
2681       unreachable          en_ld_st_g_translation_q <= 1'b0;
2682                          end
                        MISSING_ELSE
2683                          // timer and counters
2684       1/1                cycle_q                <= 64'b0;
2685       1/1                instret_q              <= 64'b0;
2686                          // aux registers
2687       1/1                en_ld_st_translation_q <= 1'b0;
2688                          // wait for interrupt
2689       1/1                wfi_q                  <= 1'b0;
2690                          // pmp
2691       1/1                for (int i = 0; i < 64; i++) begin
2692       1/1                  if (CVA6Cfg.NrPMPEntries != 0 && i < CVA6Cfg.NrPMPEntries) begin
2693       unreachable            pmpcfg_q[i]  <= riscv::pmpcfg_t'(CVA6Cfg.PMPCfgRstVal[i]);
2694       unreachable            pmpaddr_q[i] <= CVA6Cfg.PMPAddrRstVal[i][CVA6Cfg.PLEN-3:0];
2695                            end else begin
2696       1/1                    pmpcfg_q[i]  <= '0;
2697       1/1                    pmpaddr_q[i] <= '0;
2698                            end
2699                          end
2700                        end else begin
2701       1/1                priv_lvl_q <= priv_lvl_d;
2702                          // floating-point registers
2703       1/1                fcsr_q     <= fcsr_d;
2704       1/1                if (CVA6Cfg.RVZCMT) begin
2705       unreachable          jvt_q <= jvt_d;
2706                          end
                        MISSING_ELSE
2707                          // debug signals
2708       1/1                if (CVA6Cfg.DebugEn) begin
2709       unreachable          debug_mode_q <= debug_mode_d;
2710       unreachable          dcsr_q       <= dcsr_d;
2711       unreachable          dpc_q        <= dpc_d;
2712       unreachable          dscratch0_q  <= dscratch0_d;
2713       unreachable          dscratch1_q  <= dscratch1_d;
2714                          end
                        MISSING_ELSE
2715                          // machine mode registers
2716       1/1                mstatus_q        <= mstatus_d;
2717       1/1                mtvec_rst_load_q <= 1'b0;
2718       1/1                mtvec_q          <= mtvec_d;
2719       1/1                mip_q            <= mip_d;
2720       1/1                mie_q            <= mie_d;
2721       1/1                mepc_q           <= mepc_d;
2722       1/1                mcause_q         <= mcause_d;
2723       1/1                mcounteren_q     <= mcounteren_d;
2724       1/1                mscratch_q       <= mscratch_d;
2725       1/1(1 unreachable)        if (CVA6Cfg.TvalEn) mtval_q <= mtval_d;
                        MISSING_ELSE
2726       1/1                fiom_q          <= fiom_d;
2727       1/1                dcache_q        <= dcache_d;
2728       1/1                icache_q        <= icache_d;
2729       1/1                mcountinhibit_q <= mcountinhibit_d;
2730       1/1                acc_cons_q      <= acc_cons_d;
2731                          // supervisor mode registers
2732       1/1                if (CVA6Cfg.RVS) begin
2733       unreachable          medeleg_q    <= medeleg_d;
2734       unreachable          mideleg_q    <= mideleg_d;
2735       unreachable          sepc_q       <= sepc_d;
2736       unreachable          scause_q     <= scause_d;
2737       unreachable          stvec_q      <= stvec_d;
2738       unreachable          scounteren_q <= scounteren_d;
2739       unreachable          sscratch_q   <= sscratch_d;
2740       unreachable          if (CVA6Cfg.TvalEn) stval_q <= stval_d;
                   ==>  MISSING_ELSE
2741       unreachable          satp_q <= satp_d;
2742                          end
                        MISSING_ELSE
2743       1/1                if (CVA6Cfg.RVH) begin
2744       unreachable          v_q                      <= v_d;
2745       unreachable          mtval2_q                 <= mtval2_d;
2746       unreachable          mtinst_q                 <= mtinst_d;
2747                            // hypervisor mode registers
2748       unreachable          hstatus_q                <= hstatus_d;
2749       unreachable          hedeleg_q                <= hedeleg_d;
2750       unreachable          hideleg_q                <= hideleg_d;
2751       unreachable          hgeie_q                  <= hgeie_d;
2752       unreachable          hgatp_q                  <= hgatp_d;
2753       unreachable          hcounteren_q             <= hcounteren_d;
2754       unreachable          htval_q                  <= htval_d;
2755       unreachable          htinst_q                 <= htinst_d;
2756                            // virtual supervisor mode registers
2757       unreachable          vsstatus_q               <= vsstatus_d;
2758       unreachable          vsepc_q                  <= vsepc_d;
2759       unreachable          vscause_q                <= vscause_d;
2760       unreachable          vstvec_q                 <= vstvec_d;
2761       unreachable          vsscratch_q              <= vsscratch_d;
2762       unreachable          vstval_q                 <= vstval_d;
2763       unreachable          vsatp_q                  <= vsatp_d;
2764       unreachable          en_ld_st_g_translation_q <= en_ld_st_g_translation_d;
2765                          end
                        MISSING_ELSE
2766                          // timer and counters
2767       1/1                cycle_q                <= cycle_d;
2768       1/1                instret_q              <= instret_d;
2769                          // aux registers
2770       1/1                en_ld_st_translation_q <= en_ld_st_translation_d;
2771                          // wait for interrupt
2772       1/1                wfi_q                  <= wfi_d;
2773                          // pmp
2774       1/1                pmpcfg_q               <= pmpcfg_next;
2775       1/1                pmpaddr_q              <= pmpaddr_next;
2776                        end
2777                      end
2778                    
2779                      // write logic pmp
2780                      always_comb begin : write
2781       1/1              for (int i = 0; i < 64; i++) begin
2782       1/1                if (CVA6Cfg.NrPMPEntries != 0 && i < CVA6Cfg.NrPMPEntries) begin
2783       unreachable          if (!CVA6Cfg.PMPEntryReadOnly[i]) begin
2784                              // PMP locked logic is handled in the CSR write process above
2785       unreachable            pmpcfg_next[i] = pmpcfg_d[i];
2786                              // We only support >=8-byte granularity, NA4 is not supported
2787       unreachable            if ((!CVA6Cfg.PMPNapotEn && pmpcfg_d[i].addr_mode == riscv::NAPOT) ||pmpcfg_d[i].addr_mode == riscv::NA4) begin
2788       unreachable              pmpcfg_next[i].addr_mode = pmpcfg_q[i].addr_mode;
2789                              end
                   ==>  MISSING_ELSE
2790                              // Follow collective WARL spec for RWX fields
2791       unreachable            if (pmpcfg_d[i].access_type.r == '0 && pmpcfg_d[i].access_type.w == '1) begin
2792       unreachable              pmpcfg_next[i].access_type = pmpcfg_q[i].access_type;
2793                              end
                   ==>  MISSING_ELSE
2794                            end else begin
2795       unreachable            pmpcfg_next[i] = pmpcfg_q[i];
2796                            end
2797       unreachable          if (!CVA6Cfg.PMPEntryReadOnly[i]) begin
2798       unreachable            pmpaddr_next[i] = pmpaddr_d[i];
2799                            end else begin
2800       unreachable            pmpaddr_next[i] = pmpaddr_q[i];
2801                            end
2802                          end else begin
2803       1/1                  pmpcfg_next[i]  = '0;
2804       1/1                  pmpaddr_next[i] = '0;

-------------------------------------------------------------------------------
Cond Coverage for Module : csr_regfile

               Total   Covered  Percent
Conditions         41       40    97.56
Logical            41       40    97.56
Non-Logical         0        0
Event               0        0

 LINE       468
 EXPRESSION ((priv_lvl_o == PRIV_LVL_S) && hstatus_q.vtvm && v_q)
             -------------1------------    -------2------    -3-

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       468
 SUB-EXPRESSION (priv_lvl_o == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       508
 EXPRESSION ((priv_lvl_o == PRIV_LVL_S) && mstatus_q.tvm)
             -------------1------------    ------2------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       508
 SUB-EXPRESSION (priv_lvl_o == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       560
 EXPRESSION ((priv_lvl_o == PRIV_LVL_S) && ((!v_q)) && mstatus_q.tvm)
             -------------1------------    ----2---    ------3------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       560
 SUB-EXPRESSION (priv_lvl_o == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       951
 EXPRESSION (commit_ack_i[0] && ((!(ex_i.valid && 1'b0))) && (((!1'b0) || (1'b0 && (!mcountinhibit_q[2])))))
             -------1-------    ------------2------------    -----------------------3----------------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Covered

 LINE       955
 EXPRESSION (commit_ack_i[i] && ((!ex_i.valid)) && (((!1'b0) || (1'b0 && (!mcountinhibit_q[2])))))
             -------1-------    -------2-------    -----------------------3----------------------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       1195
 EXPRESSION ((priv_lvl_o == PRIV_LVL_S) && hstatus_q.vtvm && v_q)
             -------------1------------    -------2------    -3-

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       1195
 SUB-EXPRESSION (priv_lvl_o == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1202
 EXPRESSION ((vm_mode_t'(vsatp.mode) == ModeOff) || (vm_mode_t'(vsatp.mode) == 4'b1))
             -----------------1-----------------    ----------------2---------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1202
 SUB-EXPRESSION (vm_mode_t'(vsatp.mode) == ModeOff)
                -----------------1-----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1202
 SUB-EXPRESSION (vm_mode_t'(vsatp.mode) == 4'b1)
                ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1228
 EXPRESSION (mstatus_d.mpp == PRIV_LVL_HS)
            ---------------1--------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1282
 EXPRESSION ((priv_lvl_o == PRIV_LVL_S) && mstatus_q.tvm)
             -------------1------------    ------2------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1282
 SUB-EXPRESSION (priv_lvl_o == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1288
 EXPRESSION ((vm_mode_t'(satp.mode) == ModeOff) || (vm_mode_t'(satp.mode) == 4'b1))
             -----------------1----------------    ---------------2---------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1288
 SUB-EXPRESSION (vm_mode_t'(satp.mode) == ModeOff)
                -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1288
 SUB-EXPRESSION (vm_mode_t'(satp.mode) == 4'b1)
                ---------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1393
 EXPRESSION ((priv_lvl_o == PRIV_LVL_S) && ((!v_q)) && mstatus_q.tvm)
             -------------1------------    ----2---    ------3------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       1393
 SUB-EXPRESSION (priv_lvl_o == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1402
 EXPRESSION ((vm_mode_t'(hgatp.mode) == ModeOff) || (vm_mode_t'(hgatp.mode) == 4'b1))
             -----------------1-----------------    ----------------2---------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1402
 SUB-EXPRESSION (vm_mode_t'(hgatp.mode) == ModeOff)
                -----------------1-----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1402
 SUB-EXPRESSION (vm_mode_t'(hgatp.mode) == 4'b1)
                ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1438
 EXPRESSION ((((!1'b0)) & (mstatus_d.mpp == PRIV_LVL_HS)) | (((!1'b0)) & (mstatus_d.mpp == PRIV_LVL_S)) | (((!1'b0)) & (mstatus_d.mpp == PRIV_LVL_U)))
             ----------------------1---------------------   ---------------------2---------------------   ---------------------3---------------------

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Covered
 0   1   0  Covered
 1   0   0  Covered

 LINE       1438
 SUB-EXPRESSION (((!1'b0)) & (mstatus_d.mpp == PRIV_LVL_HS))
                 ----1----   ---------------2--------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       1438
 SUB-EXPRESSION (mstatus_d.mpp == PRIV_LVL_HS)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       1438
 SUB-EXPRESSION (((!1'b0)) & (mstatus_d.mpp == PRIV_LVL_S))
                 ----1----   --------------2--------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       1438
 SUB-EXPRESSION (mstatus_d.mpp == PRIV_LVL_S)
                --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       1438
 SUB-EXPRESSION (((!1'b0)) & (mstatus_d.mpp == PRIV_LVL_U))
                 ----1----   --------------2--------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       1438
 SUB-EXPRESSION (mstatus_d.mpp == PRIV_LVL_U)
                --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       1824
 EXPRESSION ((mstatus_q.xs == Dirty) | (mstatus_q.fs == Dirty))
             -----------1-----------   -----------2-----------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1824
 SUB-EXPRESSION (mstatus_q.xs == Dirty)
                -----------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1824
 SUB-EXPRESSION (mstatus_q.fs == Dirty)
                -----------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1829
 EXPRESSION ((vsstatus_q.xs == Dirty) | (vsstatus_q.fs == Dirty))
             ------------1-----------   ------------2-----------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1829
 SUB-EXPRESSION (vsstatus_q.xs == Dirty)
                ------------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1829
 SUB-EXPRESSION (vsstatus_q.fs == Dirty)
                ------------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1848
 EXPRESSION (acc_fflags_ex_valid_i ? acc_fflags_ex_i : 5'b0)
             ----------1----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1870
 EXPRESSION (((!debug_mode)) && ex_cause_is_not_debug_request && ex_i.valid)
             -------1-------    --------------2--------------    -----3----

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Covered
 1   1   1  Covered

 LINE       1885
 EXPRESSION ((priv_lvl_o == PRIV_LVL_M) ? PRIV_LVL_M : PRIV_LVL_S)
             -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1885
 SUB-EXPRESSION (priv_lvl_o == PRIV_LVL_M)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1908
 EXPRESSION (ex_i.cause[(32'b00000000000000000000000000100000 - 1)] ? ({ex_i.cause[32'b00000000000000000000000000011111:2], 2'b1}) : ex_i.cause)
             ---------------------------1--------------------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1912
 EXPRESSION 
 Number  Term
      1  (ariane_pkg::ZERO_TVAL && ((ex_i.cause inside {riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE}) || ex_i.cause[(32'b00000000000000000000000000100000 - 1)])) ? '0 : ex_i.tval)

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1912
 SUB-EXPRESSION 
 Number  Term
      1  ariane_pkg::ZERO_TVAL && 
      2  ((ex_i.cause inside {riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE}) || ex_i.cause[(32'b00000000000000000000000000100000 - 1)]))

-1- -2- Status
 -   0  Unreachable
 -   1  Unreachable

 LINE       1912
 SUB-EXPRESSION ((ex_i.cause inside {riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE}) || ex_i.cause[(32'b00000000000000000000000000100000 - 1)])
                 ------------------------------------------1-----------------------------------------    ---------------------------2--------------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1929
 EXPRESSION 
 Number  Term
      1  (ariane_pkg::ZERO_TVAL && ((ex_i.cause inside {riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE}) || ex_i.cause[(32'b00000000000000000000000000100000 - 1)])) ? '0 : ex_i.tval)

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1929
 SUB-EXPRESSION 
 Number  Term
      1  ariane_pkg::ZERO_TVAL && 
      2  ((ex_i.cause inside {riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE}) || ex_i.cause[(32'b00000000000000000000000000100000 - 1)]))

-1- -2- Status
 -   0  Unreachable
 -   1  Unreachable

 LINE       1929
 SUB-EXPRESSION 
 Number  Term
      1  (ex_i.cause inside {riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE}) || 
      2  ex_i.cause[(32'b00000000000000000000000000100000 - 1)])

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1938
 EXPRESSION 
 Number  Term
      1  (ariane_pkg::ZERO_TVAL && ((ex_i.cause inside {riscv::INSTR_ACCESS_FAULT, riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE, riscv::INSTR_PAGE_FAULT, riscv::INSTR_GUEST_PAGE_FAULT, riscv::VIRTUAL_INSTRUCTION}) || ex_i.cause[(32'b00000000000000000000000000100000 - 1)])) ? '0 : ({{(32'b00000000000000000000000000100000 - 32) {1'b0}}, ex_i.tinst}))

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1938
 SUB-EXPRESSION 
 Number  Term
      1  ariane_pkg::ZERO_TVAL && 
      2  ((ex_i.cause inside {riscv::INSTR_ACCESS_FAULT, riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE, riscv::INSTR_PAGE_FAULT, riscv::INSTR_GUEST_PAGE_FAULT, riscv::VIRTUAL_INSTRUCTION}) || ex_i.cause[(32'b00000000000000000000000000100000 - 1)]))

-1- -2- Status
 -   0  Unreachable
 -   1  Unreachable

 LINE       1938
 SUB-EXPRESSION 
 Number  Term
      1  (ex_i.cause inside {riscv::INSTR_ACCESS_FAULT, riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE, riscv::INSTR_PAGE_FAULT, riscv::INSTR_GUEST_PAGE_FAULT, riscv::VIRTUAL_INSTRUCTION}) || 
      2  ex_i.cause[(32'b00000000000000000000000000100000 - 1)])

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1950
 EXPRESSION (v_q ? priv_lvl_q[0] : hstatus_d.spvp)
             -1-

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1968
 EXPRESSION 
 Number  Term
      1  (ariane_pkg::ZERO_TVAL && (((ex_i.cause inside {riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE}) || ex_i.cause[(32'b00000000000000000000000000100010 - 1)]))) ? '0 : ex_i.tval)

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1968
 SUB-EXPRESSION 
 Number  Term
      1  ariane_pkg::ZERO_TVAL && 
      2  (((ex_i.cause inside {riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE}) || ex_i.cause[(32'b00000000000000000000000000100010 - 1)])))

-1- -2- Status
 -   0  Unreachable
 -   1  Unreachable

 LINE       1983
 EXPRESSION 
 Number  Term
      1  (ariane_pkg::ZERO_TVAL && ((ex_i.cause inside {riscv::INSTR_ADDR_MISALIGNED, riscv::INSTR_ACCESS_FAULT, riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE, riscv::INSTR_PAGE_FAULT, riscv::INSTR_GUEST_PAGE_FAULT, riscv::VIRTUAL_INSTRUCTION}) || ex_i.cause[(32'b00000000000000000000000000100000 - 1)])) ? '0 : ({{(32'b00000000000000000000000000100000 - 32) {1'b0}}, ex_i.tinst}))

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1983
 SUB-EXPRESSION 
 Number  Term
      1  ariane_pkg::ZERO_TVAL && 
      2  ((ex_i.cause inside {riscv::INSTR_ADDR_MISALIGNED, riscv::INSTR_ACCESS_FAULT, riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE, riscv::INSTR_PAGE_FAULT, riscv::INSTR_GUEST_PAGE_FAULT, riscv::VIRTUAL_INSTRUCTION}) || ex_i.cause[(32'b00000000000000000000000000100000 - 1)]))

-1- -2- Status
 -   0  Unreachable
 -   1  Unreachable

 LINE       1983
 SUB-EXPRESSION 
 Number  Term
      1  (ex_i.cause inside {riscv::INSTR_ADDR_MISALIGNED, riscv::INSTR_ACCESS_FAULT, riscv::ILLEGAL_INSTR, riscv::BREAKPOINT, riscv::ENV_CALL_UMODE, riscv::ENV_CALL_SMODE, riscv::ENV_CALL_MMODE, riscv::INSTR_PAGE_FAULT, riscv::INSTR_GUEST_PAGE_FAULT, riscv::VIRTUAL_INSTRUCTION}) || 
      2  ex_i.cause[(32'b00000000000000000000000000100000 - 1)])

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2025
 EXPRESSION (ex_i.valid && (ex_i.cause == riscv::BREAKPOINT))
             -----1----    ----------------2----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2025
 SUB-EXPRESSION (ex_i.cause == riscv::BREAKPOINT)
                ----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2055
 EXPRESSION (ex_i.valid && (ex_i.cause == riscv::DEBUG_REQUEST))
             -----1----    ------------------2-----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2055
 SUB-EXPRESSION (ex_i.cause == riscv::DEBUG_REQUEST)
                ------------------1-----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2069
 EXPRESSION (dcsr_q.step && commit_ack_i[0])
             -----1-----    -------2-------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2073
 EXPRESSION (commit_instr_i.fu == CTRL_FLOW)
            ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2098
 EXPRESSION (debug_mode && ex_i.valid && (ex_i.cause == riscv::BREAKPOINT))
             -----1----    -----2----    ----------------3----------------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2098
 SUB-EXPRESSION (ex_i.cause == riscv::BREAKPOINT)
                ----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2109
 EXPRESSION (mprv && (mstatus_q.mpv == 1'b0) && (vm_mode_t'(satp_q.mode) == 4'b1) && (mstatus_q.mpp != PRIV_LVL_M))
             --1-    -----------2-----------    ----------------3----------------    --------------4--------------

-1- -2- -3- -4- Status
 0   1   1   1  Unreachable
 1   0   1   1  Unreachable
 1   1   0   1  Unreachable
 1   1   1   0  Unreachable
 1   1   1   1  Unreachable

 LINE       2109
 SUB-EXPRESSION (mstatus_q.mpv == 1'b0)
                -----------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2109
 SUB-EXPRESSION (vm_mode_t'(satp_q.mode) == 4'b1)
                ----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2109
 SUB-EXPRESSION (mstatus_q.mpp != PRIV_LVL_M)
                --------------1--------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2111
 EXPRESSION (mprv && (mstatus_q.mpv == 1'b1))
             --1-    -----------2-----------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2111
 SUB-EXPRESSION (mstatus_q.mpv == 1'b1)
                -----------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2121
 EXPRESSION (mprv && (mstatus_q.mpv == 1'b1))
             --1-    -----------2-----------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2121
 SUB-EXPRESSION (mstatus_q.mpv == 1'b1)
                -----------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2122
 EXPRESSION (vm_mode_t'(hgatp_q.mode) == 4'b1)
            -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2132
 EXPRESSION (mprv ? mstatus_q.mpp : priv_lvl_o)
             --1-

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2134
 EXPRESSION ((mprv ? mstatus_q.mpv : v_q) || csr_hs_ld_st_inst_i)
             --------------1-------------    ---------2---------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2134
 SUB-EXPRESSION (mprv ? mstatus_q.mpv : v_q)
                 --1-

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2136
 EXPRESSION ((en_ld_st_translation_q && ((!csr_hs_ld_st_inst_i))) || ((vm_mode_t'(vsatp_q.mode) == 4'b1) && csr_hs_ld_st_inst_i))
             --------------------------1-------------------------    -----------------------------2-----------------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2136
 SUB-EXPRESSION (en_ld_st_translation_q && ((!csr_hs_ld_st_inst_i)))
                 -----------1----------    ------------2-----------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2136
 SUB-EXPRESSION ((vm_mode_t'(vsatp_q.mode) == 4'b1) && csr_hs_ld_st_inst_i)
                 -----------------1----------------    ---------2---------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2136
 SUB-EXPRESSION (vm_mode_t'(vsatp_q.mode) == 4'b1)
                -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2138
 EXPRESSION ((en_ld_st_g_translation_q && ((!csr_hs_ld_st_inst_i))) || (csr_hs_ld_st_inst_i && (vm_mode_t'(hgatp_q.mode) == 4'b1) && csr_hs_ld_st_inst_i))
             ---------------------------1--------------------------    -----------------------------------------2----------------------------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2138
 SUB-EXPRESSION (en_ld_st_g_translation_q && ((!csr_hs_ld_st_inst_i)))
                 ------------1-----------    ------------2-----------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2138
 SUB-EXPRESSION (csr_hs_ld_st_inst_i && (vm_mode_t'(hgatp_q.mode) == 4'b1) && csr_hs_ld_st_inst_i)
                 ---------1---------    -----------------2----------------    ---------3---------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2138
 SUB-EXPRESSION (vm_mode_t'(hgatp_q.mode) == 4'b1)
                -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2146
 EXPRESSION (mprv ? mstatus_q.mpp : priv_lvl_o)
             --1-

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2179
 EXPRESSION (mstatus_q.mpp != PRIV_LVL_M)
            --------------1--------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2204
 EXPRESSION (sret && v_q)
             --1-    -2-

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2308
 EXPRESSION (((priv_lvl_o == PRIV_LVL_S) && ((!v_q))) ? PRIV_LVL_HS : priv_lvl_o)
             --------------------1-------------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2308
 SUB-EXPRESSION ((priv_lvl_o == PRIV_LVL_S) && ((!v_q)))
                 -------------1------------    ----2---

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2308
 SUB-EXPRESSION (priv_lvl_o == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2320
 EXPRESSION (v_q && (csr_addr.csr_decode.priv_lvl <= PRIV_LVL_HS))
             -1-    ----------------------2----------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2325
 EXPRESSION (((!debug_mode)) && (csr_addr_i[11:4] == 8'h7b))
             -------1-------    -------------2-------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2325
 SUB-EXPRESSION (csr_addr_i[11:4] == 8'h7b)
                -------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2331
 EXPRESSION ((csr_addr_i inside {[CSR_HPM_COUNTER_3:CSR_HPM_COUNTER_31]}) | (csr_addr_i inside {[CSR_HPM_COUNTER_3H:CSR_HPM_COUNTER_31H]}))
             ------------------------------1-----------------------------   -------------------------------2------------------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2334
 EXPRESSION (v_q & mcounteren_q[sel_cnt_en] & ((~hcounteren_q[sel_cnt_en])))
             -1-   ------------2-----------   --------------3--------------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2337
 EXPRESSION (v_q & mcounteren_q[sel_cnt_en] & ((~hcounteren_q[sel_cnt_en])))
             -1-   ------------2-----------   --------------3--------------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2339
 EXPRESSION (((~mcounteren_q[sel_cnt_en])) & ((~scounteren_q[sel_cnt_en])) & hcounteren_q[sel_cnt_en])
             --------------1--------------   --------------2--------------   ------------3-----------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2341
 EXPRESSION (((~mcounteren_q[sel_cnt_en])) & ((~scounteren_q[sel_cnt_en])))
             --------------1--------------   --------------2--------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2343
 EXPRESSION (priv_lvl_o == PRIV_LVL_M)
            -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2349
 EXPRESSION ((csr_addr_i inside {[CSR_CYCLE:CSR_INSTRET]}) | (csr_addr_i inside {[CSR_CYCLEH:CSR_INSTRETH]}))
             ----------------------1----------------------   -----------------------2-----------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2352
 EXPRESSION (v_q & mcounteren_q[sel_cnt_en] & ((~hcounteren_q[sel_cnt_en])))
             -1-   ------------2-----------   --------------3--------------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2355
 EXPRESSION (v_q & mcounteren_q[sel_cnt_en] & ((~hcounteren_q[sel_cnt_en])))
             -1-   ------------2-----------   --------------3--------------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2357
 EXPRESSION (((~mcounteren_q[sel_cnt_en])) & ((~scounteren_q[sel_cnt_en])) & hcounteren_q[sel_cnt_en])
             --------------1--------------   --------------2--------------   ------------3-----------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2359
 EXPRESSION (((~mcounteren_q[sel_cnt_en])) & ((~scounteren_q[sel_cnt_en])))
             --------------1--------------   --------------2--------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2361
 EXPRESSION (priv_lvl_o == PRIV_LVL_M)
            -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2379
 EXPRESSION (((!debug_mode)) && (csr_addr_i[11:4] == 8'h7b))
             -------1-------    -------------2-------------

-1- -2- Status
 0   1  Unreachable
 1   0  Covered
 1   1  Covered

 LINE       2379
 SUB-EXPRESSION (csr_addr_i[11:4] == 8'h7b)
                -------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       2385
 EXPRESSION ((csr_addr_i inside {[CSR_HPM_COUNTER_3:CSR_HPM_COUNTER_31]}) | (csr_addr_i inside {[CSR_HPM_COUNTER_3H:CSR_HPM_COUNTER_31H]}))
             ------------------------------1-----------------------------   -------------------------------2------------------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2390
 EXPRESSION (((~mcounteren_q[csr_addr_i[4:0]])) | ((~scounteren_q[csr_addr_i[4:0]])))
             -----------------1----------------   -----------------2----------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2391
 EXPRESSION (priv_lvl_o == PRIV_LVL_M)
            -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2397
 EXPRESSION ((csr_addr_i inside {[CSR_CYCLE:CSR_INSTRET]}) | (csr_addr_i inside {[CSR_CYCLEH:CSR_INSTRETH]}))
             ----------------------1----------------------   -----------------------2-----------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2402
 EXPRESSION (((~mcounteren_q[csr_addr_i[4:0]])) | ((~scounteren_q[csr_addr_i[4:0]])))
             -----------------1----------------   -----------------2----------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2403
 EXPRESSION (priv_lvl_o == PRIV_LVL_M)
            -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2423
 EXPRESSION (update_access_exception || read_access_exception)
             -----------1-----------    ----------2----------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       2436
 EXPRESSION (virtual_update_access_exception || virtual_read_access_exception || virtual_privilege_violation)
             ---------------1---------------    --------------2--------------    -------------3-------------

-1- -2- -3- Status
 0   0   0  Unreachable
 0   0   1  Unreachable
 0   1   0  Unreachable
 1   0   0  Unreachable

 LINE       2451
 EXPRESSION (((|(mip_q & mie_q))) || ((1'b0 && debug_req_i)) || irq_i[1])
             ----------1---------    -----------2-----------    ----3---

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Unreachable
 0   1   0  Unreachable
 1   0   0  Covered

 LINE       2455
 EXPRESSION (((!debug_mode)) && (csr_op_i == WFI) && ((!ex_i.valid)))
             -------1-------    --------2--------    -------3-------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Covered
 1   1   0  Not Covered
 1   1   1  Covered

 LINE       2455
 SUB-EXPRESSION (csr_op_i == WFI)
                --------1--------

-1- Status
 0  Covered
 1  Covered

 LINE       2465
 EXPRESSION (trap_to_priv_lvl == PRIV_LVL_S)
            ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2485
 EXPRESSION ((trap_to_priv_lvl == PRIV_LVL_S) && ((!trap_to_v)) && stvec_q[0])
             ----------------1---------------    -------2------    -----3----

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2485
 SUB-EXPRESSION (trap_to_priv_lvl == PRIV_LVL_S)
                ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2490
 EXPRESSION ((trap_to_priv_lvl == PRIV_LVL_S) && trap_to_v && vstvec_q[0])
             ----------------1---------------    ----2----    -----3-----

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       2490
 SUB-EXPRESSION (trap_to_priv_lvl == PRIV_LVL_S)
                ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2787
 EXPRESSION ((((!1'b0)) && (pmpcfg_d[i].addr_mode == NAPOT)) || (pmpcfg_d[i].addr_mode == NA4))
             -----------------------1-----------------------    ---------------2--------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       2787
 SUB-EXPRESSION (((!1'b0)) && (pmpcfg_d[i].addr_mode == NAPOT))
                 ----1----    ----------------2---------------

-1- -2- Status
 -   0  Unreachable
 -   1  Unreachable

 LINE       2787
 SUB-EXPRESSION (pmpcfg_d[i].addr_mode == NAPOT)
                ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2787
 SUB-EXPRESSION (pmpcfg_d[i].addr_mode == NA4)
                ---------------1--------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2791
 EXPRESSION ((pmpcfg_d[i].access_type.r == '0) && (pmpcfg_d[i].access_type.w == '1))
             ----------------1----------------    ----------------2----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       2791
 SUB-EXPRESSION (pmpcfg_d[i].access_type.r == '0)
                ----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2791
 SUB-EXPRESSION (pmpcfg_d[i].access_type.w == '1)
                ----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       2535
 EXPRESSION (debug_mode ? PRIV_LVL_M : priv_lvl_q)
             -----1----

-1- Status
 0  Covered
 1  Unreachable

 LINE       2599
 EXPRESSION (icache_q[0] & ((~debug_mode)))
             -----1-----   -------2-------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       2298
 EXPRESSION ((mstatus_q.mie & (((priv_lvl_o == PRIV_LVL_M) | (!1'b0)))) | ((1'b0 & (priv_lvl_o != PRIV_LVL_M))))
             -----------------------------1----------------------------   ------------------2------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       2298
 SUB-EXPRESSION (mstatus_q.mie & (((priv_lvl_o == PRIV_LVL_M) | (!1'b0))))
                 ------1------   --------------------2-------------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       2087
 SUB-EXPRESSION (commit_instr_i.is_compressed ? 'h00000002 : 'h00000004)
                 --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.csr_regfile_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 98.78 100.00  97.56 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 98.78 100.00  97.56 --     


Module : 

SCORE  LINE   COND   ASSERT NAME        
 98.78 100.00  97.56 --     csr_regfile 


Parent : 

SCORE  LINE   COND   ASSERT NAME                               
100.00 100.00 100.00 --     cva6_only_pipeline.i_cva6_pipeline 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : compressed_decoder
===============================================================================
SCORE  LINE   COND   ASSERT 
 99.06  98.11 100.00 --     

Source File(s) : 

cva6/core/compressed_decoder.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                               
 99.06  98.11 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.id_stage_i.genblk1.genblk1[0].compressed_decoder_i 



-------------------------------------------------------------------------------
Line Coverage for Module : compressed_decoder

             Line No.   Total   Covered  Percent
TOTAL                      106      104    98.11
ALWAYS             43      106      104    98.11

42                        always_comb begin
43         1/1              illegal_instr_o  = 1'b0;
44         1/1              is_compressed_o  = 1'b1;
45         1/1              instr_o          = instr_i;
46         1/1              is_macro_instr_o = 0;
47         1/1              is_zcmt_instr_o  = 1'b0;
48                      
49                          // I: |    imm[11:0]    | rs1 | funct3 |    rd    | opcode |
50                          // S: | imm[11:5] | rs2 | rs1 | funct3 | imm[4:0] | opcode |
51         1/1              unique case (instr_i[1:0])
52                            // C0
53                            riscv::OpcodeC0: begin
54         1/1                  unique case (instr_i[15:13])
55                                riscv::OpcodeC0Addi4spn: begin
56                                  // c.addi4spn -> addi rd', x2, imm
57         1/1                      instr_o = {
58                                    2'b0,
59                                    instr_i[10:7],
60                                    instr_i[12:11],
61                                    instr_i[5],
62                                    instr_i[6],
63                                    2'b00,
64                                    5'h02,
65                                    3'b000,
66                                    2'b01,
67                                    instr_i[4:2],
68                                    riscv::OpcodeOpImm
69                                  };
70         2/2                      if (instr_i[12:5] == 8'b0) illegal_instr_o = 1'b1;
                        MISSING_ELSE
71                                end
72                      
73                                riscv::OpcodeC0Fld: begin
74         1/1                      if (CVA6Cfg.FpPresent) begin
75                                    // c.fld -> fld rd', imm(rs1')
76                                    // CLD: | funct3 | imm[5:3] | rs1' | imm[7:6] | rd' | C0 |
77         unreachable                instr_o = {
78                                      4'b0,
79                                      instr_i[6:5],
80                                      instr_i[12:10],
81                                      3'b000,
82                                      2'b01,
83                                      instr_i[9:7],
84                                      3'b011,
85                                      2'b01,
86                                      instr_i[4:2],
87                                      riscv::OpcodeLoadFp
88                                    };
89                                  end else begin
90         1/1                        illegal_instr_o = 1'b1;
91                                  end
92                                end
93                      
94                                riscv::OpcodeC0Lw: begin
95                                  // c.lw -> lw rd', imm(rs1')
96         1/1                      instr_o = {
97                                    5'b0,
98                                    instr_i[5],
99                                    instr_i[12:10],
100                                   instr_i[6],
101                                   2'b00,
102                                   2'b01,
103                                   instr_i[9:7],
104                                   3'b010,
105                                   2'b01,
106                                   instr_i[4:2],
107                                   riscv::OpcodeLoad
108                                 };
109                               end
110                     
111                               riscv::OpcodeC0Ld: begin
112                                 // RV64
113                                 //   c.ld -> ld rd', imm(rs1')
114                                 // RV32
115                                 //   c.flw -> flw fprd', imm(rs1')
116        1/1                      if (CVA6Cfg.IS_XLEN64) begin
117                                   // CLD: | funct3 | imm[5:3] | rs1' | imm[7:6] | rd' | C0 |
118        unreachable                instr_o = {
119                                     4'b0,
120                                     instr_i[6:5],
121                                     instr_i[12:10],
122                                     3'b000,
123                                     2'b01,
124                                     instr_i[9:7],
125                                     3'b011,
126                                     2'b01,
127                                     instr_i[4:2],
128                                     riscv::OpcodeLoad
129                                   };
130                                 end else begin
131        1/1                        if (CVA6Cfg.FpPresent) begin
132                                     // CFLW: | funct3 (change to LW) | imm[5:3] | rs1' | imm[2|6] | rd' | C0 |
133        unreachable                  instr_o = {
134                                       5'b0,
135                                       instr_i[5],
136                                       instr_i[12:10],
137                                       instr_i[6],
138                                       2'b00,
139                                       2'b01,
140                                       instr_i[9:7],
141                                       3'b010,
142                                       2'b01,
143                                       instr_i[4:2],
144                                       riscv::OpcodeLoadFp
145                                     };
146                                   end else begin
147        1/1                          illegal_instr_o = 1'b1;
148                                   end
149                                 end
150                               end
151                     
152                               riscv::OpcodeC0Zcb: begin
153        1/1                      if (CVA6Cfg.RVZCB) begin
154        1/1                        unique case (instr_i[12:10])
155                                     3'b000: begin
156                                       // c.lbu -> lbu rd', uimm(rs1')
157        1/1                            instr_o = {
158                                         10'b0,
159                                         instr_i[5],
160                                         instr_i[6],
161                                         2'b01,
162                                         instr_i[9:7],
163                                         3'b100,
164                                         2'b01,
165                                         instr_i[4:2],
166                                         riscv::OpcodeLoad
167                                       };
168                                     end
169                     
170                                     3'b001: begin
171        1/1                            if (instr_i[6]) begin
172                                         // c.lh -> lh rd', uimm(rs1')
173        1/1                              instr_o = {
174                                           10'b0,
175                                           instr_i[5],
176                                           1'b0,
177                                           2'b01,
178                                           instr_i[9:7],
179                                           3'b001,
180                                           2'b01,
181                                           instr_i[4:2],
182                                           riscv::OpcodeLoad
183                                         };
184                                       end else begin
185                                         // c.lhu -> lhu rd', uimm(rs1')
186        1/1                              instr_o = {
187                                           10'b0,
188                                           instr_i[5],
189                                           1'b0,
190                                           2'b01,
191                                           instr_i[9:7],
192                                           3'b101,
193                                           2'b01,
194                                           instr_i[4:2],
195                                           riscv::OpcodeLoad
196                                         };
197                                       end
198                                     end
199                     
200                                     3'b010: begin
201                                       // c.sb -> sb rs2', uimm(rs1')
202        1/1                            instr_o = {
203                                         7'b0,
204                                         2'b01,
205                                         instr_i[4:2],
206                                         2'b01,
207                                         instr_i[9:7],
208                                         3'b000,
209                                         3'b0,
210                                         instr_i[5],
211                                         instr_i[6],
212                                         riscv::OpcodeStore
213                                       };
214                                     end
215                     
216                                     3'b011: begin
217                                       // c.sh -> sh rs2', uimm(rs1')
218        1/1                            instr_o = {
219                                         7'b0,
220                                         2'b01,
221                                         instr_i[4:2],
222                                         2'b01,
223                                         instr_i[9:7],
224                                         3'b001,
225                                         3'b0,
226                                         instr_i[5],
227                                         1'b0,
228                                         riscv::OpcodeStore
229                                       };
230                                     end
231                     
232                                     default: begin
233        1/1                            illegal_instr_o = 1'b1;
234                                     end
235                                   endcase
236                     
237                                 end else begin
238        unreachable                instr_o = instr_i;
239        unreachable                illegal_instr_o = 1'b1;
240                                 end
241                               end
242                     
243                               riscv::OpcodeC0Fsd: begin
244        1/1                      if (CVA6Cfg.FpPresent) begin
245                                   // c.fsd -> fsd rs2', imm(rs1')
246        unreachable                instr_o = {
247                                     4'b0,
248                                     instr_i[6:5],
249                                     instr_i[12],
250                                     2'b01,
251                                     instr_i[4:2],
252                                     2'b01,
253                                     instr_i[9:7],
254                                     3'b011,
255                                     instr_i[11:10],
256                                     3'b000,
257                                     riscv::OpcodeStoreFp
258                                   };
259                                 end else begin
260        1/1                        illegal_instr_o = 1'b1;
261                                 end
262                               end
263                     
264                               riscv::OpcodeC0Sw: begin
265                                 // c.sw -> sw rs2', imm(rs1')
266        1/1                      instr_o = {
267                                   5'b0,
268                                   instr_i[5],
269                                   instr_i[12],
270                                   2'b01,
271                                   instr_i[4:2],
272                                   2'b01,
273                                   instr_i[9:7],
274                                   3'b010,
275                                   instr_i[11:10],
276                                   instr_i[6],
277                                   2'b00,
278                                   riscv::OpcodeStore
279                                 };
280                               end
281                     
282                               riscv::OpcodeC0Sd: begin
283                                 // RV64
284                                 //   c.sd -> sd rs2', imm(rs1')
285                                 // RV32
286                                 //   c.fsw -> fsw fprs2', imm(rs1')
287        1/1                      if (CVA6Cfg.IS_XLEN64) begin
288        unreachable                instr_o = {
289                                     4'b0,
290                                     instr_i[6:5],
291                                     instr_i[12],
292                                     2'b01,
293                                     instr_i[4:2],
294                                     2'b01,
295                                     instr_i[9:7],
296                                     3'b011,
297                                     instr_i[11:10],
298                                     3'b000,
299                                     riscv::OpcodeStore
300                                   };
301                                 end else begin
302        1/1                        if (CVA6Cfg.FpPresent) begin
303        unreachable                  instr_o = {
304                                       5'b0,
305                                       instr_i[5],
306                                       instr_i[12],
307                                       2'b01,
308                                       instr_i[4:2],
309                                       2'b01,
310                                       instr_i[9:7],
311                                       3'b010,
312                                       instr_i[11:10],
313                                       instr_i[6],
314                                       2'b00,
315                                       riscv::OpcodeStoreFp
316                                     };
317                                   end else begin
318        1/1                          illegal_instr_o = 1'b1;
319                                   end
320                                 end
321                               end
322                     
323                               default: begin
324        0/1     ==>              illegal_instr_o = 1'b1;
325                               end
326                             endcase
327                           end
328                     
329                           // C1
330                           riscv::OpcodeC1: begin
331        1/1                  unique case (instr_i[15:13])
332                               riscv::OpcodeC1Addi: begin
333                                 // c.addi -> addi rd, rd, nzimm
334                                 // c.nop -> addi 0, 0, 0
335        1/1                      instr_o = {
336                                   {6{instr_i[12]}},
337                                   instr_i[12],
338                                   instr_i[6:2],
339                                   instr_i[11:7],
340                                   3'b0,
341                                   instr_i[11:7],
342                                   riscv::OpcodeOpImm
343                                 };
344                               end
345                     
346                     
347                               riscv::OpcodeC1Addiw: begin  // or riscv::OpcodeC1Jal for RV32IC
348        1/1                      if (CVA6Cfg.IS_XLEN64) begin
349                                   // c.addiw -> addiw rd, rd, nzimm for RV64IC
350        unreachable                if (instr_i[11:7] != 5'h0) begin  // only valid if the destination is not r0
351        unreachable                  instr_o = {
352                                       {6{instr_i[12]}},
353                                       instr_i[12],
354                                       instr_i[6:2],
355                                       instr_i[11:7],
356                                       3'b0,
357                                       instr_i[11:7],
358                                       riscv::OpcodeOpImm32
359                                     };
360                                   end else begin
361        unreachable                  illegal_instr_o = 1'b1;
362                                   end
363                                 end else begin
364                                   // c.jal -> jal x1, imm for RV32IC only
365        1/1                        instr_o = {
366                                     instr_i[12],
367                                     instr_i[8],
368                                     instr_i[10:9],
369                                     instr_i[6],
370                                     instr_i[7],
371                                     instr_i[2],
372                                     instr_i[11],
373                                     instr_i[5:3],
374                                     {9{instr_i[12]}},
375                                     5'b1,
376                                     riscv::OpcodeJal
377                                   };
378                     
379                     
380                     
381                                 end
382                               end
383                     
384                               riscv::OpcodeC1Li: begin
385                                 // c.li -> addi rd, x0, nzimm
386        1/1                      instr_o = {
387                                   {6{instr_i[12]}},
388                                   instr_i[12],
389                                   instr_i[6:2],
390                                   5'b0,
391                                   3'b0,
392                                   instr_i[11:7],
393                                   riscv::OpcodeOpImm
394                                 };
395                               end
396                     
397                               riscv::OpcodeC1LuiAddi16sp: begin
398                                 // c.lui -> lui rd, imm
399        1/1                      instr_o = {{15{instr_i[12]}}, instr_i[6:2], instr_i[11:7], riscv::OpcodeLui};
400                     
401        1/1                      if (instr_i[11:7] == 5'h02) begin
402                                   // c.addi16sp -> addi x2, x2, nzimm
403        1/1                        instr_o = {
404                                     {3{instr_i[12]}},
405                                     instr_i[4:3],
406                                     instr_i[5],
407                                     instr_i[2],
408                                     instr_i[6],
409                                     4'b0,
410                                     5'h02,
411                                     3'b000,
412                                     5'h02,
413                                     riscv::OpcodeOpImm
414                                   };
415                                 end
                        MISSING_ELSE
416                     
417        2/2                      if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;
                        MISSING_ELSE
418                               end
419                     
420                               riscv::OpcodeC1MiscAlu: begin
421        1/1                      unique case (instr_i[11:10])
422                                   2'b00, 2'b01: begin
423                                     // 00: c.srli -> srli rd, rd, shamt
424                                     // 01: c.srai -> srai rd, rd, shamt
425        1/1                          instr_o = {
426                                       1'b0,
427                                       instr_i[10],
428                                       4'b0,
429                                       instr_i[12],
430                                       instr_i[6:2],
431                                       2'b01,
432                                       instr_i[9:7],
433                                       3'b101,
434                                       2'b01,
435                                       instr_i[9:7],
436                                       riscv::OpcodeOpImm
437                                     };
438                                   end
439                     
440                                   2'b10: begin
441                                     // c.andi -> andi rd, rd, imm
442        1/1                          instr_o = {
443                                       {6{instr_i[12]}},
444                                       instr_i[12],
445                                       instr_i[6:2],
446                                       2'b01,
447                                       instr_i[9:7],
448                                       3'b111,
449                                       2'b01,
450                                       instr_i[9:7],
451                                       riscv::OpcodeOpImm
452                                     };
453                                   end
454                     
455                                   2'b11: begin
456        1/1                          unique case ({
457                                       instr_i[12], instr_i[6:5]
458                                     })
459                                       3'b000: begin
460                                         // c.sub -> sub rd', rd', rs2'
461        1/1                              instr_o = {
462                                           2'b01,
463                                           5'b0,
464                                           2'b01,
465                                           instr_i[4:2],
466                                           2'b01,
467                                           instr_i[9:7],
468                                           3'b000,
469                                           2'b01,
470                                           instr_i[9:7],
471                                           riscv::OpcodeOp
472                                         };
473                                       end
474                     
475                                       3'b001: begin
476                                         // c.xor -> xor rd', rd', rs2'
477        1/1                              instr_o = {
478                                           7'b0,
479                                           2'b01,
480                                           instr_i[4:2],
481                                           2'b01,
482                                           instr_i[9:7],
483                                           3'b100,
484                                           2'b01,
485                                           instr_i[9:7],
486                                           riscv::OpcodeOp
487                                         };
488                                       end
489                     
490                                       3'b010: begin
491                                         // c.or  -> or  rd', rd', rs2'
492        1/1                              instr_o = {
493                                           7'b0,
494                                           2'b01,
495                                           instr_i[4:2],
496                                           2'b01,
497                                           instr_i[9:7],
498                                           3'b110,
499                                           2'b01,
500                                           instr_i[9:7],
501                                           riscv::OpcodeOp
502                                         };
503                                       end
504                     
505                                       3'b011: begin
506                                         // c.and -> and rd', rd', rs2'
507        1/1                              instr_o = {
508                                           7'b0,
509                                           2'b01,
510                                           instr_i[4:2],
511                                           2'b01,
512                                           instr_i[9:7],
513                                           3'b111,
514                                           2'b01,
515                                           instr_i[9:7],
516                                           riscv::OpcodeOp
517                                         };
518                                       end
519                     
520                                       3'b100: begin
521        1/1                              if (CVA6Cfg.IS_XLEN64) begin
522                                           // c.subw -> subw rd', rd', rs2'
523        unreachable                        instr_o = {
524                                             2'b01,
525                                             5'b0,
526                                             2'b01,
527                                             instr_i[4:2],
528                                             2'b01,
529                                             instr_i[9:7],
530                                             3'b000,
531                                             2'b01,
532                                             instr_i[9:7],
533                                             riscv::OpcodeOp32
534                                           };
535                                         end else begin
536        1/1                                illegal_instr_o = 1'b1;
537                                         end
538                                       end
539                     
540                                       3'b101: begin
541        1/1                              if (CVA6Cfg.IS_XLEN64) begin
542                                           // c.addw -> addw rd', rd', rs2'
543        unreachable                        instr_o = {
544                                             2'b00,
545                                             5'b0,
546                                             2'b01,
547                                             instr_i[4:2],
548                                             2'b01,
549                                             instr_i[9:7],
550                                             3'b000,
551                                             2'b01,
552                                             instr_i[9:7],
553                                             riscv::OpcodeOp32
554                                           };
555                                         end else begin
556        1/1                                illegal_instr_o = 1'b1;
557                                         end
558                                       end
559                     
560                                       3'b110: begin
561        1/1                              if (CVA6Cfg.RVZCB) begin
562                                           // c.mul -> mul rd', rd', rs2'
563        1/1                                instr_o = {
564                                             6'b0,
565                                             1'b1,
566                                             2'b01,
567                                             instr_i[4:2],
568                                             2'b01,
569                                             instr_i[9:7],
570                                             3'b000,
571                                             2'b01,
572                                             instr_i[9:7],
573                                             riscv::OpcodeOp
574                                           };
575                                         end else begin
576        unreachable                        instr_o = instr_i;
577        unreachable                        illegal_instr_o = 1'b1;
578                                         end
579                                       end
580                     
581                                       3'b111: begin
582        1/1                              if (CVA6Cfg.RVZCB) begin
583                     
584        1/1                                unique case (instr_i[4:2])
585                                             3'b000: begin
586                                               // c.zext.b -> andi rd', rd', 0xff
587        1/1                                    instr_o = {
588                                                 4'b0,
589                                                 8'hFF,
590                                                 2'b01,
591                                                 instr_i[9:7],
592                                                 3'b111,
593                                                 2'b01,
594                                                 instr_i[9:7],
595                                                 riscv::OpcodeOpImm
596                                               };
597                                             end
598                     
599                                             3'b001: begin
600        1/1                                    if (CVA6Cfg.RVB) begin
601                                                 // c.sext.b -> sext.b rd', rd'
602        1/1                                      instr_o = {
603                                                   7'h30,
604                                                   5'h4,
605                                                   2'b01,
606                                                   instr_i[9:7],
607                                                   3'b001,
608                                                   2'b01,
609                                                   instr_i[9:7],
610                                                   riscv::OpcodeOpImm
611                                                 };
612        unreachable                            end else illegal_instr_o = 1'b1;
613                                             end
614                     
615                                             3'b010: begin
616        1/1                                    if (CVA6Cfg.RVB) begin
617                                                 // c.zext.h -> zext.h rd', rd'
618        1/1                                      if (CVA6Cfg.IS_XLEN64) begin
619        unreachable                                instr_o = {
620                                                     7'h4,
621                                                     5'h0,
622                                                     2'b01,
623                                                     instr_i[9:7],
624                                                     3'b100,
625                                                     2'b01,
626                                                     instr_i[9:7],
627                                                     riscv::OpcodeOp32
628                                                   };
629                                                 end else begin
630        1/1                                        instr_o = {
631                                                     7'h4,
632                                                     5'h0,
633                                                     2'b01,
634                                                     instr_i[9:7],
635                                                     3'b100,
636                                                     2'b01,
637                                                     instr_i[9:7],
638                                                     riscv::OpcodeOp
639                                                   };
640                                                 end
641        unreachable                            end else illegal_instr_o = 1'b1;
642                                             end
643                     
644                                             3'b011: begin
645        1/1                                    if (CVA6Cfg.RVB) begin
646                                                 // c.sext.h -> sext.h rd', rd'
647        1/1                                      instr_o = {
648                                                   7'h30,
649                                                   5'h5,
650                                                   2'b01,
651                                                   instr_i[9:7],
652                                                   3'b001,
653                                                   2'b01,
654                                                   instr_i[9:7],
655                                                   riscv::OpcodeOpImm
656                                                 };
657        unreachable                            end else illegal_instr_o = 1'b1;
658                                             end
659                     
660                                             3'b100: begin
661        1/1                                    if (CVA6Cfg.RVB) begin
662                                                 // c.zext.w -> add.uw
663        1/1                                      if (CVA6Cfg.IS_XLEN64) begin
664        unreachable                                instr_o = {
665                                                     7'h4,
666                                                     5'h0,
667                                                     2'b01,
668                                                     instr_i[9:7],
669                                                     3'b000,
670                                                     2'b01,
671                                                     instr_i[9:7],
672                                                     riscv::OpcodeOp32
673                                                   };
674                                                 end else begin
675        1/1                                        illegal_instr_o = 1'b1;
676                                                 end
677        unreachable                            end else illegal_instr_o = 1'b1;
678                                             end
679                     
680                                             3'b101: begin
681                                               // c.not -> xori rd', rd', -1
682        1/1                                    instr_o = {
683                                                 12'hFFF,
684                                                 2'b01,
685                                                 instr_i[9:7],
686                                                 3'b100,
687                                                 2'b01,
688                                                 instr_i[9:7],
689                                                 riscv::OpcodeOpImm
690                                               };
691                                             end
692                     
693                                             default: begin
694        1/1                                    instr_o = instr_i;
695        1/1                                    illegal_instr_o = 1;
696                                             end
697                                           endcase
698                                         end
                   ==>  MISSING_ELSE
699                                       end
700                                     endcase
701                                   end
702                                 endcase
703                               end
704                     
705                               riscv::OpcodeC1J: begin
706                                 // 101: c.j   -> jal x0, imm
707        1/1                      instr_o = {
708                                   instr_i[12],
709                                   instr_i[8],
710                                   instr_i[10:9],
711                                   instr_i[6],
712                                   instr_i[7],
713                                   instr_i[2],
714                                   instr_i[11],
715                                   instr_i[5:3],
716                                   {9{instr_i[12]}},
717                                   4'b0,
718                                   ~instr_i[15],
719                                   riscv::OpcodeJal
720                                 };
721                               end
722                     
723                               riscv::OpcodeC1Beqz, riscv::OpcodeC1Bnez: begin
724                                 // 0: c.beqz -> beq rs1', x0, imm
725                                 // 1: c.bnez -> bne rs1', x0, imm
726        1/1                      instr_o = {
727                                   {4{instr_i[12]}},
728                                   instr_i[6:5],
729                                   instr_i[2],
730                                   5'b0,
731                                   2'b01,
732                                   instr_i[9:7],
733                                   2'b00,
734                                   instr_i[13],
735                                   instr_i[11:10],
736                                   instr_i[4:3],
737                                   instr_i[12],
738                                   riscv::OpcodeBranch
739                                 };
740                               end
741                             endcase
742                           end
743                     
744                           // C2
745                           riscv::OpcodeC2: begin
746        1/1                  unique case (instr_i[15:13])
747                               riscv::OpcodeC2Slli: begin
748                                 // c.slli -> slli rd, rd, shamt
749        1/1                      instr_o = {
750                                   6'b0,
751                                   instr_i[12],
752                                   instr_i[6:2],
753                                   instr_i[11:7],
754                                   3'b001,
755                                   instr_i[11:7],
756                                   riscv::OpcodeOpImm
757                                 };
758                               end
759                     
760                               riscv::OpcodeC2Fldsp: begin
761        1/1                      if (CVA6Cfg.FpPresent) begin
762                                   // c.fldsp -> fld rd, imm(x2)
763        unreachable                instr_o = {
764                                     3'b0,
765                                     instr_i[4:2],
766                                     instr_i[12],
767                                     instr_i[6:5],
768                                     3'b000,
769                                     5'h02,
770                                     3'b011,
771                                     instr_i[11:7],
772                                     riscv::OpcodeLoadFp
773                                   };
774                                 end else begin
775        1/1                        illegal_instr_o = 1'b1;
776                                 end
777                               end
778                     
779                               riscv::OpcodeC2Lwsp: begin
780                                 // c.lwsp -> lw rd, imm(x2)
781        1/1                      instr_o = {
782                                   4'b0,
783                                   instr_i[3:2],
784                                   instr_i[12],
785                                   instr_i[6:4],
786                                   2'b00,
787                                   5'h02,
788                                   3'b010,
789                                   instr_i[11:7],
790                                   riscv::OpcodeLoad
791                                 };
792        2/2                      if (instr_i[11:7] == 5'b0) illegal_instr_o = 1'b1;
                        MISSING_ELSE
793                               end
794                     
795                               riscv::OpcodeC2Ldsp: begin
796                                 // RV64
797                                 //   c.ldsp -> ld rd, imm(x2)
798                                 // RV32
799                                 //   c.flwsp -> flw fprd, imm(x2)
800        1/1                      if (CVA6Cfg.IS_XLEN64) begin
801        unreachable                instr_o = {
802                                     3'b0,
803                                     instr_i[4:2],
804                                     instr_i[12],
805                                     instr_i[6:5],
806                                     3'b000,
807                                     5'h02,
808                                     3'b011,
809                                     instr_i[11:7],
810                                     riscv::OpcodeLoad
811                                   };
812        unreachable                if (instr_i[11:7] == 5'b0) illegal_instr_o = 1'b1;
                   ==>  MISSING_ELSE
813                                 end else begin
814        1/1                        if (CVA6Cfg.FpPresent) begin
815        unreachable                  instr_o = {
816                                       4'b0,
817                                       instr_i[3:2],
818                                       instr_i[12],
819                                       instr_i[6:4],
820                                       2'b00,
821                                       5'h02,
822                                       3'b010,
823                                       instr_i[11:7],
824                                       riscv::OpcodeLoadFp
825                                     };
826                                   end else begin
827        1/1                          illegal_instr_o = 1'b1;
828                                   end
829                                 end
830                               end
831                     
832                               riscv::OpcodeC2JalrMvAdd: begin
833        1/1                      if (instr_i[12] == 1'b0) begin
834                                   // c.mv -> add rd/rs1, x0, rs2
835        1/1                        instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], riscv::OpcodeOp};
836                     
837        1/1                        if (instr_i[6:2] == 5'b0) begin
838                                     // c.jr -> jalr x0, rd/rs1, 0
839        1/1                          instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, riscv::OpcodeJalr};
840                                     // rs1 != 0
841        1/1                          illegal_instr_o = (instr_i[11:7] != '0) ? 1'b0 : 1'b1;
842                                   end
                        MISSING_ELSE
843                                 end else begin
844                                   // c.add -> add rd, rd, rs2
845        1/1                        instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], riscv::OpcodeOp};
846                     
847        1/1                        if (instr_i[6:2] == 5'b0) begin
848        1/1                          if (instr_i[11:7] == 5'b0) begin
849                                       // c.ebreak -> ebreak
850        1/1                            instr_o = {32'h00_10_00_73};
851                                     end else begin
852                                       // c.jalr -> jalr x1, rs1, 0
853        1/1                            instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, riscv::OpcodeJalr};
854                                     end
855                                   end
                        MISSING_ELSE
856                                 end
857                               end
858                     
859                               riscv::OpcodeC2Fsdsp: begin
860        1/1                      if (CVA6Cfg.FpPresent) begin
861                                   // c.fsdsp -> fsd rs2, imm(x2)
862        unreachable                instr_o = {
863                                     3'b0,
864                                     instr_i[9:7],
865                                     instr_i[12],
866                                     instr_i[6:2],
867                                     5'h02,
868                                     3'b011,
869                                     instr_i[11:10],
870                                     3'b000,
871                                     riscv::OpcodeStoreFp
872                                   };
873        1/1                      end else if (CVA6Cfg.RVZCMP && (instr_i[12:10] == 3'b110 || instr_i[12:10] == 3'b111 || instr_i[12:10] == 3'b011)) begin
874        unreachable                is_macro_instr_o = 1;
875        unreachable                instr_o = instr_i;
876        1/1                      end else if (CVA6Cfg.RVZCMT && (instr_i[12:10] == 3'b000))  //jt/jalt instruction
877        unreachable                is_zcmt_instr_o = 1'b1;
878        1/1                      else illegal_instr_o = 1'b1;
879                               end
880                               riscv::OpcodeC2Swsp: begin
881                                 // c.swsp -> sw rs2, imm(x2)
882        1/1                      instr_o = {
883                                   4'b0,
884                                   instr_i[8:7],
885                                   instr_i[12],
886                                   instr_i[6:2],
887                                   5'h02,
888                                   3'b010,
889                                   instr_i[11:9],
890                                   2'b00,
891                                   riscv::OpcodeStore
892                                 };
893                               end
894                     
895                               riscv::OpcodeC2Sdsp: begin
896                                 // RV64
897                                 //   c.sdsp -> sd rs2, imm(x2)
898                                 // RV32
899                                 //   c.fswsp -> fsw fprs2, imm(x2)
900        1/1                      if (CVA6Cfg.IS_XLEN64) begin
901        unreachable                instr_o = {
902                                     3'b0,
903                                     instr_i[9:7],
904                                     instr_i[12],
905                                     instr_i[6:2],
906                                     5'h02,
907                                     3'b011,
908                                     instr_i[11:10],
909                                     3'b000,
910                                     riscv::OpcodeStore
911                                   };
912                                 end else begin
913        1/1                        if (CVA6Cfg.FpPresent) begin
914        unreachable                  instr_o = {
915                                       4'b0,
916                                       instr_i[8:7],
917                                       instr_i[12],
918                                       instr_i[6:2],
919                                       5'h02,
920                                       3'b010,
921                                       instr_i[11:9],
922                                       2'b00,
923                                       riscv::OpcodeStoreFp
924                                     };
925                                   end else begin
926        1/1                          illegal_instr_o = 1'b1;
927                                   end
928                                 end
929                               end
930                     
931                               default: begin
932        0/1     ==>              illegal_instr_o = 1'b1;
933                               end
934                             endcase
935                           end
936                     
937                           // normal instruction
938        1/1                default: is_compressed_o = 1'b0;
939                         endcase
940                     
941                         // Check if the instruction was illegal, if it was then output the offending instruction (zero-extended)
942        1/1              if (illegal_instr_o) begin
943        1/1                instr_o = instr_i;
944                         end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : compressed_decoder

               Total   Covered  Percent
Conditions         20       20   100.00
Logical            20       20   100.00
Non-Logical         0        0
Event               0        0

 LINE       70
 EXPRESSION (instr_i[12:5] == 8'b0)
            -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       350
 EXPRESSION (instr_i[11:7] != 5'b0)
            -----------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       401
 EXPRESSION (instr_i[11:7] == 5'h02)
            ------------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       417
 EXPRESSION ({instr_i[12], instr_i[6:2]} == 6'b0)
            ------------------1------------------

-1- Status
 0  Covered
 1  Covered

 LINE       792
 EXPRESSION (instr_i[11:7] == 5'b0)
            -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       812
 EXPRESSION (instr_i[11:7] == 5'b0)
            -----------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       833
 EXPRESSION (instr_i[12] == 1'b0)
            ----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       837
 EXPRESSION (instr_i[6:2] == 5'b0)
            -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       841
 EXPRESSION ((instr_i[11:7] != '0) ? 1'b0 : 1'b1)
             ----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       841
 SUB-EXPRESSION (instr_i[11:7] != '0)
                ----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       847
 EXPRESSION (instr_i[6:2] == 5'b0)
            -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       848
 EXPRESSION (instr_i[11:7] == 5'b0)
            -----------1-----------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.id_stage_i.genblk1.genblk1[0].compressed_decoder_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 99.06  98.11 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.06  98.11 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME               
 99.06  98.11 100.00 --     compressed_decoder 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     id_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : decoder
===============================================================================
SCORE  LINE   COND   ASSERT 
 99.12  99.73  98.51 --     

Source File(s) : 

cva6/core/decoder.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                            
 99.12  99.73  98.51 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.id_stage_i.genblk2[0].decoder_i 



-------------------------------------------------------------------------------
Line Coverage for Module : decoder

             Line No.   Total   Covered  Percent
TOTAL                      376      375    99.73
ALWAYS            163      318      317    99.69
ALWAYS           1497       24       24   100.00
ALWAYS           1581       34       34   100.00

162                     
163        1/1              imm_select                             = NOIMM;
164        1/1              is_control_flow_instr_o                = 1'b0;
165        1/1              illegal_instr                          = 1'b0;
166        1/1              illegal_instr_non_bm                   = 1'b0;
167        1/1              illegal_instr_bm                       = 1'b0;
168        1/1              illegal_instr_zic                      = 1'b0;
169        1/1              virtual_illegal_instr                  = 1'b0;
170        1/1              instruction_o.pc                       = pc_i;
171        1/1              instruction_o.trans_id                 = '0;
172        1/1              instruction_o.fu                       = NONE;
173        1/1              instruction_o.op                       = ariane_pkg::ADD;
174        1/1              instruction_o.rs1                      = '0;
175        1/1              instruction_o.rs2                      = '0;
176        1/1              instruction_o.rd                       = '0;
177        1/1              instruction_o.use_pc                   = 1'b0;
178        1/1              instruction_o.is_compressed            = is_compressed_i;
179        1/1              instruction_o.is_macro_instr           = is_macro_instr_i;
180        1/1              instruction_o.is_last_macro_instr      = is_last_macro_instr_i;
181        1/1              instruction_o.is_double_rd_macro_instr = is_double_rd_macro_instr_i;
182        1/1              instruction_o.use_zimm                 = 1'b0;
183        1/1              instruction_o.bp                       = branch_predict_i;
184        1/1              instruction_o.vfp                      = 1'b0;
185        1/1              instruction_o.is_zcmt                  = is_zcmt_i;
186        1/1              ecall                                  = 1'b0;
187        1/1              ebreak                                 = 1'b0;
188        1/1              check_fprm                             = 1'b0;
189                     
190        1/1              if (~ex_i.valid) begin
191        1/1                case (instr.rtype.opcode)
192                             riscv::OpcodeSystem: begin
193        1/1                    instruction_o.fu = CSR;
194        1/1                    instruction_o.rs1 = instr.itype.rs1;
195        1/1                    instruction_o.rs2 = instr.rtype.rs2;   //IMPROVEMENT: needs to be checked if better way is available
196        1/1                    instruction_o.rd = instr.itype.rd;
197                     
198        1/1                    unique case (instr.itype.funct3)
199                                 3'b000: begin
200                                   // check if the RD and and RS1 fields are zero, this may be reset for the SENCE.VMA instruction
201        1/1                        if (instr.itype.rs1 != '0 || instr.itype.rd != '0) begin
202        1/1                          if (CVA6Cfg.RVH && v_i) begin
203        unreachable                    virtual_illegal_instr = 1'b1;
204                                     end else begin
205        1/1                            illegal_instr = 1'b1;
206                                     end
207                                   end
                        MISSING_ELSE
208                                   // decode the immiediate field
209        1/1                        case (instr.itype.imm)
210                                     // ECALL -> inject exception
211        1/1                          12'b0: ecall = 1'b1;
212                                     // EBREAK -> inject exception
213        1/1                          12'b1: ebreak = 1'b1;
214                                     // SRET
215                                     12'b1_0000_0010: begin
216        1/1                            if (CVA6Cfg.RVS) begin
217        unreachable                      instruction_o.op = ariane_pkg::SRET;
218                                         // check privilege level, SRET can only be executed in S and M mode
219                                         // we'll just decode an illegal instruction if we are in the wrong privilege level
220        unreachable                      if (CVA6Cfg.RVU && priv_lvl_i == riscv::PRIV_LVL_U) begin
221        unreachable                        if (CVA6Cfg.RVH && v_i) begin
222        unreachable                          virtual_illegal_instr = 1'b1;
223                                           end else begin
224        unreachable                          illegal_instr = 1'b1;
225                                           end
226                                           //  do not change privilege level if this is an illegal instruction
227        unreachable                        instruction_o.op = ariane_pkg::ADD;
228                                         end
                   ==>  MISSING_ELSE
229                                         // if we are in S-Mode and Trap SRET (tsr) is set -> trap on illegal instruction
230        unreachable                      if (priv_lvl_i == riscv::PRIV_LVL_S && tsr_i) begin
231        unreachable                        if (CVA6Cfg.RVH && v_i) begin
232        unreachable                          virtual_illegal_instr = 1'b1;
233                                           end else begin
234        unreachable                          illegal_instr = 1'b1;
235                                           end
236                                           //  do not change privilege level if this is an illegal instruction
237        unreachable                        instruction_o.op = ariane_pkg::ADD;
238                                         end
                   ==>  MISSING_ELSE
239                                       end else begin
240        1/1                              illegal_instr = 1'b1;
241        1/1                              instruction_o.op = ariane_pkg::ADD;
242                                       end
243                                     end
244                                     // MRET
245                                     12'b11_0000_0010: begin
246        1/1                            instruction_o.op = ariane_pkg::MRET;
247                                       // check privilege level, MRET can only be executed in M mode
248                                       // otherwise we decode an illegal instruction
249        1/1                            if ((CVA6Cfg.RVS && priv_lvl_i == riscv::PRIV_LVL_S) || (CVA6Cfg.RVU && priv_lvl_i == riscv::PRIV_LVL_U))
250        unreachable                      illegal_instr = 1'b1;
                        MISSING_ELSE
251                                     end
252                                     // DRET
253                                     12'b111_1011_0010: begin
254        1/1                            instruction_o.op = ariane_pkg::DRET;
255        1/1                            if (CVA6Cfg.DebugEn) begin
256                                         // check that we are in debug mode when executing this instruction
257        unreachable                      illegal_instr = (!debug_mode_i) ? 1'b1 : illegal_instr;
258                                       end else begin
259        1/1                              illegal_instr = 1'b1;
260                                       end
261                                     end
262                                     // WFI
263                                     12'b1_0000_0101: begin
264        1/1                            instruction_o.op = ariane_pkg::WFI;
265                                       // if timeout wait is set, trap on an illegal instruction in S Mode
266                                       // (after 0 cycles timeout)
267        1/1                            if (CVA6Cfg.RVS && priv_lvl_i == riscv::PRIV_LVL_S && tw_i) begin
268        unreachable                      illegal_instr = 1'b1;
269        unreachable                      instruction_o.op = ariane_pkg::ADD;
270                                       end
                        MISSING_ELSE
271        1/1                            if (CVA6Cfg.RVH && priv_lvl_i == riscv::PRIV_LVL_S && v_i && vtw_i && !tw_i) begin
272        unreachable                      virtual_illegal_instr = 1'b1;
273        unreachable                      instruction_o.op = ariane_pkg::ADD;
274                                       end
                        MISSING_ELSE
275                                       // we don't support U mode interrupts so WFI is illegal in this context
276        1/1                            if (CVA6Cfg.RVU && priv_lvl_i == riscv::PRIV_LVL_U) begin
277        unreachable                      if (CVA6Cfg.RVH && v_i) virtual_illegal_instr = 1'b1;
278        unreachable                      else illegal_instr = 1'b1;
279        unreachable                      instruction_o.op = ariane_pkg::ADD;
280                                       end
                        MISSING_ELSE
281                                     end
282                                     // SFENCE.VMA
283                                     default: begin
284        1/1                            if (instr.instr[31:25] == 7'b1001) begin
285                                         // check privilege level, SFENCE.VMA can only be executed in M/S mode
286                                         // only if S mode is supported
287                                         // otherwise decode an illegal instruction
288        1/1                              if (CVA6Cfg.RVH && v_i) begin
289        unreachable                        virtual_illegal_instr = (priv_lvl_i == riscv::PRIV_LVL_S) ? 1'b0 : 1'b1;
290                                         end else begin
291        1/1                                illegal_instr    = (CVA6Cfg.RVS && (priv_lvl_i inside {riscv::PRIV_LVL_M, riscv::PRIV_LVL_S}) && instr.itype.rd == '0) ? 1'b0 : 1'b1;
292                                         end
293        1/1                              instruction_o.op = ariane_pkg::SFENCE_VMA;
294                                         // check TVM flag and intercept SFENCE.VMA call if necessary
295        1/1                              if (CVA6Cfg.RVS && priv_lvl_i == riscv::PRIV_LVL_S && tvm_i) begin
296        unreachable                        if (CVA6Cfg.RVH && v_i) virtual_illegal_instr = 1'b1;
297        unreachable                        else illegal_instr = 1'b1;
298                                         end
                        MISSING_ELSE
299        1/1                            end else if (CVA6Cfg.RVH) begin
300        unreachable                      if (instr.instr[31:25] == 7'b10001) begin
301                                           // check privilege level, HFENCE.VVMA can only be executed in M/S mode
302                                           // otherwise decode an illegal instruction or virtual illegal instruction
303        unreachable                        if (v_i) begin
304        unreachable                          virtual_illegal_instr = 1'b1;
305                                           end else begin
306        unreachable                          illegal_instr    = (priv_lvl_i inside {riscv::PRIV_LVL_M, riscv::PRIV_LVL_S}) ? 1'b0 : 1'b1;
307                                           end
308        unreachable                        instruction_o.op = ariane_pkg::HFENCE_VVMA;
309        unreachable                      end else if (instr.instr[31:25] == 7'b110001) begin
310                                           // check privilege level, HFENCE.GVMA can only be executed in M/S mode
311                                           // otherwise decode an illegal instruction or virtual illegal instruction
312        unreachable                        if (v_i) begin
313        unreachable                          virtual_illegal_instr = 1'b1;
314                                           end else begin
315        unreachable                          illegal_instr    = (priv_lvl_i inside {riscv::PRIV_LVL_M, riscv::PRIV_LVL_S}) ? 1'b0 : 1'b1;
316                                           end
317        unreachable                        instruction_o.op = ariane_pkg::HFENCE_GVMA;
318                                           // check TVM flag and intercept HFENCE.GVMA call if necessary
319        unreachable                        if (priv_lvl_i == riscv::PRIV_LVL_S && !v_i && tvm_i) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
320                                         end else begin
321        unreachable                        illegal_instr = 1'b1;
322                                         end
323                                       end else begin
324        1/1                              illegal_instr = 1'b1;
325                                       end
326                                     end
327                                   endcase
328                                 end
329                                 3'b100: begin
330                                   // Hypervisor load/store instructions
331        1/1                        if (CVA6Cfg.RVH) begin
332        unreachable                  if (instr.instr[25] != 1'b0) begin
333        unreachable                    instruction_o.fu = STORE;
334        unreachable                    imm_select = NOIMM;
335        unreachable                    instruction_o.rs1 = instr.stype.rs1;
336        unreachable                    instruction_o.rs2 = instr.stype.rs2;
337                                     end else begin
338        unreachable                    instruction_o.fu = LOAD;
339        unreachable                    imm_select = NOIMM;
340        unreachable                    instruction_o.rs1 = instr.itype.rs1;
341        unreachable                    instruction_o.rd = instr.itype.rd;
342                                     end
343                     
344                                     // Hypervisor load/store instructions when V=1 cause virtual instruction
345        unreachable                  if (v_i) virtual_illegal_instr = 1'b1;
346                                     // Hypervisor load/store instructions in U-mode when hstatus.HU=0 cause an illegal instruction trap.
347        unreachable                  else if (!hu_i && priv_lvl_i == riscv::PRIV_LVL_U) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
348        unreachable                  unique case (instr.rtype.funct7)
349                                       7'b011_0000: begin
350        unreachable                      if (instr.rtype.rs2 == 5'b0) begin
351        unreachable                        instruction_o.op = ariane_pkg::HLV_B;
352                                         end
                   ==>  MISSING_ELSE
353        unreachable                      if (instr.rtype.rs2 == 5'b1) begin
354        unreachable                        instruction_o.op = ariane_pkg::HLV_BU;
355                                         end
                   ==>  MISSING_ELSE
356                                       end
357                                       7'b011_0010: begin
358        unreachable                      if (instr.rtype.rs2 == 5'b0) begin
359        unreachable                        instruction_o.op = ariane_pkg::HLV_H;
360                                         end
                   ==>  MISSING_ELSE
361        unreachable                      if (instr.rtype.rs2 == 5'b1) begin
362        unreachable                        instruction_o.op = ariane_pkg::HLV_HU;
363                                         end
                   ==>  MISSING_ELSE
364        unreachable                      if (instr.rtype.rs2 == 5'b11) begin
365        unreachable                        instruction_o.op = ariane_pkg::HLVX_HU;
366                                         end
                   ==>  MISSING_ELSE
367                                       end
368                                       7'b011_0100: begin
369        unreachable                      if (instr.rtype.rs2 == 5'b0) begin
370        unreachable                        instruction_o.op = ariane_pkg::HLV_W;
371                                         end
                   ==>  MISSING_ELSE
372        unreachable                      if (instr.rtype.rs2 == 5'b1) begin
373        unreachable                        instruction_o.op = ariane_pkg::HLV_WU;
374                                         end
                   ==>  MISSING_ELSE
375        unreachable                      if (instr.rtype.rs2 == 5'b11) begin
376        unreachable                        instruction_o.op = ariane_pkg::HLVX_WU;
377                                         end
                   ==>  MISSING_ELSE
378                                       end
379        unreachable                    7'b011_0001: instruction_o.op = ariane_pkg::HSV_B;
380        unreachable                    7'b011_0011: instruction_o.op = ariane_pkg::HSV_H;
381        unreachable                    7'b011_0101: instruction_o.op = ariane_pkg::HSV_W;
382        unreachable                    7'b011_0110: instruction_o.op = ariane_pkg::HLV_D;
383        unreachable                    7'b011_0111: instruction_o.op = ariane_pkg::HSV_D;
384        unreachable                    default: illegal_instr = 1'b1;
385                     
386                                     endcase
387        unreachable                  tinst = {
388                                       instr.rtype.funct7,
389                                       instr.rtype.rs2,
390                                       5'b0,
391                                       instr.rtype.funct3,
392                                       instr.rtype.rd,
393                                       instr.rtype.opcode
394                                     };
395                                   end else begin
396        1/1                          illegal_instr = 1'b1;
397                                   end
398                                 end
399                                 // atomically swaps values in the CSR and integer register
400                                 3'b001: begin  // CSRRW
401        1/1                        imm_select = IIMM;
402        1/1                        instruction_o.op = ariane_pkg::CSR_WRITE;
403                                 end
404                                 // atomically set values in the CSR and write back to rd
405                                 3'b010: begin  // CSRRS
406        1/1                        imm_select = IIMM;
407                                   // this is just a read
408        2/2                        if (instr.itype.rs1 == '0) instruction_o.op = ariane_pkg::CSR_READ;
409        1/1                        else instruction_o.op = ariane_pkg::CSR_SET;
410                                 end
411                                 // atomically clear values in the CSR and write back to rd
412                                 3'b011: begin  // CSRRC
413        1/1                        imm_select = IIMM;
414                                   // this is just a read
415        2/2                        if (instr.itype.rs1 == '0) instruction_o.op = ariane_pkg::CSR_READ;
416        1/1                        else instruction_o.op = ariane_pkg::CSR_CLEAR;
417                                 end
418                                 // use zimm and iimm
419                                 3'b101: begin  // CSRRWI
420        1/1                        instruction_o.rs1 = instr.itype.rs1;
421        1/1                        imm_select = IIMM;
422        1/1                        instruction_o.use_zimm = 1'b1;
423        1/1                        instruction_o.op = ariane_pkg::CSR_WRITE;
424                                 end
425                                 3'b110: begin  // CSRRSI
426        1/1                        instruction_o.rs1 = instr.itype.rs1;
427        1/1                        imm_select = IIMM;
428        1/1                        instruction_o.use_zimm = 1'b1;
429                                   // this is just a read
430        2/2                        if (instr.itype.rs1 == 5'b0) instruction_o.op = ariane_pkg::CSR_READ;
431        1/1                        else instruction_o.op = ariane_pkg::CSR_SET;
432                                 end
433                                 3'b111: begin  // CSRRCI
434        1/1                        instruction_o.rs1 = instr.itype.rs1;
435        1/1                        imm_select = IIMM;
436        1/1                        instruction_o.use_zimm = 1'b1;
437                                   // this is just a read
438        2/2                        if (instr.itype.rs1 == '0) instruction_o.op = ariane_pkg::CSR_READ;
439        1/1                        else instruction_o.op = ariane_pkg::CSR_CLEAR;
440                                 end
441        0/1     ==>              default: illegal_instr = 1'b1;
442                               endcase
443                             end
444                             // Memory ordering instructions
445                             riscv::OpcodeMiscMem: begin
446        1/1                    instruction_o.fu  = CSR;
447        1/1                    instruction_o.rs1 = '0;
448        1/1                    instruction_o.rs2 = '0;
449        1/1                    instruction_o.rd  = '0;
450                     
451        1/1                    case (instr.stype.funct3)
452                                 // FENCE
453                                 // Currently implemented as a whole DCache flush boldly ignoring other things
454        1/1                      3'b000:  instruction_o.op = ariane_pkg::FENCE;
455                                 // FENCE.I
456                                 3'b001:
457        1/1                      if (CVA6Cfg.RVZifencei) begin
458        unreachable                instruction_o.op = ariane_pkg::FENCE_I;
459                                 end else begin
460        1/1                        illegal_instr = 1'b1;
461                                 end
462        1/1                      default: illegal_instr = 1'b1;
463                               endcase
464                             end
465                     
466                             // --------------------------
467                             // Reg-Reg Operations
468                             // --------------------------
469                             riscv::OpcodeOp: begin
470                               // --------------------------------------------
471                               // Vectorial Floating-Point Reg-Reg Operations
472                               // --------------------------------------------
473        1/1                    if (instr.rvftype.funct2 == 2'b10) begin  // Prefix 10 for all Xfvec ops
474                                 // only generate decoder if FP extensions are enabled (static)
475        1/1                      if (CVA6Cfg.FpPresent && CVA6Cfg.XFVec && fs_i != riscv::Off && ((CVA6Cfg.RVH && (!v_i || vfs_i != riscv::Off)) || !CVA6Cfg.RVH)) begin
476                                   automatic logic allow_replication;  // control honoring of replication flag
477                     
478        unreachable                instruction_o.fu  = FPU_VEC;  // Same unit, but sets 'vectorial' signal
479        unreachable                instruction_o.rs1 = instr.rvftype.rs1;
480        unreachable                instruction_o.rs2 = instr.rvftype.rs2;
481        unreachable                instruction_o.rd  = instr.rvftype.rd;
482        unreachable                check_fprm        = 1'b1;
483        unreachable                allow_replication = 1'b1;
484                                   // decode vectorial FP instruction
485        unreachable                unique case (instr.rvftype.vecfltop)
486                                     5'b00001: begin
487        unreachable                    instruction_o.op  = ariane_pkg::FADD;  // vfadd.vfmt - Vectorial FP Addition
488        unreachable                    instruction_o.rs1 = '0;  // Operand A is set to 0
489        unreachable                    instruction_o.rs2 = instr.rvftype.rs1;  // Operand B is set to rs1
490        unreachable                    imm_select        = IIMM;  // Operand C is set to rs2
491                                     end
492                                     5'b00010: begin
493        unreachable                    instruction_o.op = ariane_pkg::FSUB;  // vfsub.vfmt - Vectorial FP Subtraction
494        unreachable                    instruction_o.rs1 = '0;  // Operand A is set to 0
495        unreachable                    instruction_o.rs2 = instr.rvftype.rs1;  // Operand B is set to rs1
496        unreachable                    imm_select = IIMM;  // Operand C is set to rs2
497                                     end
498                                     5'b00011:
499        unreachable                  instruction_o.op = ariane_pkg::FMUL;  // vfmul.vfmt - Vectorial FP Multiplication
500                                     5'b00100:
501        unreachable                  instruction_o.op = ariane_pkg::FDIV;  // vfdiv.vfmt - Vectorial FP Division
502                                     5'b00101: begin
503        unreachable                    instruction_o.op = ariane_pkg::VFMIN;  // vfmin.vfmt - Vectorial FP Minimum
504        unreachable                    check_fprm       = 1'b0;  // rounding mode irrelevant
505                                     end
506                                     5'b00110: begin
507        unreachable                    instruction_o.op = ariane_pkg::VFMAX;  // vfmax.vfmt - Vectorial FP Maximum
508        unreachable                    check_fprm       = 1'b0;  // rounding mode irrelevant
509                                     end
510                                     5'b00111: begin
511        unreachable                    instruction_o.op  = ariane_pkg::FSQRT;  // vfsqrt.vfmt - Vectorial FP Square Root
512        unreachable                    allow_replication = 1'b0;  // only one operand
513        unreachable                    if (instr.rvftype.rs2 != 5'b00000) illegal_instr = 1'b1;  // rs2 must be 0
                   ==>  MISSING_ELSE
514                                     end
515                                     5'b01000: begin
516        unreachable                    instruction_o.op = ariane_pkg::FMADD; // vfmac.vfmt - Vectorial FP Multiply-Accumulate
517        unreachable                    imm_select = SIMM;  // rd into result field (upper bits don't matter)
518                                     end
519                                     5'b01001: begin
520        unreachable                    instruction_o.op = ariane_pkg::FMSUB; // vfmre.vfmt - Vectorial FP Multiply-Reduce
521        unreachable                    imm_select = SIMM;  // rd into result field (upper bits don't matter)
522                                     end
523                                     5'b01100: begin
524        unreachable                    unique case (instr.rvftype.rs2) inside // operation encoded in rs2, `inside` for matching ?
525                                         5'b00000: begin
526        unreachable                        instruction_o.rs2 = instr.rvftype.rs1; // set rs2 = rs1 so we can map FMV to SGNJ in the unit
527        unreachable                        if (instr.rvftype.repl)
528        unreachable                          instruction_o.op = ariane_pkg::FMV_X2F;  // vfmv.vfmt.x - GPR to FPR Move
529        unreachable                        else instruction_o.op = ariane_pkg::FMV_F2X;  // vfmv.x.vfmt - FPR to GPR Move
530        unreachable                        check_fprm = 1'b0;  // no rounding for moves
531                                         end
532                                         5'b00001: begin
533        unreachable                        instruction_o.op  = ariane_pkg::FCLASS; // vfclass.vfmt - Vectorial FP Classify
534        unreachable                        check_fprm = 1'b0;  // no rounding for classification
535        unreachable                        allow_replication = 1'b0;  // R must not be set
536                                         end
537                                         5'b00010:
538        unreachable                      instruction_o.op = ariane_pkg::FCVT_F2I; // vfcvt.x.vfmt - Vectorial FP to Int Conversion
539                                         5'b00011:
540        unreachable                      instruction_o.op = ariane_pkg::FCVT_I2F; // vfcvt.vfmt.x - Vectorial Int to FP Conversion
541                                         5'b001??: begin
542        unreachable                        instruction_o.op       = ariane_pkg::FCVT_F2F; // vfcvt.vfmt.vfmt - Vectorial FP to FP Conversion
543        unreachable                        instruction_o.rs2 = instr.rvftype.rd; // set rs2 = rd as target vector for conversion
544        unreachable                        imm_select = IIMM;  // rs2 holds part of the intruction
545                                           // TODO CHECK R bit for valid fmt combinations
546                                           // determine source format
547        unreachable                        unique case (instr.rvftype.rs2[21:20])
548                                             // Only process instruction if corresponding extension is active (static)
549        unreachable                          2'b00:   if (~CVA6Cfg.RVFVec) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
550        unreachable                          2'b01:   if (~CVA6Cfg.XF16ALTVec) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
551        unreachable                          2'b10:   if (~CVA6Cfg.XF16Vec) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
552        unreachable                          2'b11:   if (~CVA6Cfg.XF8Vec) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
553        unreachable                          default: illegal_instr = 1'b1;
554                                           endcase
555                                         end
556        unreachable                      default: illegal_instr = 1'b1;
557                                       endcase
558                                     end
559                                     5'b01101: begin
560        unreachable                    check_fprm = 1'b0;  // no rounding for sign-injection
561        unreachable                    instruction_o.op = ariane_pkg::VFSGNJ; // vfsgnj.vfmt - Vectorial FP Sign Injection
562                                     end
563                                     5'b01110: begin
564        unreachable                    check_fprm = 1'b0;  // no rounding for sign-injection
565        unreachable                    instruction_o.op = ariane_pkg::VFSGNJN; // vfsgnjn.vfmt - Vectorial FP Negated Sign Injection
566                                     end
567                                     5'b01111: begin
568        unreachable                    check_fprm = 1'b0;  // no rounding for sign-injection
569        unreachable                    instruction_o.op = ariane_pkg::VFSGNJX; // vfsgnjx.vfmt - Vectorial FP XORed Sign Injection
570                                     end
571                                     5'b10000: begin
572        unreachable                    check_fprm       = 1'b0;  // no rounding for comparisons
573        unreachable                    instruction_o.op = ariane_pkg::VFEQ;  // vfeq.vfmt - Vectorial FP Equality
574                                     end
575                                     5'b10001: begin
576        unreachable                    check_fprm       = 1'b0;  // no rounding for comparisons
577        unreachable                    instruction_o.op = ariane_pkg::VFNE;  // vfne.vfmt - Vectorial FP Non-Equality
578                                     end
579                                     5'b10010: begin
580        unreachable                    check_fprm       = 1'b0;  // no rounding for comparisons
581        unreachable                    instruction_o.op = ariane_pkg::VFLT;  // vfle.vfmt - Vectorial FP Less Than
582                                     end
583                                     5'b10011: begin
584        unreachable                    check_fprm = 1'b0;  // no rounding for comparisons
585        unreachable                    instruction_o.op = ariane_pkg::VFGE;  // vfge.vfmt - Vectorial FP Greater or Equal
586                                     end
587                                     5'b10100: begin
588        unreachable                    check_fprm       = 1'b0;  // no rounding for comparisons
589        unreachable                    instruction_o.op = ariane_pkg::VFLE;  // vfle.vfmt - Vectorial FP Less or Equal
590                                     end
591                                     5'b10101: begin
592        unreachable                    check_fprm       = 1'b0;  // no rounding for comparisons
593        unreachable                    instruction_o.op = ariane_pkg::VFGT;  // vfgt.vfmt - Vectorial FP Greater Than
594                                     end
595                                     5'b11000: begin
596        unreachable                    instruction_o.op  = ariane_pkg::VFCPKAB_S; // vfcpka/b.vfmt.s - Vectorial FP Cast-and-Pack from 2x FP32, lowest 4 entries
597        unreachable                    imm_select = SIMM;  // rd into result field (upper bits don't matter)
598        unreachable                    if (~CVA6Cfg.RVF)
599        unreachable                      illegal_instr = 1'b1;  // if we don't support RVF, we can't cast from FP32
                   ==>  MISSING_ELSE
600                                       // check destination format
601        unreachable                    unique case (instr.rvftype.vfmt)
602                                         // Only process instruction if corresponding extension is active and FLEN suffices (static)
603                                         2'b00: begin
604        unreachable                        if (~CVA6Cfg.RVFVec)
605        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
606        unreachable                        if (instr.rvftype.repl)
607        unreachable                          illegal_instr = 1'b1;  // no entries 2/3 in vector of 2 fp32
                   ==>  MISSING_ELSE
608                                         end
609                                         2'b01: begin
610        unreachable                        if (~CVA6Cfg.XF16ALTVec)
611        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
612                                         end
613                                         2'b10: begin
614        unreachable                        if (~CVA6Cfg.XF16Vec)
615        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
616                                         end
617                                         2'b11: begin
618        unreachable                        if (~CVA6Cfg.XF8Vec)
619        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
620                                         end
621        unreachable                      default: illegal_instr = 1'b1;
622                                       endcase
623                                     end
624                                     5'b11001: begin
625        unreachable                    instruction_o.op  = ariane_pkg::VFCPKCD_S; // vfcpkc/d.vfmt.s - Vectorial FP Cast-and-Pack from 2x FP32, second 4 entries
626        unreachable                    imm_select = SIMM;  // rd into result field (upper bits don't matter)
627        unreachable                    if (~CVA6Cfg.RVF)
628        unreachable                      illegal_instr = 1'b1;  // if we don't support RVF, we can't cast from FP32
                   ==>  MISSING_ELSE
629                                       // check destination format
630        unreachable                    unique case (instr.rvftype.vfmt)
631                                         // Only process instruction if corresponding extension is active and FLEN suffices (static)
632        unreachable                      2'b00:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 2 FP32
633        unreachable                      2'b01:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 4 FP16ALT
634        unreachable                      2'b10:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 4 FP16
635                                         2'b11: begin
636        unreachable                        if (~CVA6Cfg.XF8Vec)
637        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
638                                         end
639        unreachable                      default: illegal_instr = 1'b1;
640                                       endcase
641                                     end
642                                     5'b11010: begin
643        unreachable                    instruction_o.op  = ariane_pkg::VFCPKAB_D; // vfcpka/b.vfmt.d - Vectorial FP Cast-and-Pack from 2x FP64, lowest 4 entries
644        unreachable                    imm_select = SIMM;  // rd into result field (upper bits don't matter)
645        unreachable                    if (~CVA6Cfg.RVD)
646        unreachable                      illegal_instr = 1'b1;  // if we don't support RVD, we can't cast from FP64
                   ==>  MISSING_ELSE
647                                       // check destination format
648        unreachable                    unique case (instr.rvftype.vfmt)
649                                         // Only process instruction if corresponding extension is active and FLEN suffices (static)
650                                         2'b00: begin
651        unreachable                        if (~CVA6Cfg.RVFVec)
652        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
653        unreachable                        if (instr.rvftype.repl)
654        unreachable                          illegal_instr = 1'b1;  // no entries 2/3 in vector of 2 fp32
                   ==>  MISSING_ELSE
655                                         end
656                                         2'b01: begin
657        unreachable                        if (~CVA6Cfg.XF16ALTVec)
658        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
659                                         end
660                                         2'b10: begin
661        unreachable                        if (~CVA6Cfg.XF16Vec)
662        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
663                                         end
664                                         2'b11: begin
665        unreachable                        if (~CVA6Cfg.XF8Vec)
666        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
667                                         end
668        unreachable                      default: illegal_instr = 1'b1;
669                                       endcase
670                                     end
671                                     5'b11011: begin
672        unreachable                    instruction_o.op  = ariane_pkg::VFCPKCD_D; // vfcpka/b.vfmt.d - Vectorial FP Cast-and-Pack from 2x FP64, second 4 entries
673        unreachable                    imm_select = SIMM;  // rd into result field (upper bits don't matter)
674        unreachable                    if (~CVA6Cfg.RVD)
675        unreachable                      illegal_instr = 1'b1;  // if we don't support RVD, we can't cast from FP64
                   ==>  MISSING_ELSE
676                                       // check destination format
677        unreachable                    unique case (instr.rvftype.vfmt)
678                                         // Only process instruction if corresponding extension is active and FLEN suffices (static)
679        unreachable                      2'b00:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 2 FP32
680        unreachable                      2'b01:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 4 FP16ALT
681        unreachable                      2'b10:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 4 FP16
682                                         2'b11: begin
683        unreachable                        if (~CVA6Cfg.XF8Vec)
684        unreachable                          illegal_instr = 1'b1;  // destination vector not supported
                   ==>  MISSING_ELSE
685                                         end
686        unreachable                      default: illegal_instr = 1'b1;
687                                       endcase
688                                     end
689        unreachable                  default: illegal_instr = 1'b1;
690                                   endcase
691                     
692                                   // check format
693        unreachable                unique case (instr.rvftype.vfmt)
694                                     // Only process instruction if corresponding extension is active (static)
695        unreachable                  2'b00:   if (~CVA6Cfg.RVFVec) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
696        unreachable                  2'b01:   if (~CVA6Cfg.XF16ALTVec) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
697        unreachable                  2'b10:   if (~CVA6Cfg.XF16Vec) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
698        unreachable                  2'b11:   if (~CVA6Cfg.XF8Vec) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
699        unreachable                  default: illegal_instr = 1'b1;
700                                   endcase
701                     
702                                   // check disallowed replication
703        unreachable                if (~allow_replication & instr.rvftype.repl) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
704                     
705                                   // check rounding mode
706        unreachable                if (check_fprm) begin
707        unreachable                  unique case (frm_i) inside  // actual rounding mode from frm csr
708        unreachable                    [3'b000 : 3'b100]: ;  //legal rounding modes
709        unreachable                    default: illegal_instr = 1'b1;
710                                     endcase
711                                   end
                   ==>  MISSING_ELSE
712                     
713                                 end else begin  // No vectorial FP enabled (static)
714        1/1                        illegal_instr = 1'b1;
715                                 end
716                     
717                                 // ---------------------------
718                                 // Integer Reg-Reg Operations
719                                 // ---------------------------
720                               end else begin
721        1/1                      if (CVA6Cfg.RVB) begin
722        1/1                        instruction_o.fu  = (instr.rtype.funct7 == 7'b000_0001 || ((instr.rtype.funct7 == 7'b000_0101) && !(instr.rtype.funct3[14]))) ? MULT : ALU;
723                                 end else begin
724        unreachable                instruction_o.fu = (instr.rtype.funct7 == 7'b000_0001) ? MULT : ALU;
725                                 end
726        1/1                      instruction_o.rs1 = instr.rtype.rs1;
727        1/1                      instruction_o.rs2 = instr.rtype.rs2;
728        1/1                      instruction_o.rd  = instr.rtype.rd;
729                     
730        1/1                      unique case ({
731                                   instr.rtype.funct7, instr.rtype.funct3
732                                 })
733        1/1                        {7'b000_0000, 3'b000} : instruction_o.op = ariane_pkg::ADD;  // Add
734        1/1                        {7'b010_0000, 3'b000} : instruction_o.op = ariane_pkg::SUB;  // Sub
735        1/1                        {7'b000_0000, 3'b010} : instruction_o.op = ariane_pkg::SLTS;  // Set Lower Than
736                                   {
737                                     7'b000_0000, 3'b011
738                                   } :
739        1/1                        instruction_o.op = ariane_pkg::SLTU;  // Set Lower Than Unsigned
740        1/1                        {7'b000_0000, 3'b100} : instruction_o.op = ariane_pkg::XORL;  // Xor
741        1/1                        {7'b000_0000, 3'b110} : instruction_o.op = ariane_pkg::ORL;  // Or
742        1/1                        {7'b000_0000, 3'b111} : instruction_o.op = ariane_pkg::ANDL;  // And
743        1/1                        {7'b000_0000, 3'b001} : instruction_o.op = ariane_pkg::SLL;  // Shift Left Logical
744        1/1                        {7'b000_0000, 3'b101} : instruction_o.op = ariane_pkg::SRL;  // Shift Right Logical
745        1/1                        {7'b010_0000, 3'b101} : instruction_o.op = ariane_pkg::SRA;  // Shift Right Arithmetic
746                                   // Multiplications
747        1/1                        {7'b000_0001, 3'b000} : instruction_o.op = ariane_pkg::MUL;
748        1/1                        {7'b000_0001, 3'b001} : instruction_o.op = ariane_pkg::MULH;
749        1/1                        {7'b000_0001, 3'b010} : instruction_o.op = ariane_pkg::MULHSU;
750        1/1                        {7'b000_0001, 3'b011} : instruction_o.op = ariane_pkg::MULHU;
751        1/1                        {7'b000_0001, 3'b100} : instruction_o.op = ariane_pkg::DIV;
752        1/1                        {7'b000_0001, 3'b101} : instruction_o.op = ariane_pkg::DIVU;
753        1/1                        {7'b000_0001, 3'b110} : instruction_o.op = ariane_pkg::REM;
754        1/1                        {7'b000_0001, 3'b111} : instruction_o.op = ariane_pkg::REMU;
755                                   default: begin
756        1/1                          illegal_instr_non_bm = 1'b1;
757                                   end
758                                 endcase
759        1/1                      if (CVA6Cfg.RVB) begin
760        1/1                        unique case ({
761                                     instr.rtype.funct7, instr.rtype.funct3
762                                   })
763                                     //Logical with Negate
764        1/1                          {7'b010_0000, 3'b111} : instruction_o.op = ariane_pkg::ANDN;  // Andn
765        1/1                          {7'b010_0000, 3'b110} : instruction_o.op = ariane_pkg::ORN;  // Orn
766        1/1                          {7'b010_0000, 3'b100} : instruction_o.op = ariane_pkg::XNOR;  // Xnor
767                                     //Shift and Add (Bitmanip)
768        1/1                          {7'b001_0000, 3'b010} : instruction_o.op = ariane_pkg::SH1ADD;  // Sh1add
769        1/1                          {7'b001_0000, 3'b100} : instruction_o.op = ariane_pkg::SH2ADD;  // Sh2add
770        1/1                          {7'b001_0000, 3'b110} : instruction_o.op = ariane_pkg::SH3ADD;  // Sh3add
771                                     // Integer maximum/minimum
772        1/1                          {7'b000_0101, 3'b110} : instruction_o.op = ariane_pkg::MAX;  // max
773        1/1                          {7'b000_0101, 3'b111} : instruction_o.op = ariane_pkg::MAXU;  // maxu
774        1/1                          {7'b000_0101, 3'b100} : instruction_o.op = ariane_pkg::MIN;  // min
775        1/1                          {7'b000_0101, 3'b101} : instruction_o.op = ariane_pkg::MINU;  // minu
776                                     // Single bit instructions
777        1/1                          {7'b010_0100, 3'b001} : instruction_o.op = ariane_pkg::BCLR;  // bclr
778        1/1                          {7'b010_0100, 3'b101} : instruction_o.op = ariane_pkg::BEXT;  // bext
779        1/1                          {7'b011_0100, 3'b001} : instruction_o.op = ariane_pkg::BINV;  // binv
780        1/1                          {7'b001_0100, 3'b001} : instruction_o.op = ariane_pkg::BSET;  // bset
781                                     // Carry-Less-Multiplication (clmul, clmulh, clmulr)
782        1/1                          {7'b000_0101, 3'b001} : instruction_o.op = ariane_pkg::CLMUL;  // clmul
783        1/1                          {7'b000_0101, 3'b011} : instruction_o.op = ariane_pkg::CLMULH;  // clmulh
784        1/1                          {7'b000_0101, 3'b010} : instruction_o.op = ariane_pkg::CLMULR;  // clmulr
785                                     // Bitwise Shifting
786        1/1                          {7'b011_0000, 3'b001} : instruction_o.op = ariane_pkg::ROL;  // rol
787        1/1                          {7'b011_0000, 3'b101} : instruction_o.op = ariane_pkg::ROR;  // ror
788                                     {
789                                       7'b000_0100, 3'b111
790                                     } : begin
791        1/1(1 unreachable)                    if (CVA6Cfg.ZKN) instruction_o.op = ariane_pkg::PACK_H;  //packh
792        1/1                            else illegal_instr_bm = 1'b1;
793                                     end
794                                     // Zero Extend Op RV32 encoding
795                                     {
796                                       7'b000_0100, 3'b100
797                                     } : begin
798        1/1                            if (!CVA6Cfg.IS_XLEN64 && instr.instr[24:20] == 5'b00000)
799        1/1                              instruction_o.op = ariane_pkg::ZEXTH;  // Zero Extend Op RV32 encoding
800        1/1(1 unreachable)                    else if (CVA6Cfg.ZKN) instruction_o.op = ariane_pkg::PACK;  // pack
801        1/1                            else illegal_instr_bm = 1'b1;
802                                     end
803                                     default: begin
804        1/1                            illegal_instr_bm = 1'b1;
805                                     end
806                                   endcase
807                                 end
                   ==>  MISSING_ELSE
808        1/1                      if (CVA6Cfg.RVZiCond) begin
809        unreachable                unique case ({
810                                     instr.rtype.funct7, instr.rtype.funct3
811                                   })
812                                     //Conditional move
813        unreachable                  {7'b000_0111, 3'b101} : instruction_o.op = ariane_pkg::CZERO_EQZ;  // czero.eqz
814        unreachable                  {7'b000_0111, 3'b111} : instruction_o.op = ariane_pkg::CZERO_NEZ;  // czero.nez
815                                     default: begin
816        unreachable                    illegal_instr_zic = 1'b1;
817                                     end
818                                   endcase
819                                 end
                        MISSING_ELSE
820                                 //VCS coverage on
821        1/1                      unique case ({
822                                   CVA6Cfg.RVB, CVA6Cfg.RVZiCond
823                                 })
824        unreachable                2'b00:   illegal_instr = illegal_instr_non_bm;
825        unreachable                2'b01:   illegal_instr = illegal_instr_non_bm & illegal_instr_zic;
826        1/1                        2'b10:   illegal_instr = illegal_instr_non_bm & illegal_instr_bm;
827        unreachable                2'b11:   illegal_instr = illegal_instr_non_bm & illegal_instr_bm & illegal_instr_zic;
828        unreachable                default: ;
829                                 endcase
830                               end
831                             end
832                     
833                             // --------------------------
834                             // 32bit Reg-Reg Operations
835                             // --------------------------
836                             riscv::OpcodeOp32: begin
837        1/1                    instruction_o.fu  = (instr.rtype.funct7 == 7'b000_0001) ? MULT : ALU;
838        1/1                    instruction_o.rs1 = instr.rtype.rs1;
839        1/1                    instruction_o.rs2 = instr.rtype.rs2;
840        1/1                    instruction_o.rd  = instr.rtype.rd;
841        1/1                    if (CVA6Cfg.IS_XLEN64) begin
842        unreachable              unique case ({
843                                   instr.rtype.funct7, instr.rtype.funct3
844                                 })
845        unreachable                {7'b000_0000, 3'b000} : instruction_o.op = ariane_pkg::ADDW;  // addw
846        unreachable                {7'b010_0000, 3'b000} : instruction_o.op = ariane_pkg::SUBW;  // subw
847        unreachable                {7'b000_0000, 3'b001} : instruction_o.op = ariane_pkg::SLLW;  // sllw
848        unreachable                {7'b000_0000, 3'b101} : instruction_o.op = ariane_pkg::SRLW;  // srlw
849        unreachable                {7'b010_0000, 3'b101} : instruction_o.op = ariane_pkg::SRAW;  // sraw
850                                   // Multiplications
851        unreachable                {7'b000_0001, 3'b000} : instruction_o.op = ariane_pkg::MULW;
852        unreachable                {7'b000_0001, 3'b100} : instruction_o.op = ariane_pkg::DIVW;
853        unreachable                {7'b000_0001, 3'b101} : instruction_o.op = ariane_pkg::DIVUW;
854        unreachable                {7'b000_0001, 3'b110} : instruction_o.op = ariane_pkg::REMW;
855        unreachable                {7'b000_0001, 3'b111} : instruction_o.op = ariane_pkg::REMUW;
856        unreachable                default: illegal_instr_non_bm = 1'b1;
857                                 endcase
858        unreachable              if (CVA6Cfg.RVB) begin
859        unreachable                unique case ({
860                                     instr.rtype.funct7, instr.rtype.funct3
861                                   })
862                                     // Shift with Add (Unsigned Word)
863        unreachable                  {7'b001_0000, 3'b010} : instruction_o.op = ariane_pkg::SH1ADDUW;  // sh1add.uw
864        unreachable                  {7'b001_0000, 3'b100} : instruction_o.op = ariane_pkg::SH2ADDUW;  // sh2add.uw
865        unreachable                  {7'b001_0000, 3'b110} : instruction_o.op = ariane_pkg::SH3ADDUW;  // sh3add.uw
866                                     // Unsigned word Op's
867        unreachable                  {7'b000_0100, 3'b000} : instruction_o.op = ariane_pkg::ADDUW;  // add.uw
868                                     // Bitwise Shifting
869        unreachable                  {7'b011_0000, 3'b001} : instruction_o.op = ariane_pkg::ROLW;  // rolw
870        unreachable                  {7'b011_0000, 3'b101} : instruction_o.op = ariane_pkg::RORW;  // rorw
871                                     {
872                                       7'b000_0100, 3'b100
873                                     } : begin
874        unreachable                    if (instr.instr[24:20] == 5'b00000)
875        unreachable                      instruction_o.op = ariane_pkg::ZEXTH;  // Zero Extend Op RV64 encoding
876        unreachable                    else if (CVA6Cfg.ZKN) instruction_o.op = ariane_pkg::PACK_W;  // packw
877        unreachable                    else illegal_instr_bm = 1'b1;
878                                     end
879        unreachable                  default: illegal_instr_bm = 1'b1;
880                                   endcase
881        unreachable                illegal_instr = illegal_instr_non_bm & illegal_instr_bm;
882                                 end else begin
883        unreachable                illegal_instr = illegal_instr_non_bm;
884                                 end
885        1/1                    end else illegal_instr = 1'b1;
886                             end
887                             // --------------------------------
888                             // Reg-Immediate Operations
889                             // --------------------------------
890                             riscv::OpcodeOpImm: begin
891        1/1                    instruction_o.fu = ALU;
892        1/1                    imm_select = IIMM;
893        1/1                    instruction_o.rs1 = instr.itype.rs1;
894        1/1                    instruction_o.rd = instr.itype.rd;
895        1/1                    unique case (instr.itype.funct3)
896        1/1                      3'b000: instruction_o.op = ariane_pkg::ADD;  // Add Immediate
897        1/1                      3'b010: instruction_o.op = ariane_pkg::SLTS;  // Set to one if Lower Than Immediate
898                                 3'b011:
899        1/1                      instruction_o.op = ariane_pkg::SLTU;  // Set to one if Lower Than Immediate Unsigned
900        1/1                      3'b100: instruction_o.op = ariane_pkg::XORL;  // Exclusive Or with Immediate
901        1/1                      3'b110: instruction_o.op = ariane_pkg::ORL;  // Or with Immediate
902        1/1                      3'b111: instruction_o.op = ariane_pkg::ANDL;  // And with Immediate
903                     
904                                 3'b001: begin
905        1/1                        instruction_o.op = ariane_pkg::SLL;  // Shift Left Logical by Immediate
906        2/2                        if (instr.instr[31:26] != 6'b0) illegal_instr_non_bm = 1'b1;
                        MISSING_ELSE
907        2/2                        if (instr.instr[25] != 1'b0 && CVA6Cfg.XLEN == 32) illegal_instr_non_bm = 1'b1;
                        MISSING_ELSE
908                                 end
909                     
910                                 3'b101: begin
911        1/1                        if (instr.instr[31:26] == 6'b0)
912        1/1                          instruction_o.op = ariane_pkg::SRL;  // Shift Right Logical by Immediate
913        1/1                        else if (instr.instr[31:26] == 6'b010_000)
914        1/1                          instruction_o.op = ariane_pkg::SRA;  // Shift Right Arithmetically by Immediate
915        1/1                        else illegal_instr_non_bm = 1'b1;
916        2/2                        if (instr.instr[25] != 1'b0 && CVA6Cfg.XLEN == 32) illegal_instr_non_bm = 1'b1;
                        MISSING_ELSE
917                                 end
918                               endcase
919        1/1                    if (CVA6Cfg.RVB) begin
920        1/1                      unique case (instr.itype.funct3)
921                                   3'b001: begin
922        1/1                          if (instr.instr[31:25] == 7'b0110000) begin
923        2/2                            if (instr.instr[24:20] == 5'b00100) instruction_o.op = ariane_pkg::SEXTB;
924        2/2                            else if (instr.instr[24:20] == 5'b00101) instruction_o.op = ariane_pkg::SEXTH;
925        2/2                            else if (instr.instr[24:20] == 5'b00010) instruction_o.op = ariane_pkg::CPOP;
926        2/2                            else if (instr.instr[24:20] == 5'b00000) instruction_o.op = ariane_pkg::CLZ;
927        2/2                            else if (instr.instr[24:20] == 5'b00001) instruction_o.op = ariane_pkg::CTZ;
928        1/1                            else illegal_instr_bm = 1'b1;
929        1/1                          end else if (CVA6Cfg.IS_XLEN64 && instr.instr[31:26] == 6'b010010)
930        unreachable                    instruction_o.op = ariane_pkg::BCLRI;
931        1/1                          else if (CVA6Cfg.IS_XLEN32 && instr.instr[31:25] == 7'b0100100)
932        1/1                            instruction_o.op = ariane_pkg::BCLRI;
933        1/1                          else if (CVA6Cfg.IS_XLEN64 && instr.instr[31:26] == 6'b011010)
934        unreachable                    instruction_o.op = ariane_pkg::BINVI;
935        1/1                          else if (CVA6Cfg.IS_XLEN32 && instr.instr[31:25] == 7'b0110100)
936        1/1                            instruction_o.op = ariane_pkg::BINVI;
937        1/1                          else if (CVA6Cfg.IS_XLEN64 && instr.instr[31:26] == 6'b001010)
938        unreachable                    instruction_o.op = ariane_pkg::BSETI;
939        1/1                          else if (CVA6Cfg.IS_XLEN32 && instr.instr[31:25] == 7'b0010100)
940        1/1                            instruction_o.op = ariane_pkg::BSETI;
941        1/1                          else if (CVA6Cfg.ZKN && instr.instr[31:20] == 12'b000010001111)
942        unreachable                    instruction_o.op = ariane_pkg::ZIP;
943        1/1                          else illegal_instr_bm = 1'b1;
944                                   end
945                                   3'b101: begin
946        2/2                          if (instr.instr[31:20] == 12'b001010000111) instruction_o.op = ariane_pkg::ORCB;
947        1/1                          else if (CVA6Cfg.IS_XLEN64 && instr.instr[31:20] == 12'b011010111000)
948        unreachable                    instruction_o.op = ariane_pkg::REV8;
949        1/1                          else if (instr.instr[31:20] == 12'b011010011000)
950        1/1                            instruction_o.op = ariane_pkg::REV8;
951        1/1                          else if (CVA6Cfg.IS_XLEN64 && instr.instr[31:26] == 6'b010_010)
952        unreachable                    instruction_o.op = ariane_pkg::BEXTI;
953        1/1                          else if (CVA6Cfg.IS_XLEN32 && instr.instr[31:25] == 7'b010_0100)
954        1/1                            instruction_o.op = ariane_pkg::BEXTI;
955        1/1                          else if (CVA6Cfg.IS_XLEN64 && instr.instr[31:26] == 6'b011_000)
956        unreachable                    instruction_o.op = ariane_pkg::RORI;
957        1/1                          else if (CVA6Cfg.IS_XLEN32 && instr.instr[31:25] == 7'b011_0000)
958        1/1                            instruction_o.op = ariane_pkg::RORI;
959        1/1                          else if (CVA6Cfg.ZKN && instr.instr[31:20] == 12'b011010000111)
960        unreachable                    instruction_o.op = ariane_pkg::BREV8;
961        1/1                          else if (CVA6Cfg.ZKN && instr.instr[31:20] == 12'b000010001111)
962        unreachable                    instruction_o.op = ariane_pkg::UNZIP;
963        1/1                          else illegal_instr_bm = 1'b1;
964                                   end
965        1/1                        default: illegal_instr_bm = 1'b1;
966                                 endcase
967        1/1                      illegal_instr = illegal_instr_non_bm & illegal_instr_bm;
968                               end else begin
969        unreachable              illegal_instr = illegal_instr_non_bm;
970                               end
971                             end
972                     
973                             // --------------------------------
974                             // 32 bit Reg-Immediate Operations
975                             // --------------------------------
976                             riscv::OpcodeOpImm32: begin
977        1/1                    instruction_o.fu = ALU;
978        1/1                    imm_select = IIMM;
979        1/1                    instruction_o.rs1 = instr.itype.rs1;
980        1/1                    instruction_o.rd = instr.itype.rd;
981        1/1                    if (CVA6Cfg.IS_XLEN64) begin
982        unreachable              unique case (instr.itype.funct3)
983        unreachable                3'b000:  instruction_o.op = ariane_pkg::ADDW;  // Add Immediate
984                                   3'b001: begin
985        unreachable                  instruction_o.op = ariane_pkg::SLLW;  // Shift Left Logical by Immediate
986        unreachable                  if (instr.instr[31:25] != 7'b0) illegal_instr_non_bm = 1'b1;
                   ==>  MISSING_ELSE
987                                   end
988                                   3'b101: begin
989        unreachable                  if (instr.instr[31:25] == 7'b0)
990        unreachable                    instruction_o.op = ariane_pkg::SRLW;  // Shift Right Logical by Immediate
991        unreachable                  else if (instr.instr[31:25] == 7'b010_0000)
992        unreachable                    instruction_o.op = ariane_pkg::SRAW;  // Shift Right Arithmetically by Immediate
993        unreachable                  else illegal_instr_non_bm = 1'b1;
994                                   end
995        unreachable                default: illegal_instr_non_bm = 1'b1;
996                                 endcase
997        unreachable              if (CVA6Cfg.RVB) begin
998        unreachable                unique case (instr.itype.funct3)
999                                     3'b001: begin
1000       unreachable                    if (instr.instr[31:25] == 7'b0110000) begin
1001       unreachable                      if (instr.instr[21:20] == 2'b10) instruction_o.op = ariane_pkg::CPOPW;
1002       unreachable                      else if (instr.instr[21:20] == 2'b00) instruction_o.op = ariane_pkg::CLZW;
1003       unreachable                      else if (instr.instr[21:20] == 2'b01) instruction_o.op = ariane_pkg::CTZW;
1004       unreachable                      else illegal_instr_bm = 1'b1;
1005       unreachable                    end else if (instr.instr[31:26] == 6'b000010) begin
1006       unreachable                      instruction_o.op = ariane_pkg::SLLIUW; // Shift Left Logic by Immediate (Unsigned Word)
1007       unreachable                    end else illegal_instr_bm = 1'b1;
1008                                    end
1009                                    3'b101: begin
1010       unreachable                    if (instr.instr[31:25] == 7'b011_0000) instruction_o.op = ariane_pkg::RORIW;
1011       unreachable                    else illegal_instr_bm = 1'b1;
1012                                    end
1013       unreachable                  default: illegal_instr_bm = 1'b1;
1014                                  endcase
1015       unreachable                illegal_instr = illegal_instr_non_bm & illegal_instr_bm;
1016                                end else begin
1017       unreachable                illegal_instr = illegal_instr_non_bm;
1018                                end
1019                    
1020       1/1                    end else illegal_instr = 1'b1;
1021                            end
1022                            // --------------------------------
1023                            // LSU
1024                            // --------------------------------
1025                            riscv::OpcodeStore: begin
1026       1/1                    instruction_o.fu = STORE;
1027       1/1                    imm_select = SIMM;
1028       1/1                    instruction_o.rs1 = instr.stype.rs1;
1029       1/1                    instruction_o.rs2 = instr.stype.rs2;
1030                              // determine store size
1031       1/1                    unique case (instr.stype.funct3)
1032       1/1                      3'b000: instruction_o.op = ariane_pkg::SB;
1033       1/1                      3'b001: instruction_o.op = ariane_pkg::SH;
1034       1/1                      3'b010: instruction_o.op = ariane_pkg::SW;
1035                                3'b011:
1036       1/1(1 unreachable)              if (CVA6Cfg.XLEN == 64) instruction_o.op = ariane_pkg::SD;
1037       1/1                      else illegal_instr = 1'b1;
1038       1/1                      default: illegal_instr = 1'b1;
1039                              endcase
1040       1/1                    if (CVA6Cfg.RVH) begin
1041       unreachable              tinst = {7'b0, instr.stype.rs2, 5'b0, instr.stype.funct3, 5'b0, instr.stype.opcode};
1042       unreachable              tinst[1] = is_compressed_i ? 1'b0 : 'b1;
1043                              end
                        MISSING_ELSE
1044                            end
1045                    
1046                            riscv::OpcodeLoad: begin
1047       1/1                    instruction_o.fu = LOAD;
1048       1/1                    imm_select = IIMM;
1049       1/1                    instruction_o.rs1 = instr.itype.rs1;
1050       1/1                    instruction_o.rd = instr.itype.rd;
1051                              // determine load size and signed type
1052       1/1                    unique case (instr.itype.funct3)
1053       1/1                      3'b000: instruction_o.op = ariane_pkg::LB;
1054       1/1                      3'b001: instruction_o.op = ariane_pkg::LH;
1055       1/1                      3'b010: instruction_o.op = ariane_pkg::LW;
1056       1/1                      3'b100: instruction_o.op = ariane_pkg::LBU;
1057       1/1                      3'b101: instruction_o.op = ariane_pkg::LHU;
1058                                3'b110:
1059       1/1(1 unreachable)              if (CVA6Cfg.XLEN == 64) instruction_o.op = ariane_pkg::LWU;
1060       1/1                      else illegal_instr = 1'b1;
1061                                3'b011:
1062       1/1(1 unreachable)              if (CVA6Cfg.XLEN == 64) instruction_o.op = ariane_pkg::LD;
1063       1/1                      else illegal_instr = 1'b1;
1064       1/1                      default: illegal_instr = 1'b1;
1065                              endcase
1066       1/1                    if (CVA6Cfg.RVH) begin
1067       unreachable              tinst = {17'b0, instr.itype.funct3, instr.itype.rd, instr.itype.opcode};
1068       unreachable              tinst[1] = is_compressed_i ? 1'b0 : 'b1;
1069                              end
                        MISSING_ELSE
1070                            end
1071                    
1072                            // --------------------------------
1073                            // Floating-Point Load/store
1074                            // --------------------------------
1075                            riscv::OpcodeStoreFp: begin
1076       1/1                    if (CVA6Cfg.FpPresent && fs_i != riscv::Off && ((CVA6Cfg.RVH && (!v_i || vfs_i != riscv::Off)) || !CVA6Cfg.RVH)) begin // only generate decoder if FP extensions are enabled (static)
1077       unreachable              instruction_o.fu = STORE;
1078       unreachable              imm_select = SIMM;
1079       unreachable              instruction_o.rs1 = instr.stype.rs1;
1080       unreachable              instruction_o.rs2 = instr.stype.rs2;
1081                                // determine store size
1082       unreachable              unique case (instr.stype.funct3)
1083                                  // Only process instruction if corresponding extension is active (static)
1084                                  3'b000:
1085       unreachable                if (CVA6Cfg.XF8) instruction_o.op = ariane_pkg::FSB;
1086       unreachable                else illegal_instr = 1'b1;
1087                                  3'b001:
1088       unreachable                if (CVA6Cfg.XF16 | CVA6Cfg.XF16ALT) instruction_o.op = ariane_pkg::FSH;
1089       unreachable                else illegal_instr = 1'b1;
1090                                  3'b010:
1091       unreachable                if (CVA6Cfg.RVF) instruction_o.op = ariane_pkg::FSW;
1092       unreachable                else illegal_instr = 1'b1;
1093                                  3'b011:
1094       unreachable                if (CVA6Cfg.RVD) instruction_o.op = ariane_pkg::FSD;
1095       unreachable                else illegal_instr = 1'b1;
1096       unreachable                default: illegal_instr = 1'b1;
1097                                endcase
1098       unreachable              if (CVA6Cfg.RVH) begin
1099       unreachable                tinst = {7'b0, instr.stype.rs2, 5'b0, instr.stype.funct3, 5'b0, instr.stype.opcode};
1100       unreachable                tinst[1] = is_compressed_i ? 1'b0 : 'b1;
1101                                end
                   ==>  MISSING_ELSE
1102       1/1                    end else illegal_instr = 1'b1;
1103                            end
1104                    
1105                            riscv::OpcodeLoadFp: begin
1106       1/1                    if (CVA6Cfg.FpPresent && fs_i != riscv::Off && ((CVA6Cfg.RVH && (!v_i || vfs_i != riscv::Off)) || !CVA6Cfg.RVH)) begin // only generate decoder if FP extensions are enabled (static)
1107       unreachable              instruction_o.fu = LOAD;
1108       unreachable              imm_select = IIMM;
1109       unreachable              instruction_o.rs1 = instr.itype.rs1;
1110       unreachable              instruction_o.rd = instr.itype.rd;
1111                                // determine load size
1112       unreachable              unique case (instr.itype.funct3)
1113                                  // Only process instruction if corresponding extension is active (static)
1114                                  3'b000:
1115       unreachable                if (CVA6Cfg.XF8) instruction_o.op = ariane_pkg::FLB;
1116       unreachable                else illegal_instr = 1'b1;
1117                                  3'b001:
1118       unreachable                if (CVA6Cfg.XF16 | CVA6Cfg.XF16ALT) instruction_o.op = ariane_pkg::FLH;
1119       unreachable                else illegal_instr = 1'b1;
1120                                  3'b010:
1121       unreachable                if (CVA6Cfg.RVF) instruction_o.op = ariane_pkg::FLW;
1122       unreachable                else illegal_instr = 1'b1;
1123                                  3'b011:
1124       unreachable                if (CVA6Cfg.RVD) instruction_o.op = ariane_pkg::FLD;
1125       unreachable                else illegal_instr = 1'b1;
1126       unreachable                default: illegal_instr = 1'b1;
1127                                endcase
1128       unreachable              if (CVA6Cfg.RVH) begin
1129       unreachable                tinst = {17'b0, instr.itype.funct3, instr.itype.rd, instr.itype.opcode};
1130       unreachable                tinst[1] = is_compressed_i ? 1'b0 : 'b1;
1131                                end
                   ==>  MISSING_ELSE
1132       1/1                    end else illegal_instr = 1'b1;
1133                            end
1134                    
1135                            // ----------------------------------
1136                            // Floating-Point Reg-Reg Operations
1137                            // ----------------------------------
1138                            riscv::OpcodeMadd, riscv::OpcodeMsub, riscv::OpcodeNmsub, riscv::OpcodeNmadd: begin
1139       1/1                    if (CVA6Cfg.FpPresent && fs_i != riscv::Off && ((CVA6Cfg.RVH && (!v_i || vfs_i != riscv::Off)) || !CVA6Cfg.RVH)) begin // only generate decoder if FP extensions are enabled (static)
1140       unreachable              instruction_o.fu  = FPU;
1141       unreachable              instruction_o.rs1 = instr.r4type.rs1;
1142       unreachable              instruction_o.rs2 = instr.r4type.rs2;
1143       unreachable              instruction_o.rd  = instr.r4type.rd;
1144       unreachable              imm_select        = RS3;  // rs3 into result field
1145       unreachable              check_fprm        = 1'b1;
1146                                // select the correct fused operation
1147       unreachable              unique case (instr.r4type.opcode)
1148                                  default: instruction_o.op = ariane_pkg::FMADD;  // fmadd.fmt - FP Fused multiply-add
1149                                  riscv::OpcodeMsub:
1150       unreachable                instruction_o.op = ariane_pkg::FMSUB;  // fmsub.fmt - FP Fused multiply-subtract
1151                                  riscv::OpcodeNmsub:
1152       unreachable                instruction_o.op = ariane_pkg::FNMSUB; // fnmsub.fmt - FP Negated fused multiply-subtract
1153                                  riscv::OpcodeNmadd:
1154       unreachable                instruction_o.op = ariane_pkg::FNMADD;  // fnmadd.fmt - FP Negated fused multiply-add
1148       unreachable                default: instruction_o.op = ariane_pkg::FMADD;  // fmadd.fmt - FP Fused multiply-add
1149                                  riscv::OpcodeMsub:
1150                                  instruction_o.op = ariane_pkg::FMSUB;  // fmsub.fmt - FP Fused multiply-subtract
1151                                  riscv::OpcodeNmsub:
1152                                  instruction_o.op = ariane_pkg::FNMSUB; // fnmsub.fmt - FP Negated fused multiply-subtract
1153                                  riscv::OpcodeNmadd:
1154                                  instruction_o.op = ariane_pkg::FNMADD;  // fnmadd.fmt - FP Negated fused multiply-add
1155                                endcase
1156                    
1157                                // determine fp format
1158       unreachable              unique case (instr.r4type.funct2)
1159                                  // Only process instruction if corresponding extension is active (static)
1160       unreachable                2'b00:   if (~CVA6Cfg.RVF) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1161       unreachable                2'b01:   if (~CVA6Cfg.RVD) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1162       unreachable                2'b10:   if (~CVA6Cfg.XF16 & ~CVA6Cfg.XF16ALT) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1163       unreachable                2'b11:   if (~CVA6Cfg.XF8) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1164       unreachable                default: illegal_instr = 1'b1;
1165                                endcase
1166                    
1167                                // check rounding mode
1168       unreachable              if (check_fprm) begin
1169       unreachable                unique case (instr.rftype.rm) inside
1170       unreachable                  [3'b000 : 3'b100]: ;  //legal rounding modes
1171                                    3'b101: begin  // Alternative Half-Precsision encded as fmt=10 and rm=101
1172       unreachable                    if (~CVA6Cfg.XF16ALT || instr.rftype.fmt != 2'b10) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1173       unreachable                    unique case (frm_i) inside  // actual rounding mode from frm csr
1174       unreachable                      [3'b000 : 3'b100]: ;  //legal rounding modes
1175       unreachable                      default: illegal_instr = 1'b1;
1176                                      endcase
1177                                    end
1178                                    3'b111: begin
1179                                      // rounding mode from frm csr
1180       unreachable                    unique case (frm_i) inside
1181       unreachable                      [3'b000 : 3'b100]: ;  //legal rounding modes
1182       unreachable                      default: illegal_instr = 1'b1;
1183                                      endcase
1184                                    end
1185       unreachable                  default:           illegal_instr = 1'b1;
1186                                  endcase
1187                                end
                   ==>  MISSING_ELSE
1188                              end else begin
1189       1/1                      illegal_instr = 1'b1;
1190                              end
1191                            end
1192                    
1193                            riscv::OpcodeOpFp: begin
1194       1/1                    if (CVA6Cfg.FpPresent && fs_i != riscv::Off && ((CVA6Cfg.RVH && (!v_i || vfs_i != riscv::Off)) || !CVA6Cfg.RVH)) begin // only generate decoder if FP extensions are enabled (static)
1195       unreachable              instruction_o.fu  = FPU;
1196       unreachable              instruction_o.rs1 = instr.rftype.rs1;
1197       unreachable              instruction_o.rs2 = instr.rftype.rs2;
1198       unreachable              instruction_o.rd  = instr.rftype.rd;
1199       unreachable              check_fprm        = 1'b1;
1200                                // decode FP instruction
1201       unreachable              unique case (instr.rftype.funct5)
1202                                  5'b00000: begin
1203       unreachable                  instruction_o.op  = ariane_pkg::FADD;  // fadd.fmt - FP Addition
1204       unreachable                  instruction_o.rs1 = '0;  // Operand A is set to 0
1205       unreachable                  instruction_o.rs2 = instr.rftype.rs1;  // Operand B is set to rs1
1206       unreachable                  imm_select        = IIMM;  // Operand C is set to rs2
1207                                  end
1208                                  5'b00001: begin
1209       unreachable                  instruction_o.op  = ariane_pkg::FSUB;  // fsub.fmt - FP Subtraction
1210       unreachable                  instruction_o.rs1 = '0;  // Operand A is set to 0
1211       unreachable                  instruction_o.rs2 = instr.rftype.rs1;  // Operand B is set to rs1
1212       unreachable                  imm_select        = IIMM;  // Operand C is set to rs2
1213                                  end
1214       unreachable                5'b00010: instruction_o.op = ariane_pkg::FMUL;  // fmul.fmt - FP Multiplication
1215       unreachable                5'b00011: instruction_o.op = ariane_pkg::FDIV;  // fdiv.fmt - FP Division
1216                                  5'b01011: begin
1217       unreachable                  instruction_o.op = ariane_pkg::FSQRT;  // fsqrt.fmt - FP Square Root
1218                                    // rs2 must be zero
1219       unreachable                  if (instr.rftype.rs2 != 5'b00000) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1220                                  end
1221                                  5'b00100: begin
1222       unreachable                  instruction_o.op = ariane_pkg::FSGNJ;  // fsgn{j[n]/jx}.fmt - FP Sign Injection
1223       unreachable                  check_fprm       = 1'b0;  // instruction encoded in rm, do the check here
1224       unreachable                  if (CVA6Cfg.XF16ALT) begin        // FP16ALT instructions encoded in rm separately (static)
1225       unreachable                    if (!(instr.rftype.rm inside {[3'b000 : 3'b010], [3'b100 : 3'b110]}))
1226       unreachable                      illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1227                                    end else begin
1228       unreachable                    if (!(instr.rftype.rm inside {[3'b000 : 3'b010]})) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1229                                    end
1230                                  end
1231                                  5'b00101: begin
1232       unreachable                  instruction_o.op = ariane_pkg::FMIN_MAX;  // fmin/fmax.fmt - FP Minimum / Maximum
1233       unreachable                  check_fprm       = 1'b0;  // instruction encoded in rm, do the check here
1234       unreachable                  if (CVA6Cfg.XF16ALT) begin           // FP16ALT instructions encoded in rm separately (static)
1235       unreachable                    if (!(instr.rftype.rm inside {[3'b000 : 3'b001], [3'b100 : 3'b101]}))
1236       unreachable                      illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1237                                    end else begin
1238       unreachable                    if (!(instr.rftype.rm inside {[3'b000 : 3'b001]})) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1239                                    end
1240                                  end
1241                                  5'b01000: begin
1242       unreachable                  instruction_o.op = ariane_pkg::FCVT_F2F;  // fcvt.fmt.fmt - FP to FP Conversion
1243       unreachable                  instruction_o.rs2 = instr.rvftype.rs1; // tie rs2 to rs1 to be safe (vectors use rs2)
1244       unreachable                  imm_select = IIMM;  // rs2 holds part of the intruction
1245       unreachable                  if (|instr.rftype.rs2[24:23])
1246       unreachable                    illegal_instr = 1'b1;  // bits [22:20] used, other bits must be 0
                   ==>  MISSING_ELSE
1247                                    // check source format
1248       unreachable                  unique case (instr.rftype.rs2[22:20])
1249                                      // Only process instruction if corresponding extension is active (static)
1250       unreachable                    3'b000:  if (~CVA6Cfg.RVF) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1251       unreachable                    3'b001:  if (~CVA6Cfg.RVD) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1252       unreachable                    3'b010:  if (~CVA6Cfg.XF16) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1253       unreachable                    3'b110:  if (~CVA6Cfg.XF16ALT) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1254       unreachable                    3'b011:  if (~CVA6Cfg.XF8) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1255       unreachable                    default: illegal_instr = 1'b1;
1256                                    endcase
1257                                  end
1258                                  5'b10100: begin
1259       unreachable                  instruction_o.op = ariane_pkg::FCMP;  // feq/flt/fle.fmt - FP Comparisons
1260       unreachable                  check_fprm       = 1'b0;  // instruction encoded in rm, do the check here
1261       unreachable                  if (CVA6Cfg.XF16ALT) begin       // FP16ALT instructions encoded in rm separately (static)
1262       unreachable                    if (!(instr.rftype.rm inside {[3'b000 : 3'b010], [3'b100 : 3'b110]}))
1263       unreachable                      illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1264                                    end else begin
1265       unreachable                    if (!(instr.rftype.rm inside {[3'b000 : 3'b010]})) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1266                                    end
1267                                  end
1268                                  5'b11000: begin
1269       unreachable                  instruction_o.op = ariane_pkg::FCVT_F2I;  // fcvt.ifmt.fmt - FP to Int Conversion
1270       unreachable                  imm_select       = IIMM;  // rs2 holds part of the instruction
1271       unreachable                  if (|instr.rftype.rs2[24:22])
1272       unreachable                    illegal_instr = 1'b1;  // bits [21:20] used, other bits must be 0
                   ==>  MISSING_ELSE
1273                                  end
1274                                  5'b11010: begin
1275       unreachable                  instruction_o.op = ariane_pkg::FCVT_I2F;  // fcvt.fmt.ifmt - Int to FP Conversion
1276       unreachable                  imm_select       = IIMM;  // rs2 holds part of the instruction
1277       unreachable                  if (|instr.rftype.rs2[24:22])
1278       unreachable                    illegal_instr = 1'b1;  // bits [21:20] used, other bits must be 0
                   ==>  MISSING_ELSE
1279                                  end
1280                                  5'b11100: begin
1281       unreachable                  instruction_o.rs2 = instr.rftype.rs1; // set rs2 = rs1 so we can map FMV to SGNJ in the unit
1282       unreachable                  check_fprm = 1'b0;  // instruction encoded in rm, do the check here
1283       unreachable                  if (instr.rftype.rm == 3'b000 || (CVA6Cfg.XF16ALT && instr.rftype.rm == 3'b100)) // FP16ALT has separate encoding
1284       unreachable                    instruction_o.op = ariane_pkg::FMV_F2X;  // fmv.ifmt.fmt - FPR to GPR Move
1285       unreachable                  else if (instr.rftype.rm == 3'b001 || (CVA6Cfg.XF16ALT && instr.rftype.rm == 3'b101)) // FP16ALT has separate encoding
1286       unreachable                    instruction_o.op = ariane_pkg::FCLASS;  // fclass.fmt - FP Classify
1287       unreachable                  else illegal_instr = 1'b1;
1288                                    // rs2 must be zero
1289       unreachable                  if (instr.rftype.rs2 != 5'b00000) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1290                                  end
1291                                  5'b11110: begin
1292       unreachable                  instruction_o.op = ariane_pkg::FMV_X2F;  // fmv.fmt.ifmt - GPR to FPR Move
1293       unreachable                  instruction_o.rs2 = instr.rftype.rs1; // set rs2 = rs1 so we can map FMV to SGNJ in the unit
1294       unreachable                  check_fprm = 1'b0;  // instruction encoded in rm, do the check here
1295       unreachable                  if (!(instr.rftype.rm == 3'b000 || (CVA6Cfg.XF16ALT && instr.rftype.rm == 3'b100)))
1296       unreachable                    illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1297                                    // rs2 must be zero
1298       unreachable                  if (instr.rftype.rs2 != 5'b00000) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1299                                  end
1300       unreachable                default:  illegal_instr = 1'b1;
1301                                endcase
1302                    
1303                                // check format
1304       unreachable              unique case (instr.rftype.fmt)
1305                                  // Only process instruction if corresponding extension is active (static)
1306       unreachable                2'b00:   if (~CVA6Cfg.RVF) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1307       unreachable                2'b01:   if (~CVA6Cfg.RVD) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1308       unreachable                2'b10:   if (~CVA6Cfg.XF16 & ~CVA6Cfg.XF16ALT) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1309       unreachable                2'b11:   if (~CVA6Cfg.XF8) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1310       unreachable                default: illegal_instr = 1'b1;
1311                                endcase
1312                    
1313                                // check rounding mode
1314       unreachable              if (check_fprm) begin
1315       unreachable                unique case (instr.rftype.rm) inside
1316       unreachable                  [3'b000 : 3'b100]: ;  //legal rounding modes
1317                                    3'b101: begin  // Alternative Half-Precsision encded as fmt=10 and rm=101
1318       unreachable                    if (~CVA6Cfg.XF16ALT || instr.rftype.fmt != 2'b10) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1319       unreachable                    unique case (frm_i) inside  // actual rounding mode from frm csr
1320       unreachable                      [3'b000 : 3'b100]: ;  //legal rounding modes
1321       unreachable                      default: illegal_instr = 1'b1;
1322                                      endcase
1323                                    end
1324                                    3'b111: begin
1325                                      // rounding mode from frm csr
1326       unreachable                    unique case (frm_i) inside
1327       unreachable                      [3'b000 : 3'b100]: ;  //legal rounding modes
1328       unreachable                      default: illegal_instr = 1'b1;
1329                                      endcase
1330                                    end
1331       unreachable                  default:           illegal_instr = 1'b1;
1332                                  endcase
1333                                end
                   ==>  MISSING_ELSE
1334                              end else begin
1335       1/1                      illegal_instr = 1'b1;
1336                              end
1337                            end
1338                    
1339                            // ----------------------------------
1340                            // Atomic Operations
1341                            // ----------------------------------
1342                            riscv::OpcodeAmo: begin
1343                              // we are going to use the load unit for AMOs
1344       1/1                    instruction_o.fu  = STORE;
1345       1/1                    instruction_o.rs1 = instr.atype.rs1;
1346       1/1                    instruction_o.rs2 = instr.atype.rs2;
1347       1/1                    instruction_o.rd  = instr.atype.rd;
1348                              // TODO(zarubaf): Ordering
1349                              // words
1350       1/1                    if (CVA6Cfg.RVA && instr.stype.funct3 == 3'h2) begin
1351       unreachable              unique case (instr.instr[31:27])
1352       unreachable                5'h0: instruction_o.op = ariane_pkg::AMO_ADDW;
1353       unreachable                5'h1: instruction_o.op = ariane_pkg::AMO_SWAPW;
1354                                  5'h2: begin
1355       unreachable                  instruction_o.op = ariane_pkg::AMO_LRW;
1356       unreachable                  if (instr.atype.rs2 != 0) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1357                                  end
1358       unreachable                5'h3: instruction_o.op = ariane_pkg::AMO_SCW;
1359       unreachable                5'h4: instruction_o.op = ariane_pkg::AMO_XORW;
1360       unreachable                5'h8: instruction_o.op = ariane_pkg::AMO_ORW;
1361       unreachable                5'hC: instruction_o.op = ariane_pkg::AMO_ANDW;
1362       unreachable                5'h10: instruction_o.op = ariane_pkg::AMO_MINW;
1363       unreachable                5'h14: instruction_o.op = ariane_pkg::AMO_MAXW;
1364       unreachable                5'h18: instruction_o.op = ariane_pkg::AMO_MINWU;
1365       unreachable                5'h1C: instruction_o.op = ariane_pkg::AMO_MAXWU;
1366       unreachable                default: illegal_instr = 1'b1;
1367                                endcase
1368                                // double words
1369       1/1                    end else if (CVA6Cfg.IS_XLEN64 && CVA6Cfg.RVA && instr.stype.funct3 == 3'h3) begin
1370       unreachable              unique case (instr.instr[31:27])
1371       unreachable                5'h0: instruction_o.op = ariane_pkg::AMO_ADDD;
1372       unreachable                5'h1: instruction_o.op = ariane_pkg::AMO_SWAPD;
1373                                  5'h2: begin
1374       unreachable                  instruction_o.op = ariane_pkg::AMO_LRD;
1375       unreachable                  if (instr.atype.rs2 != 0) illegal_instr = 1'b1;
                   ==>  MISSING_ELSE
1376                                  end
1377       unreachable                5'h3: instruction_o.op = ariane_pkg::AMO_SCD;
1378       unreachable                5'h4: instruction_o.op = ariane_pkg::AMO_XORD;
1379       unreachable                5'h8: instruction_o.op = ariane_pkg::AMO_ORD;
1380       unreachable                5'hC: instruction_o.op = ariane_pkg::AMO_ANDD;
1381       unreachable                5'h10: instruction_o.op = ariane_pkg::AMO_MIND;
1382       unreachable                5'h14: instruction_o.op = ariane_pkg::AMO_MAXD;
1383       unreachable                5'h18: instruction_o.op = ariane_pkg::AMO_MINDU;
1384       unreachable                5'h1C: instruction_o.op = ariane_pkg::AMO_MAXDU;
1385       unreachable                default: illegal_instr = 1'b1;
1386                                endcase
1387                              end else begin
1388       1/1                      illegal_instr = 1'b1;
1389                              end
1390       1/1                    if (CVA6Cfg.RVH) begin
1391       unreachable              tinst = {
1392                                  instr.atype.funct5,
1393                                  instr.atype.aq,
1394                                  instr.atype.rl,
1395                                  instr.atype.rs2,
1396                                  5'b0,
1397                                  instr.atype.funct3,
1398                                  instr.atype.rd,
1399                                  instr.atype.opcode
1400                                };
1401                              end
                        MISSING_ELSE
1402                            end
1403                    
1404                            // --------------------------------
1405                            // Control Flow Instructions
1406                            // --------------------------------
1407                            riscv::OpcodeBranch: begin
1408       1/1                    imm_select              = SBIMM;
1409       1/1                    instruction_o.fu        = CTRL_FLOW;
1410       1/1                    instruction_o.rs1       = instr.stype.rs1;
1411       1/1                    instruction_o.rs2       = instr.stype.rs2;
1412                    
1413       1/1                    is_control_flow_instr_o = 1'b1;
1414                    
1415       1/1                    case (instr.stype.funct3)
1416       1/1                      3'b000: instruction_o.op = ariane_pkg::EQ;
1417       1/1                      3'b001: instruction_o.op = ariane_pkg::NE;
1418       1/1                      3'b100: instruction_o.op = ariane_pkg::LTS;
1419       1/1                      3'b101: instruction_o.op = ariane_pkg::GES;
1420       1/1                      3'b110: instruction_o.op = ariane_pkg::LTU;
1421       1/1                      3'b111: instruction_o.op = ariane_pkg::GEU;
1422                                default: begin
1423       1/1                        is_control_flow_instr_o = 1'b0;
1424       1/1                        illegal_instr           = 1'b1;
1425                                end
1426                              endcase
1427                            end
1428                            // Jump and link register
1429                            riscv::OpcodeJalr: begin
1430       1/1                    instruction_o.fu        = CTRL_FLOW;
1431       1/1                    instruction_o.op        = ariane_pkg::JALR;
1432       1/1                    instruction_o.rs1       = instr.itype.rs1;
1433       1/1                    imm_select              = IIMM;
1434       1/1                    instruction_o.rd        = instr.itype.rd;
1435       1/1                    is_control_flow_instr_o = 1'b1;
1436                              // invalid jump and link register -> reserved for vector encoding
1437       2/2                    if (instr.itype.funct3 != 3'b0) illegal_instr = 1'b1;
                        MISSING_ELSE
1438                            end
1439                            // Jump and link
1440                            riscv::OpcodeJal: begin
1441       1/1                    instruction_o.fu        = CTRL_FLOW;
1442       1/1                    imm_select              = JIMM;
1443       1/1                    instruction_o.rd        = instr.utype.rd;
1444       1/1                    is_control_flow_instr_o = 1'b1;
1445                            end
1446                    
1447                            riscv::OpcodeAuipc: begin
1448       1/1                    instruction_o.fu     = ALU;
1449       1/1                    imm_select           = UIMM;
1450       1/1                    instruction_o.use_pc = 1'b1;
1451       1/1                    instruction_o.rd     = instr.utype.rd;
1452                            end
1453                    
1454                            riscv::OpcodeLui: begin
1455       1/1                    imm_select       = UIMM;
1456       1/1                    instruction_o.fu = ALU;
1457       1/1                    instruction_o.rd = instr.utype.rd;
1458                            end
1459                    
1460       1/1                  default: illegal_instr = 1'b1;
1461                          endcase
1462                        end
                        MISSING_ELSE
1463       1/1              if (CVA6Cfg.CvxifEn) begin
1464       1/1                if (~ex_i.valid && (is_illegal_i || illegal_instr)) begin
1465       1/1                  instruction_o.fu = CVXIF;
1466       1/1                  instruction_o.rs1 = instr.r4type.rs1;
1467       1/1                  instruction_o.rs2 = instr.r4type.rs2;
1468       1/1                  instruction_o.rd = instr.r4type.rd;
1469       1/1                  instruction_o.op = ariane_pkg::OFFLOAD;
1470       1/1                  imm_select             = instr.rtype.opcode == riscv::OpcodeMadd ||
1471                                                     instr.rtype.opcode == riscv::OpcodeMsub ||
1472                                                     instr.rtype.opcode == riscv::OpcodeNmadd ||
1473                                                     instr.rtype.opcode == riscv::OpcodeNmsub ? RS3 : MUX_RD_RS3;
1474                          end
                        MISSING_ELSE
1475                        end
                   ==>  MISSING_ELSE
1476                    
1477                        // Accelerator instructions.
1478                        // These can overwrite the previous decoding entirely.
1479       1/1              if (CVA6Cfg.EnableAccelerator) begin // only generate decoder if accelerators are enabled (static)
1480       unreachable        if (is_accel) begin
1481       unreachable          instruction_o.fu        = acc_instruction.fu;
1482       unreachable          instruction_o.vfp       = acc_instruction.vfp;
1483       unreachable          instruction_o.rs1       = acc_instruction.rs1;
1484       unreachable          instruction_o.rs2       = acc_instruction.rs2;
1485       unreachable          instruction_o.rd        = acc_instruction.rd;
1486       unreachable          instruction_o.op        = acc_instruction.op;
1487       unreachable          illegal_instr           = acc_illegal_instr;
1488       unreachable          is_control_flow_instr_o = acc_is_control_flow_instr;
1489                          end
                   ==>  MISSING_ELSE
1490                        end
                        MISSING_ELSE
1491                      end
1492                    
1493                      // --------------------------------
1494                      // Sign extend immediate
1495                      // --------------------------------
1496                      always_comb begin : sign_extend
1497       1/1              imm_i_type = {{CVA6Cfg.XLEN - 12{instruction_i[31]}}, instruction_i[31:20]};
1498       1/1              imm_s_type = {
1499                          {CVA6Cfg.XLEN - 12{instruction_i[31]}}, instruction_i[31:25], instruction_i[11:7]
1500                        };
1501       1/1              imm_sb_type = {
1502                          {CVA6Cfg.XLEN - 13{instruction_i[31]}},
1503                          instruction_i[31],
1504                          instruction_i[7],
1505                          instruction_i[30:25],
1506                          instruction_i[11:8],
1507                          1'b0
1508                        };
1509       1/1              imm_u_type = {
1510                          {CVA6Cfg.XLEN - 32{instruction_i[31]}}, instruction_i[31:12], 12'b0
1511                        };  // JAL, AUIPC, sign extended to 64 bit
1512                        //  if zcmt then xlen jump address assign to immidiate
1513       1/1              if (CVA6Cfg.RVZCMT && is_zcmt_i) begin
1514       unreachable        imm_uj_type = {{CVA6Cfg.XLEN - 32{jump_address_i[31]}}, jump_address_i[31:0]};
1515                        end else begin
1516       1/1                imm_uj_type = {
1517                            {CVA6Cfg.XLEN - 20{instruction_i[31]}},
1518                            instruction_i[19:12],
1519                            instruction_i[20],
1520                            instruction_i[30:21],
1521                            1'b0
1522                          };
1523                        end
1524                    
1525                        // NOIMM, IIMM, SIMM, SBIMM, UIMM, JIMM, RS3
1526                        // select immediate
1527       1/1              case (imm_select)
1528                          IIMM: begin
1529       1/1                  instruction_o.result  = imm_i_type;
1530       1/1                  instruction_o.use_imm = 1'b1;
1531                          end
1532                          SIMM: begin
1533       1/1                  instruction_o.result  = imm_s_type;
1534       1/1                  instruction_o.use_imm = 1'b1;
1535                          end
1536                          SBIMM: begin
1537       1/1                  instruction_o.result  = imm_sb_type;
1538       1/1                  instruction_o.use_imm = 1'b1;
1539                          end
1540                          UIMM: begin
1541       1/1                  instruction_o.result  = imm_u_type;
1542       1/1                  instruction_o.use_imm = 1'b1;
1543                          end
1544                          JIMM: begin
1545       1/1                  instruction_o.result  = imm_uj_type;
1546       1/1                  instruction_o.use_imm = 1'b1;
1547                          end
1548                          RS3: begin
1549                            // result holds address of fp operand rs3
1550       1/1                  instruction_o.result  = {{CVA6Cfg.XLEN - 5{1'b0}}, instr.r4type.rs3};
1551       1/1                  instruction_o.use_imm = 1'b0;
1552                          end
1553                          MUX_RD_RS3: begin
1554                            // result holds address of operand rs3 which is in rd field
1555       1/1                  instruction_o.result  = {{CVA6Cfg.XLEN - 5{1'b0}}, instr.rtype.rd};
1556       1/1                  instruction_o.use_imm = 1'b0;
1557                          end
1558                          default: begin
1559       1/1                  instruction_o.result  = {CVA6Cfg.XLEN{1'b0}};
1560       1/1                  instruction_o.use_imm = 1'b0;
1561                          end
1562                        endcase
1563                    
1564       1/1              if (CVA6Cfg.EnableAccelerator) begin
1565       unreachable        if (is_accel) begin
1566       unreachable          instruction_o.result  = acc_instruction.result;
1567       unreachable          instruction_o.use_imm = acc_instruction.use_imm;
1568                          end
                   ==>  MISSING_ELSE
1569                        end
                        MISSING_ELSE
1570                      end
1571                    
1572                      // ---------------------
1573                      // Exception handling
1574                      // ---------------------
1575                      logic [CVA6Cfg.XLEN-1:0] interrupt_cause;
1576                    
1577                      // this instruction has already executed if the exception is valid
1578                      assign instruction_o.valid = instruction_o.ex.valid;
1579                    
1580                      always_comb begin : exception_handling
1581       1/1              interrupt_cause = '0;
1582       1/1              instruction_o.ex = ex_i;
1583       1/1              orig_instr_o = (is_compressed_i) ? {{CVA6Cfg.XLEN-16{1'b0}}, compressed_instr_i} : {{CVA6Cfg.XLEN-32{1'b0}}, instruction_i};
1584                        // look if we didn't already get an exception in any previous
1585                        // stage - we should not overwrite it as we retain order regarding the exception
1586       1/1              if (~ex_i.valid) begin
1587                          // if we didn't already get an exception save the instruction here as we may need it
1588                          // in the commit stage if we got a access exception to one of the CSR registers
1589       1/1                if (CVA6Cfg.TvalEn)
1590       unreachable          instruction_o.ex.tval  = (is_compressed_i) ? {{CVA6Cfg.XLEN-16{1'b0}}, compressed_instr_i} : {{CVA6Cfg.XLEN-32{1'b0}}, instruction_i};
1591       1/1                else instruction_o.ex.tval = '0;
1592       1/1(1 unreachable)        if (CVA6Cfg.RVH) instruction_o.ex.tinst = tinst;
1593       1/1                else instruction_o.ex.tinst = '0;
1594                          // instructions which will throw an exception are marked as valid
1595                          // e.g.: they can be committed anytime and do not need to wait for any functional unit
1596                          // check here if we decoded an invalid instruction or if the compressed decoder already decoded
1597                          // a invalid instruction
1598       1/1                if (illegal_instr || is_illegal_i) begin
1599       1/1(1 unreachable)          if (!CVA6Cfg.CvxifEn) instruction_o.ex.valid = 1'b1;
                        MISSING_ELSE
1600                            // we decoded an illegal exception here
1601       1/1                  instruction_o.ex.cause = riscv::ILLEGAL_INSTR;
1602       1/1                end else if (CVA6Cfg.RVH && virtual_illegal_instr) begin
1603       unreachable          instruction_o.ex.valid = 1'b1;
1604                            // we decoded an virtual illegal exception here
1605       unreachable          instruction_o.ex.cause = riscv::VIRTUAL_INSTRUCTION;
1606                            // we got an ecall, set the correct cause depending on the current privilege level
1607       1/1                end else if (ecall) begin
1608                            // this exception is valid
1609       1/1                  instruction_o.ex.valid = 1'b1;
1610                            // depending on the privilege mode, set the appropriate cause
1611       1/1                  if (priv_lvl_i == riscv::PRIV_LVL_S && CVA6Cfg.RVS) begin
1612       unreachable            instruction_o.ex.cause = (CVA6Cfg.RVH && v_i) ? riscv::ENV_CALL_VSMODE : riscv::ENV_CALL_SMODE;
1613       1/1                  end else if (priv_lvl_i == riscv::PRIV_LVL_U && CVA6Cfg.RVU) begin
1614       unreachable            instruction_o.ex.cause = riscv::ENV_CALL_UMODE;
1615                              // we are in M-mode
1616                            end else begin
1617       1/1                    instruction_o.ex.cause = riscv::ENV_CALL_MMODE;
1618                            end
1619       1/1                end else if (ebreak) begin
1620                            // this exception is valid
1621       1/1                  instruction_o.ex.valid = 1'b1;
1622                            // set breakpoint cause
1623       1/1                  instruction_o.ex.cause = riscv::BREAKPOINT;
1624                            // set gva bit
1625       1/1(1 unreachable)          if (CVA6Cfg.RVH) instruction_o.ex.gva = v_i;
1626       1/1                  else instruction_o.ex.gva = 1'b0;
1627                          end
                        MISSING_ELSE
1628                          // -----------------
1629                          // Interrupt Control
1630                          // -----------------
1631                          // we decode an interrupt the same as an exception, hence it will be taken if the instruction did not
1632                          // throw any previous exception.
1633                          // we have three interrupt sources: external interrupts, software interrupts, timer interrupts (order of precedence)
1634                          // for two privilege levels: Supervisor and Machine Mode
1635                          // Virtual Supervisor Timer Interrupt
1636       1/1                if (CVA6Cfg.RVH) begin
1637       unreachable          if (irq_ctrl_i.mie[riscv::IRQ_VS_TIMER] && irq_ctrl_i.mip[riscv::IRQ_VS_TIMER]) begin
1638       unreachable            interrupt_cause = INTERRUPTS.VS_TIMER;
1639                            end
                   ==>  MISSING_ELSE
1640                            // Virtual Supervisor Software Interrupt
1641       unreachable          if (irq_ctrl_i.mie[riscv::IRQ_VS_SOFT] && irq_ctrl_i.mip[riscv::IRQ_VS_SOFT]) begin
1642       unreachable            interrupt_cause = INTERRUPTS.VS_SW;
1643                            end
                   ==>  MISSING_ELSE
1644                            // Virtual Supervisor External Interrupt
1645       unreachable          if (irq_ctrl_i.mie[riscv::IRQ_VS_EXT] && (irq_ctrl_i.mip[riscv::IRQ_VS_EXT])) begin
1646       unreachable            interrupt_cause = INTERRUPTS.VS_EXT;
1647                            end
                   ==>  MISSING_ELSE
1648                            // Hypervisor Guest External Interrupts
1649       unreachable          if (irq_ctrl_i.mie[riscv::IRQ_HS_EXT] && irq_ctrl_i.mip[riscv::IRQ_HS_EXT]) begin
1650       unreachable            interrupt_cause = INTERRUPTS.HS_EXT;
1651                            end
                   ==>  MISSING_ELSE
1652                          end
                        MISSING_ELSE
1653       1/1                if (CVA6Cfg.RVS) begin
1654                            // Supervisor Timer Interrupt
1655       unreachable          if (irq_ctrl_i.mie[riscv::IRQ_S_TIMER] && irq_ctrl_i.mip[riscv::IRQ_S_TIMER]) begin
1656       unreachable            interrupt_cause = INTERRUPTS.S_TIMER;
1657                            end
                   ==>  MISSING_ELSE
1658                            // Supervisor Software Interrupt
1659       unreachable          if (irq_ctrl_i.mie[riscv::IRQ_S_SOFT] && irq_ctrl_i.mip[riscv::IRQ_S_SOFT]) begin
1660       unreachable            interrupt_cause = INTERRUPTS.S_SW;
1661                            end
                   ==>  MISSING_ELSE
1662                            // Supervisor External Interrupt
1663                            // The logical-OR of the software-writable bit and the signal from the external interrupt controller is
1664                            // used to generate external interrupts to the supervisor
1665       unreachable          if (irq_ctrl_i.mie[riscv::IRQ_S_EXT] && (irq_ctrl_i.mip[riscv::IRQ_S_EXT] | irq_i[ariane_pkg::SupervisorIrq])) begin
1666       unreachable            interrupt_cause = INTERRUPTS.S_EXT;
1667                            end
                   ==>  MISSING_ELSE
1668                          end
                        MISSING_ELSE
1669                          // Machine Timer Interrupt
1670       1/1                if (irq_ctrl_i.mip[riscv::IRQ_M_TIMER] && irq_ctrl_i.mie[riscv::IRQ_M_TIMER]) begin
1671       1/1                  interrupt_cause = INTERRUPTS.M_TIMER;
1672                          end
                        MISSING_ELSE
1673       1/1                if (CVA6Cfg.SoftwareInterruptEn) begin
1674                            // Machine Mode Software Interrupt
1675       unreachable          if (irq_ctrl_i.mip[riscv::IRQ_M_SOFT] && irq_ctrl_i.mie[riscv::IRQ_M_SOFT]) begin
1676       unreachable            interrupt_cause = INTERRUPTS.M_SW;
1677                            end
                   ==>  MISSING_ELSE
1678                          end
                        MISSING_ELSE
1679                          // Machine Mode External Interrupt
1680       1/1                if (irq_ctrl_i.mip[riscv::IRQ_M_EXT] && irq_ctrl_i.mie[riscv::IRQ_M_EXT]) begin
1681       1/1                  interrupt_cause = INTERRUPTS.M_EXT;
1682                          end
                        MISSING_ELSE
1683                    
1684       1/1                if (interrupt_cause[CVA6Cfg.XLEN-1] && irq_ctrl_i.global_enable) begin
1685                            // However, if bit i in mideleg is set, interrupts are considered to be globally enabled if the harts current privilege
1686                            // mode equals the delegated privilege mode (S or U) and that modes interrupt enable bit
1687                            // (SIE or UIE in mstatus) is set, or if the current privilege mode is less than the delegated privilege mode.
1688       1/1                  if (CVA6Cfg.RVS && irq_ctrl_i.mideleg[interrupt_cause[$clog2(CVA6Cfg.XLEN)-1:0]]) begin
1689       unreachable            if (CVA6Cfg.RVH) begin : hyp_int_gen
1690       unreachable              if (v_i && irq_ctrl_i.hideleg[interrupt_cause[$clog2(CVA6Cfg.XLEN)-1:0]]) begin
1691       unreachable                if ((irq_ctrl_i.sie && priv_lvl_i == riscv::PRIV_LVL_S) || priv_lvl_i == riscv::PRIV_LVL_U) begin
1692       unreachable                  instruction_o.ex.valid = 1'b1;
1693       unreachable                  instruction_o.ex.cause = interrupt_cause;
1694                                  end
                   ==>  MISSING_ELSE
1695       unreachable              end else if (v_i && ~irq_ctrl_i.hideleg[interrupt_cause[$clog2(
1696                                        CVA6Cfg.XLEN
1697                                    )-1:0]]) begin
1698       unreachable                instruction_o.ex.valid = 1'b1;
1699       unreachable                instruction_o.ex.cause = interrupt_cause;
1700       unreachable              end else if (!v_i && ((irq_ctrl_i.sie && priv_lvl_i == riscv::PRIV_LVL_S) || priv_lvl_i == riscv::PRIV_LVL_U) && ~irq_ctrl_i.hideleg[interrupt_cause[$clog2(
1701                                        CVA6Cfg.XLEN
1702                                    )-1:0]]) begin
1703       unreachable                instruction_o.ex.valid = 1'b1;
1704       unreachable                instruction_o.ex.cause = interrupt_cause;
1705                                end
                   ==>  MISSING_ELSE
1706                              end else begin
1707       unreachable              if ((CVA6Cfg.RVS && irq_ctrl_i.sie && priv_lvl_i == riscv::PRIV_LVL_S) || (CVA6Cfg.RVU && priv_lvl_i == riscv::PRIV_LVL_U)) begin
1708       unreachable                instruction_o.ex.valid = 1'b1;
1709       unreachable                instruction_o.ex.cause = interrupt_cause;
1710                                end
                   ==>  MISSING_ELSE
1711                              end
1712                            end else begin
1713       1/1                    instruction_o.ex.valid = 1'b1;
1714       1/1                    instruction_o.ex.cause = interrupt_cause;
1715                            end
1716                          end
                        MISSING_ELSE
1717                        end
                        MISSING_ELSE
1718                    
1719                        // a debug request has precendece over everything else
1720       1/1              if (CVA6Cfg.DebugEn && debug_req_i && !debug_mode_i) begin
1721       unreachable        instruction_o.ex.valid = 1'b1;
1722       unreachable        instruction_o.ex.cause = riscv::DEBUG_REQUEST;
1723                        end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : decoder

               Total   Covered  Percent
Conditions        134      132    98.51
Logical           134      132    98.51
Non-Logical         0        0
Event               0        0

 LINE       201
 EXPRESSION ((instr.itype.rs1 != '0) || (instr.itype.rd != '0))
             -----------1-----------    -----------2----------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       201
 SUB-EXPRESSION (instr.itype.rs1 != '0)
                -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       201
 SUB-EXPRESSION (instr.itype.rd != '0)
                -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       230
 EXPRESSION ((priv_lvl_i == PRIV_LVL_S) && tsr_i)
             -------------1------------    --2--

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       230
 SUB-EXPRESSION (priv_lvl_i == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       257
 EXPRESSION (((!debug_mode_i)) ? 1'b1 : illegal_instr)
             --------1--------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       284
 EXPRESSION (instr.instr[31:25] == 7'b0001001)
            -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       289
 EXPRESSION ((priv_lvl_i == PRIV_LVL_S) ? 1'b0 : 1'b1)
             -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       289
 SUB-EXPRESSION (priv_lvl_i == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       300
 EXPRESSION (instr.instr[31:25] == 7'b0010001)
            -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       306
 EXPRESSION ((priv_lvl_i inside {PRIV_LVL_M, PRIV_LVL_S}) ? 1'b0 : 1'b1)
             ----------------------1---------------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       309
 EXPRESSION (instr.instr[31:25] == 7'b0110001)
            -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       315
 EXPRESSION ((priv_lvl_i inside {PRIV_LVL_M, PRIV_LVL_S}) ? 1'b0 : 1'b1)
             ----------------------1---------------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       319
 EXPRESSION ((priv_lvl_i == PRIV_LVL_S) && ((!v_i)) && tvm_i)
             -------------1------------    ----2---    --3--

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       319
 SUB-EXPRESSION (priv_lvl_i == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       332
 EXPRESSION (instr.instr[25] != 1'b0)
            ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       347
 EXPRESSION (((!hu_i)) && (priv_lvl_i == PRIV_LVL_U))
             ----1----    -------------2------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       347
 SUB-EXPRESSION (priv_lvl_i == PRIV_LVL_U)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       350
 EXPRESSION (instr.rtype.rs2 == 5'b0)
            ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       353
 EXPRESSION (instr.rtype.rs2 == 5'b1)
            ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       358
 EXPRESSION (instr.rtype.rs2 == 5'b0)
            ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       361
 EXPRESSION (instr.rtype.rs2 == 5'b1)
            ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       364
 EXPRESSION (instr.rtype.rs2 == 5'b00011)
            --------------1--------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       369
 EXPRESSION (instr.rtype.rs2 == 5'b0)
            ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       372
 EXPRESSION (instr.rtype.rs2 == 5'b1)
            ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       375
 EXPRESSION (instr.rtype.rs2 == 5'b00011)
            --------------1--------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       408
 EXPRESSION (instr.itype.rs1 == '0)
            -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       415
 EXPRESSION (instr.itype.rs1 == '0)
            -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       430
 EXPRESSION (instr.itype.rs1 == 5'b0)
            ------------1------------

-1- Status
 0  Covered
 1  Covered

 LINE       438
 EXPRESSION (instr.itype.rs1 == '0)
            -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       473
 EXPRESSION (instr.rvftype.funct2 == 2'b10)
            ---------------1---------------

-1- Status
 0  Covered
 1  Covered

 LINE       513
 EXPRESSION (instr.rvftype.rs2 != 5'b0)
            -------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       703
 EXPRESSION (((~allow_replication)) & instr.rvftype.repl)
             -----------1----------   ---------2--------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       722
 EXPRESSION (((instr.rtype.funct7 == 7'b1) || ((instr.rtype.funct7 == 7'b0000101) && ((!instr.rtype.funct3[14])))) ? MULT : ALU)
             --------------------------------------------------1--------------------------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       722
 SUB-EXPRESSION ((instr.rtype.funct7 == 7'b1) || ((instr.rtype.funct7 == 7'b0000101) && ((!instr.rtype.funct3[14]))))
                 --------------1-------------    ---------------------------------2---------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       722
 SUB-EXPRESSION (instr.rtype.funct7 == 7'b1)
                --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       722
 SUB-EXPRESSION ((instr.rtype.funct7 == 7'b0000101) && ((!instr.rtype.funct3[14])))
                 -----------------1----------------    -------------2-------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       722
 SUB-EXPRESSION (instr.rtype.funct7 == 7'b0000101)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       724
 EXPRESSION ((instr.rtype.funct7 == 7'b1) ? MULT : ALU)
             --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       724
 SUB-EXPRESSION (instr.rtype.funct7 == 7'b1)
                --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       798
 EXPRESSION (((!1'b0)) && (instr.instr[24:20] == 5'b0))
             ----1----    --------------2-------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       798
 SUB-EXPRESSION (instr.instr[24:20] == 5'b0)
                --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       825
 EXPRESSION (illegal_instr_non_bm & illegal_instr_zic)
             ----------1---------   --------2--------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       826
 EXPRESSION (illegal_instr_non_bm & illegal_instr_bm)
             ----------1---------   --------2-------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       827
 EXPRESSION (illegal_instr_non_bm & illegal_instr_bm & illegal_instr_zic)
             ----------1---------   --------2-------   --------3--------

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       837
 EXPRESSION ((instr.rtype.funct7 == 7'b1) ? MULT : ALU)
             --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       837
 SUB-EXPRESSION (instr.rtype.funct7 == 7'b1)
                --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       874
 EXPRESSION (instr.instr[24:20] == 5'b0)
            --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       881
 EXPRESSION (illegal_instr_non_bm & illegal_instr_bm)
             ----------1---------   --------2-------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       906
 EXPRESSION (instr.instr[31:26] != 6'b0)
            --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       907
 EXPRESSION ((instr.instr[25] != 1'b0) && (32'b00000000000000000000000000100000 == 32))
             ------------1------------    ----------------------2---------------------

-1- -2- Status
 0   -  Covered
 1   -  Covered

 LINE       907
 SUB-EXPRESSION (instr.instr[25] != 1'b0)
                ------------1------------

-1- Status
 0  Covered
 1  Covered

 LINE       907
 SUB-EXPRESSION (32'b00000000000000000000000000100000 == 32)
                ----------------------1---------------------

-1- Status
 0  Unreachable
 1  Covered

 LINE       911
 EXPRESSION (instr.instr[31:26] == 6'b0)
            --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       913
 EXPRESSION (instr.instr[31:26] == 6'b010000)
            ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       916
 EXPRESSION ((instr.instr[25] != 1'b0) && (32'b00000000000000000000000000100000 == 32))
             ------------1------------    ----------------------2---------------------

-1- -2- Status
 0   -  Covered
 1   -  Covered

 LINE       916
 SUB-EXPRESSION (instr.instr[25] != 1'b0)
                ------------1------------

-1- Status
 0  Covered
 1  Covered

 LINE       916
 SUB-EXPRESSION (32'b00000000000000000000000000100000 == 32)
                ----------------------1---------------------

-1- Status
 0  Unreachable
 1  Covered

 LINE       922
 EXPRESSION (instr.instr[31:25] == 7'b0110000)
            -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       923
 EXPRESSION (instr.instr[24:20] == 5'b00100)
            ----------------1---------------

-1- Status
 0  Covered
 1  Covered

 LINE       924
 EXPRESSION (instr.instr[24:20] == 5'b00101)
            ----------------1---------------

-1- Status
 0  Covered
 1  Covered

 LINE       925
 EXPRESSION (instr.instr[24:20] == 5'b00010)
            ----------------1---------------

-1- Status
 0  Covered
 1  Covered

 LINE       926
 EXPRESSION (instr.instr[24:20] == 5'b0)
            --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       927
 EXPRESSION (instr.instr[24:20] == 5'b1)
            --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       931
 EXPRESSION (1'b1 && (instr.instr[31:25] == 7'b0100100))
             --1-    -----------------2----------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       931
 SUB-EXPRESSION (instr.instr[31:25] == 7'b0100100)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       935
 EXPRESSION (1'b1 && (instr.instr[31:25] == 7'b0110100))
             --1-    -----------------2----------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       935
 SUB-EXPRESSION (instr.instr[31:25] == 7'b0110100)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       939
 EXPRESSION (1'b1 && (instr.instr[31:25] == 7'b0010100))
             --1-    -----------------2----------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       939
 SUB-EXPRESSION (instr.instr[31:25] == 7'b0010100)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       946
 EXPRESSION (instr.instr[31:20] == 12'b001010000111)
            --------------------1-------------------

-1- Status
 0  Covered
 1  Covered

 LINE       949
 EXPRESSION (instr.instr[31:20] == 12'b011010011000)
            --------------------1-------------------

-1- Status
 0  Covered
 1  Covered

 LINE       953
 EXPRESSION (1'b1 && (instr.instr[31:25] == 7'b0100100))
             --1-    -----------------2----------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       953
 SUB-EXPRESSION (instr.instr[31:25] == 7'b0100100)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       957
 EXPRESSION (1'b1 && (instr.instr[31:25] == 7'b0110000))
             --1-    -----------------2----------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       957
 SUB-EXPRESSION (instr.instr[31:25] == 7'b0110000)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       967
 EXPRESSION (illegal_instr_non_bm & illegal_instr_bm)
             ----------1---------   --------2-------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       986
 EXPRESSION (instr.instr[31:25] != 7'b0)
            --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       989
 EXPRESSION (instr.instr[31:25] == 7'b0)
            --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       991
 EXPRESSION (instr.instr[31:25] == 7'b0100000)
            -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1000
 EXPRESSION (instr.instr[31:25] == 7'b0110000)
            -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1001
 EXPRESSION (instr.instr[21:20] == 2'b10)
            --------------1--------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1002
 EXPRESSION (instr.instr[21:20] == 2'b0)
            --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1003
 EXPRESSION (instr.instr[21:20] == 2'b1)
            --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1005
 EXPRESSION (instr.instr[31:26] == 6'b000010)
            ----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1010
 EXPRESSION (instr.instr[31:25] == 7'b0110000)
            -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1015
 EXPRESSION (illegal_instr_non_bm & illegal_instr_bm)
             ----------1---------   --------2-------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1042
 EXPRESSION (is_compressed_i ? 1'b0 : 'b1)
             -------1-------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1068
 EXPRESSION (is_compressed_i ? 1'b0 : 'b1)
             -------1-------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1100
 EXPRESSION (is_compressed_i ? 1'b0 : 'b1)
             -------1-------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1130
 EXPRESSION (is_compressed_i ? 1'b0 : 'b1)
             -------1-------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1219
 EXPRESSION (instr.rftype.rs2 != 5'b0)
            -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1283
 EXPRESSION ((instr.rftype.rm == 3'b0) || ((1'b0 && (instr.rftype.rm == 3'b100))))
             ------------1------------    -------------------2-------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1283
 SUB-EXPRESSION (instr.rftype.rm == 3'b0)
                ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1285
 EXPRESSION ((instr.rftype.rm == 3'b1) || ((1'b0 && (instr.rftype.rm == 3'b101))))
             ------------1------------    -------------------2-------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1285
 SUB-EXPRESSION (instr.rftype.rm == 3'b1)
                ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1289
 EXPRESSION (instr.rftype.rs2 != 5'b0)
            -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1295
 EXPRESSION ( ! ((instr.rftype.rm == 3'b0) || ((1'b0 && (instr.rftype.rm == 3'b100)))) )
                -----------------------------------1----------------------------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1295
 SUB-EXPRESSION ((instr.rftype.rm == 3'b0) || ((1'b0 && (instr.rftype.rm == 3'b100))))
                 ------------1------------    -------------------2-------------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1295
 SUB-EXPRESSION (instr.rftype.rm == 3'b0)
                ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1298
 EXPRESSION (instr.rftype.rs2 != 5'b0)
            -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1356
 EXPRESSION (instr.atype.rs2 != 5'b0)
            ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1375
 EXPRESSION (instr.atype.rs2 != 5'b0)
            ------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1437
 EXPRESSION (instr.itype.funct3 != 3'b0)
            --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       1464
 EXPRESSION (((~ex_i.valid)) && (is_illegal_i || illegal_instr))
             -------1-------    ---------------2---------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       1464
 SUB-EXPRESSION (is_illegal_i || illegal_instr)
                 ------1-----    ------2------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Not Covered

 LINE       1470
 EXPRESSION 
 Number  Term
      1  ((instr.rtype.opcode == riscv::OpcodeMadd) || (instr.rtype.opcode == riscv::OpcodeMsub) || (instr.rtype.opcode == riscv::OpcodeNmadd) || (instr.rtype.opcode == riscv::OpcodeNmsub)) ? RS3 : MUX_RD_RS3)

-1- Status
 0  Covered
 1  Covered

 LINE       1470
 SUB-EXPRESSION 
 Number  Term
      1  (instr.rtype.opcode == riscv::OpcodeMadd) || 
      2  (instr.rtype.opcode == riscv::OpcodeMsub) || 
      3  (instr.rtype.opcode == riscv::OpcodeNmadd) || 
      4  (instr.rtype.opcode == riscv::OpcodeNmsub))

-1- -2- -3- -4- Status
 0   0   0   0  Covered
 0   0   0   1  Covered
 0   0   1   0  Covered
 0   1   0   0  Covered
 1   0   0   0  Covered

 LINE       1470
 SUB-EXPRESSION (instr.rtype.opcode == riscv::OpcodeMadd)
                --------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       1470
 SUB-EXPRESSION (instr.rtype.opcode == riscv::OpcodeMsub)
                --------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       1470
 SUB-EXPRESSION (instr.rtype.opcode == riscv::OpcodeNmadd)
                ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       1470
 SUB-EXPRESSION (instr.rtype.opcode == riscv::OpcodeNmsub)
                ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       1583
 EXPRESSION 
 Number  Term
      1  is_compressed_i ? ({{(32'b00000000000000000000000000100000 - 16) {1'b0}}, compressed_instr_i}) : ({{(32'b00000000000000000000000000100000 - 32) {1'b0}}, instruction_i}))

-1- Status
 0  Covered
 1  Covered

 LINE       1590
 EXPRESSION 
 Number  Term
      1  is_compressed_i ? ({{(32'b00000000000000000000000000100000 - 16) {1'b0}}, compressed_instr_i}) : ({{(32'b00000000000000000000000000100000 - 32) {1'b0}}, instruction_i}))

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1598
 EXPRESSION (illegal_instr || is_illegal_i)
             ------1------    ------2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       1637
 EXPRESSION (irq_ctrl_i.mie[riscv::IRQ_VS_TIMER] && irq_ctrl_i.mip[riscv::IRQ_VS_TIMER])
             -----------------1-----------------    -----------------2-----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1641
 EXPRESSION (irq_ctrl_i.mie[riscv::IRQ_VS_SOFT] && irq_ctrl_i.mip[riscv::IRQ_VS_SOFT])
             -----------------1----------------    -----------------2----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1645
 EXPRESSION (irq_ctrl_i.mie[riscv::IRQ_VS_EXT] && irq_ctrl_i.mip[riscv::IRQ_VS_EXT])
             ----------------1----------------    ----------------2----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1649
 EXPRESSION (irq_ctrl_i.mie[riscv::IRQ_HS_EXT] && irq_ctrl_i.mip[riscv::IRQ_HS_EXT])
             ----------------1----------------    ----------------2----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1655
 EXPRESSION (irq_ctrl_i.mie[riscv::IRQ_S_TIMER] && irq_ctrl_i.mip[riscv::IRQ_S_TIMER])
             -----------------1----------------    -----------------2----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1659
 EXPRESSION (irq_ctrl_i.mie[riscv::IRQ_S_SOFT] && irq_ctrl_i.mip[riscv::IRQ_S_SOFT])
             ----------------1----------------    ----------------2----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1665
 EXPRESSION (irq_ctrl_i.mie[riscv::IRQ_S_EXT] && (irq_ctrl_i.mip[riscv::IRQ_S_EXT] | irq_i[ariane_pkg::SupervisorIrq]))
             ----------------1---------------    ----------------------------------2----------------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1665
 SUB-EXPRESSION (irq_ctrl_i.mip[riscv::IRQ_S_EXT] | irq_i[ariane_pkg::SupervisorIrq])
                 ----------------1---------------   ----------------2---------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1670
 EXPRESSION (irq_ctrl_i.mip[riscv::IRQ_M_TIMER] && irq_ctrl_i.mie[riscv::IRQ_M_TIMER])
             -----------------1----------------    -----------------2----------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       1675
 EXPRESSION (irq_ctrl_i.mip[riscv::IRQ_M_SOFT] && irq_ctrl_i.mie[riscv::IRQ_M_SOFT])
             ----------------1----------------    ----------------2----------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1680
 EXPRESSION (irq_ctrl_i.mip[riscv::IRQ_M_EXT] && irq_ctrl_i.mie[riscv::IRQ_M_EXT])
             ----------------1---------------    ----------------2---------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       1684
 EXPRESSION (interrupt_cause[(32'b00000000000000000000000000100000 - 1)] && irq_ctrl_i.global_enable)
             -----------------------------1-----------------------------    ------------2-----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       1691
 EXPRESSION ((irq_ctrl_i.sie && (priv_lvl_i == PRIV_LVL_S)) || (priv_lvl_i == PRIV_LVL_U))
             -----------------------1----------------------    -------------2------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       1691
 SUB-EXPRESSION (irq_ctrl_i.sie && (priv_lvl_i == PRIV_LVL_S))
                 -------1------    -------------2------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       1691
 SUB-EXPRESSION (priv_lvl_i == PRIV_LVL_S)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1691
 SUB-EXPRESSION (priv_lvl_i == PRIV_LVL_U)
                -------------1------------

-1- Status
 0  Unreachable
 1  Unreachable

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.id_stage_i.genblk2[0].decoder_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 99.12  99.73  98.51 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.12  99.73  98.51 --     


Module : 

SCORE  LINE   COND   ASSERT NAME    
 99.12  99.73  98.51 --     decoder 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     id_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : serdiv
===============================================================================
SCORE  LINE   COND   ASSERT 
 99.13 100.00  98.26 --     

Source File(s) : 

cva6/core/serdiv.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                    
 99.13 100.00  98.26 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div 



-------------------------------------------------------------------------------
Line Coverage for Module : serdiv

             Line No.   Total   Covered  Percent
TOTAL                       60       60   100.00
ALWAYS            169       35       35   100.00
ALWAYS            248       25       25   100.00

168                         // default
169        1/1              state_d    = state_q;
170        1/1              in_rdy_o   = 1'b0;
171        1/1              out_vld_o  = 1'b0;
172        1/1              load_en    = 1'b0;
173        1/1              a_reg_en   = 1'b0;
174        1/1              b_reg_en   = 1'b0;
175        1/1              res_reg_en = 1'b0;
176                     
177        1/1              unique case (state_q)
178                           IDLE: begin
179        1/1                  in_rdy_o = 1'b1;
180                     
181        1/1                  if (in_vld_i) begin
182                               // CVA6: there is a cycle delay until the valid signal is asserted by the id stage
183                               // Ara:  we need a stable handshake
184        1/1                    in_rdy_o = (STABLE_HANDSHAKE) ? 1'b1 : 1'b0;
185        1/1                    a_reg_en = 1'b1;
186        1/1                    b_reg_en = 1'b1;
187        1/1                    load_en  = 1'b1;
188        1/1                    state_d  = DIVIDE;
189                             end
                        MISSING_ELSE
190                           end
191                           DIVIDE: begin
192        1/1                  if (~(div_res_zero_q | op_b_zero_q | op_b_neg_one_q)) begin
193        1/1                    a_reg_en   = ab_comp;
194        1/1                    b_reg_en   = 1'b1;
195        1/1                    res_reg_en = 1'b1;
196                             end
                        MISSING_ELSE
197                             // can end the division immediately if the result is known
198        1/1                  if (div_res_zero_q | op_b_zero_q | op_b_neg_one_q) begin
199        1/1                    out_vld_o = 1'b1;
200        1/1                    state_d   = FINISH;
201        1/1                    if (out_rdy_i) begin
202                                 // in_rdy_o = 1'b1;// there is a cycle delay until the valid signal is asserted by the id stage
203        1/1                      state_d = IDLE;
204                               end
                   ==>  MISSING_ELSE
205        1/1                  end else if (cnt_zero) begin
206        1/1                    state_d = FINISH;
207                             end
                        MISSING_ELSE
208                           end
209                           FINISH: begin
210        1/1                  out_vld_o = 1'b1;
211                     
212        1/1                  if (out_rdy_i) begin
213                               // in_rdy_o = 1'b1;// there is a cycle delay until the valid signal is asserted by the id stage
214        1/1                    state_d = IDLE;
215                             end
                   ==>  MISSING_ELSE
216                           end
217        1/1                default: state_d = IDLE;
218                         endcase
219                     
220        1/1              if (flush_i) begin
221        1/1                a_reg_en = 1'b0;
222        1/1                b_reg_en = 1'b0;
223        1/1                load_en  = 1'b0;
224        1/1                state_d  = IDLE;
225                         end
                        MISSING_ELSE
226                       end
227                     
228                       /////////////////////////////////////
229                       // regs, flags
230                       /////////////////////////////////////
231                     
232                       // get flags
233                       assign rem_sel_d = (load_en) ? opcode_i[1] : rem_sel_q;
234                       assign comp_inv_d = (load_en) ? opcode_i[0] & op_b_sign : comp_inv_q;
235                       assign op_b_zero_d = (load_en) ? op_b_zero : op_b_zero_q;
236                       assign op_b_neg_one_d = (load_en) ? op_b_neg_one : op_b_neg_one_q;
237                       assign res_inv_d       = (load_en) ? (~op_b_zero | opcode_i[1]) & opcode_i[0] & (op_a_sign ^ op_b_sign ^ op_b_neg_one) : res_inv_q;
238                     
239                       // transaction id
240                       assign id_d = (load_en) ? id_i : id_q;
241                       assign id_o = id_q;
242                     
243                       assign op_a_d = (a_reg_en) ? add_out : op_a_q;
244                       assign op_b_d = (b_reg_en) ? b_mux : op_b_q;
245                       assign res_d = (load_en) ? '0 : (res_reg_en) ? {res_q[$high(res_q)-1:0], ab_comp} : res_q;
246                     
247                       always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs
248        1/1              if (~rst_ni) begin
249        1/1                state_q        <= IDLE;
250        1/1                op_a_q         <= '0;
251        1/1                op_b_q         <= '0;
252        1/1                res_q          <= '0;
253        1/1                cnt_q          <= '0;
254        1/1                id_q           <= '0;
255        1/1                rem_sel_q      <= 1'b0;
256        1/1                comp_inv_q     <= 1'b0;
257        1/1                res_inv_q      <= 1'b0;
258        1/1                op_b_zero_q    <= 1'b0;
259        1/1                op_b_neg_one_q <= 1'b0;
260        1/1                div_res_zero_q <= 1'b0;
261                         end else begin
262        1/1                state_q        <= state_d;
263        1/1                op_a_q         <= op_a_d;
264        1/1                op_b_q         <= op_b_d;
265        1/1                res_q          <= res_d;
266        1/1                cnt_q          <= cnt_d;
267        1/1                id_q           <= id_d;
268        1/1                rem_sel_q      <= rem_sel_d;
269        1/1                comp_inv_q     <= comp_inv_d;
270        1/1                res_inv_q      <= res_inv_d;
271        1/1                op_b_zero_q    <= op_b_zero_d;
272        1/1                op_b_neg_one_q <= op_b_neg_one_d;
273        1/1                div_res_zero_q <= div_res_zero_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : serdiv

               Total   Covered  Percent
Conditions        115      113    98.26
Logical           115      113    98.26
Non-Logical         0        0
Event               0        0

 LINE       192
 SUB-EXPRESSION (div_res_zero_q | op_b_zero_q | op_b_neg_one_q)
                 -------1------   -----2-----   -------3------

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Covered
 0   1   0  Covered
 1   0   0  Covered

 LINE       198
 EXPRESSION (div_res_zero_q | op_b_zero_q | op_b_neg_one_q)
             -------1------   -----2-----   -------3------

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Covered
 0   1   0  Covered
 1   0   0  Covered

 LINE       103
 EXPRESSION (lzc_b_no_one & ((~op_b_sign)))
             ------1-----   -------2------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       104
 EXPRESSION (lzc_b_no_one & op_b_sign)
             ------1-----   ----2----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       106
 EXPRESSION ((opcode_i[0] & op_a_sign) ? ({(~op_a_i[(31 - 1):0]), 1'b1}) : op_a_i)
             ------------1------------

-1- Status
 0  Covered
 1  Covered

 LINE       106
 SUB-EXPRESSION (opcode_i[0] & op_a_sign)
                 -----1-----   ----2----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       107
 EXPRESSION ((opcode_i[0] & op_b_sign) ? ((~op_b_i)) : op_b_i)
             ------------1------------

-1- Status
 0  Covered
 1  Covered

 LINE       107
 SUB-EXPRESSION (opcode_i[0] & op_b_sign)
                 -----1-----   ----2----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       127
 EXPRESSION (lzc_a_no_one ? WIDTH : ({1'b0, lzc_a_result}))
             ------1-----

-1- Status
 0  Covered
 1  Covered

 LINE       133
 EXPRESSION (load_en ? div_shift[6] : div_res_zero_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       139
 EXPRESSION (load_en & ( ~ (opcode_i[0] & (op_a_sign ^ op_b_sign)) ))
             ---1---   ----------------------2----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       139
 SUB-EXPRESSION (opcode_i[0] & (op_a_sign ^ op_b_sign))
                 -----1-----   -----------2-----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       139
 SUB-EXPRESSION (op_a_sign ^ op_b_sign)
                 ----1----   ----2----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       142
 EXPRESSION (load_en ? op_a_i : op_b_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       145
 EXPRESSION (load_en ? op_b : ({comp_inv_q, op_b_q[31:1]}))
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       148
 EXPRESSION (rem_sel_q ? (op_b_neg_one_q ? '0 : op_a_q) : (op_b_zero_q ? '1 : (op_b_neg_one_q ? op_a_q : res_q)))
             ----1----

-1- Status
 0  Covered
 1  Covered

 LINE       148
 SUB-EXPRESSION (op_b_neg_one_q ? '0 : op_a_q)
                 -------1------

-1- Status
 0  Covered
 1  Covered

 LINE       148
 SUB-EXPRESSION (op_b_zero_q ? '1 : (op_b_neg_one_q ? op_a_q : res_q))
                 -----1-----

-1- Status
 0  Covered
 1  Covered

 LINE       148
 SUB-EXPRESSION (op_b_neg_one_q ? op_a_q : res_q)
                 -------1------

-1- Status
 0  Covered
 1  Covered

 LINE       151
 EXPRESSION (res_inv_q ? ((-$signed(out_mux))) : out_mux)
             ----1----

-1- Status
 0  Covered
 1  Covered

 LINE       154
 EXPRESSION (((op_a_q == op_b_q) | ((op_a_q > op_b_q) ^ comp_inv_q)) & (((|op_a_q)) | op_b_zero_q))
             ---------------------------1---------------------------   -------------2-------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       154
 SUB-EXPRESSION ((op_a_q == op_b_q) | ((op_a_q > op_b_q) ^ comp_inv_q))
                 ---------1--------   ----------------2---------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       154
 SUB-EXPRESSION (op_a_q == op_b_q)
                ---------1--------

-1- Status
 0  Covered
 1  Covered

 LINE       154
 SUB-EXPRESSION ((op_a_q > op_b_q) ^ comp_inv_q)
                 --------1--------   -----2----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       154
 SUB-EXPRESSION (((|op_a_q)) | op_b_zero_q)
                 -----1-----   -----2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       157
 EXPRESSION (load_en ? 0 : op_a_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       158
 EXPRESSION (pm_sel ? ((add_tmp + add_mux)) : ((add_tmp - $signed(add_mux))))
             ---1--

-1- Status
 0  Covered
 1  Covered

 LINE       164
 EXPRESSION (cnt_q == 5'b0)
            -------1-------

-1- Status
 0  Covered
 1  Covered

 LINE       165
 EXPRESSION (load_en ? div_shift[($clog2(WIDTH) - 1):0] : (((~cnt_zero)) ? ((cnt_q - 1)) : cnt_q))
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       165
 SUB-EXPRESSION (((~cnt_zero)) ? ((cnt_q - 1)) : cnt_q)
                 ------1------

-1- Status
 0  Covered
 1  Covered

 LINE       233
 EXPRESSION (load_en ? opcode_i[1] : rem_sel_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       234
 EXPRESSION (load_en ? (opcode_i[0] & op_b_sign) : comp_inv_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       234
 SUB-EXPRESSION (opcode_i[0] & op_b_sign)
                 -----1-----   ----2----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       235
 EXPRESSION (load_en ? op_b_zero : op_b_zero_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       236
 EXPRESSION (load_en ? op_b_neg_one : op_b_neg_one_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       237
 EXPRESSION (load_en ? ((((~op_b_zero)) | opcode_i[1]) & opcode_i[0] & (op_a_sign ^ op_b_sign ^ op_b_neg_one)) : res_inv_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       237
 SUB-EXPRESSION ((((~op_b_zero)) | opcode_i[1]) & opcode_i[0] & (op_a_sign ^ op_b_sign ^ op_b_neg_one))
                 ---------------1--------------   -----2-----   -------------------3------------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       237
 SUB-EXPRESSION (((~op_b_zero)) | opcode_i[1])
                 -------1------   -----2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       237
 SUB-EXPRESSION (op_a_sign ^ op_b_sign ^ op_b_neg_one)
                 ----1----   ----2----   ------3-----

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Not Covered
 0   1   0  Covered
 0   1   1  Covered
 1   0   0  Covered
 1   0   1  Not Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       240
 EXPRESSION (load_en ? id_i : id_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       243
 EXPRESSION (a_reg_en ? add_out : op_a_q)
             ----1---

-1- Status
 0  Covered
 1  Covered

 LINE       244
 EXPRESSION (b_reg_en ? b_mux : op_b_q)
             ----1---

-1- Status
 0  Covered
 1  Covered

 LINE       245
 EXPRESSION (load_en ? '0 : (res_reg_en ? ({res_q[(31 - 1):0], ab_comp}) : res_q))
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       245
 SUB-EXPRESSION (res_reg_en ? ({res_q[(31 - 1):0], ab_comp}) : res_q)
                 -----1----

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 99.13 100.00  98.26 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.82 100.00  99.64 --     


Module : 

SCORE  LINE   COND   ASSERT NAME   
 99.13 100.00  98.26 --     serdiv 


Parent : 

SCORE  LINE   COND   ASSERT NAME   
100.00 100.00 100.00 --     i_mult 


Subtrees :

SCORE  LINE   COND   ASSERT NAME    
100.00 100.00 100.00 --     i_lzc_a 
100.00 100.00 100.00 --     i_lzc_b 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : frontend
===============================================================================
SCORE  LINE   COND   ASSERT 
 99.24 100.00  98.47 --     

Source File(s) : 

cva6/core/frontend/frontend.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                       
 99.24 100.00  98.47 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend 



-------------------------------------------------------------------------------
Line Coverage for Module : frontend

             Line No.   Total   Covered  Percent
TOTAL                      159      159   100.00
ALWAYS            243       38       38   100.00
ALWAYS            319        3        3   100.00
ALWAYS            412       11       11   100.00
ALWAYS            440       10       10   100.00
ALWAYS            496       18       18   100.00
ALWAYS            572       11       11   100.00
ALWAYS            601       16       16   100.00
ALWAYS            664       22       22   100.00
ALWAYS            727       30       30   100.00

242                       always_comb begin
243        1/1              taken_rvi_cf = '0;
244        1/1              taken_rvc_cf = '0;
245        1/1              predict_address = '0;
246                     
247        2/2              for (int i = 0; i < CVA6Cfg.INSTR_PER_FETCH; i++) cf_type[i] = ariane_pkg::NoCF;
248                     
249        1/1              ras_push = 1'b0;
250        1/1              ras_pop = 1'b0;
251        1/1              ras_update = '0;
252                     
253                         // lower most prediction gets precedence
254        1/1              for (int i = CVA6Cfg.INSTR_PER_FETCH - 1; i >= 0; i--) begin
255        1/1                unique case ({
256                             is_branch[i], is_return[i], is_jump[i], is_jalr[i]
257                           })
258        1/1                  4'b0000: ;  // regular instruction e.g.: no branch
259                             // unconditional jump to register, we need the BTB to resolve this
260                             4'b0001: begin
261        1/1                    ras_pop  = 1'b0;
262        1/1                    ras_push = 1'b0;
263        1/1                    if (CVA6Cfg.BTBEntries != 0 && btb_prediction_shifted[i].valid) begin
264        unreachable              predict_address = btb_prediction_shifted[i].target_address;
265        unreachable              cf_type[i] = ariane_pkg::JumpR;
266                               end
                        MISSING_ELSE
267                             end
268                             // its an unconditional jump to an immediate
269                             4'b0010: begin
270        1/1                    ras_pop = 1'b0;
271        1/1                    ras_push = 1'b0;
272        1/1                    taken_rvi_cf[i] = rvi_jump[i];
273        1/1                    taken_rvc_cf[i] = rvc_jump[i];
274        1/1                    cf_type[i] = ariane_pkg::Jump;
275                             end
276                             // return
277                             4'b0100: begin
278                               // make sure to only alter the RAS if we actually consumed the instruction
279        1/1                    ras_pop = ras_predict.valid & instr_queue_consumed[i];
280        1/1                    ras_push = 1'b0;
281        1/1                    predict_address = ras_predict.ra;
282        1/1                    cf_type[i] = ariane_pkg::Return;
283                             end
284                             // branch prediction
285                             4'b1000: begin
286        1/1                    ras_pop  = 1'b0;
287        1/1                    ras_push = 1'b0;
288                               // if we have a valid dynamic prediction use it
289        1/1                    if (bht_prediction_shifted[i].valid) begin
290        1/1                      taken_rvi_cf[i] = rvi_branch[i] & bht_prediction_shifted[i].taken;
291        1/1                      taken_rvc_cf[i] = rvc_branch[i] & bht_prediction_shifted[i].taken;
292                                 // otherwise default to static prediction
293                               end else begin
294                                 // set if immediate is negative - static prediction
295        1/1                      taken_rvi_cf[i] = rvi_branch[i] & rvi_imm[i][CVA6Cfg.VLEN-1];
296        1/1                      taken_rvc_cf[i] = rvc_branch[i] & rvc_imm[i][CVA6Cfg.VLEN-1];
297                               end
298        1/1                    if (taken_rvi_cf[i] || taken_rvc_cf[i]) begin
299        1/1                      cf_type[i] = ariane_pkg::Branch;
300                               end
                        MISSING_ELSE
301                             end
302        1/1                  default: ;
303                             // default: $error("Decoded more than one control flow");
304                           endcase
305                           // if this instruction, in addition, is a call, save the resulting address
306                           // but only if we actually consumed the address
307        1/1                if (is_call[i]) begin
308        1/1                  ras_push   = instr_queue_consumed[i];
309        1/1                  ras_update = addr[i] + (rvc_call[i] ? 2 : 4);
310                           end
                        MISSING_ELSE
311                           // calculate the jump target address
312        1/1                if (taken_rvc_cf[i] || taken_rvi_cf[i]) begin
313        1/1                  predict_address = addr[i] + (taken_rvc_cf[i] ? rvc_imm[i] : rvi_imm[i]);
314                           end
                        MISSING_ELSE
315                         end
316                       end
317                       // or reduce struct
318                       always_comb begin
319        1/1              bp_valid = 1'b0;
320                         // BP cannot be valid if we have a return instruction and the RAS is not giving a valid address
321                         // Check that we encountered a control flow and that for a return the RAS
322                         // contains a valid prediction.
323        1/1              for (int i = 0; i < CVA6Cfg.INSTR_PER_FETCH; i++)
324        1/1              bp_valid |= ((cf_type[i] != NoCF & cf_type[i] != Return) | ((cf_type[i] == Return) & ras_predict.valid));
325                       end
326                       assign is_mispredict = resolved_branch_i.is_mispredict;
327                     
328                       logic spec_req_non_idempot;
329                     
330                       // MMU interface
331                       assign areq_o.fetch_vaddr = (vaddr_q >> CVA6Cfg.FETCH_ALIGN_BITS) << CVA6Cfg.FETCH_ALIGN_BITS;
332                     
333                       // CHECK PMA regions
334                     
335                       logic paddr_is_cacheable, paddr_is_cacheable_q;  // asserted if physical address is non-cacheable
336                       assign paddr_is_cacheable = config_pkg::is_inside_cacheable_regions(
337                           CVA6Cfg, {{64 - CVA6Cfg.PLEN{1'b0}}, obi_fetch_req_o.a.addr}  //TO DO CHECK GRANULARITY
338                       );
339                     
340                       logic paddr_nonidempotent;
341                       assign paddr_nonidempotent = config_pkg::is_inside_nonidempotent_regions(
342                           CVA6Cfg, {{64 - CVA6Cfg.PLEN{1'b0}}, obi_fetch_req_o.a.addr}  //TO DO CHECK GRANULARITY
343                       );
344                     
345                       // Caches optimisation signals
346                     
347                       logic [CVA6Cfg.VLEN-1:0] vaddr_rvalid;
348                       logic rvalid;
349                       logic ex_rvalid;
350                       logic pop_fetch;
351                     
352                       // in order to decouple the response interface from the request interface,
353                       // we need a a buffer which can hold all inflight memory fetch requests
354                       typedef struct packed {
355                         logic [CVA6Cfg.VLEN-1:0] vaddr;  // scoreboard identifier
356                       } fetchbuf_t;
357                     
358                       logic [CVA6Cfg.PLEN-1:0] paddr;
359                     
360                       // to support a throughput of one fetch per cycle, if the number of entries
361                       // of the fetch buffer is 1, implement a fall-through mode. This however
362                       // adds a combinational path between the request and response interfaces
363                       // towards the cache.
364                       localparam logic FETCHBUF_FALLTHROUGH = (CVA6Cfg.NrFetchBufEntries == 1);
365                       localparam int unsigned REQ_ID_BITS = CVA6Cfg.NrFetchBufEntries > 1 ? $clog2(
366                           CVA6Cfg.NrFetchBufEntries
367                       ) : 1;
368                     
369                       typedef logic [REQ_ID_BITS-1:0] fetchbuf_id_t;
370                     
371                       logic [CVA6Cfg.NrFetchBufEntries-1:0] fetchbuf_valid_q, fetchbuf_valid_d;
372                       logic [CVA6Cfg.NrFetchBufEntries-1:0] fetchbuf_flushed_q, fetchbuf_flushed_d;
373                       fetchbuf_t [CVA6Cfg.NrFetchBufEntries-1:0] fetchbuf_q;
374                       logic fetchbuf_empty, fetchbuf_full;
375                       fetchbuf_id_t fetchbuf_free_index;
376                       logic fetchbuf_w, fetchbuf_w_q;
377                       fetchbuf_id_t fetchbuf_windex, fetchbuf_windex_q;
378                       logic         fetchbuf_r;
379                       fetchbuf_t    fetchbuf_rdata;
380                       fetchbuf_id_t fetchbuf_rindex;
381                       fetchbuf_id_t fetchbuf_last_id_q;
382                     
383                       logic kill_req_d, kill_req_q;
384                       logic ex_s1;
385                     
386                     
387                       assign fetchbuf_full = &fetchbuf_valid_q && !(FETCHBUF_FALLTHROUGH && fetchbuf_r);
388                     
389                     
390                       //
391                       //  buffer of outstanding fetchs
392                     
393                       //  write in the first available slot
394                       generate
395                         if (CVA6Cfg.NrFetchBufEntries > 1) begin : fetchbuf_free_index_multi_gen
396                           lzc #(
397                               .WIDTH(CVA6Cfg.NrFetchBufEntries),
398                               .MODE (1'b0)                        // Count leading zeros
399                           ) lzc_windex_i (
400                               .in_i   (~fetchbuf_valid_q),
401                               .cnt_o  (fetchbuf_free_index),
402                               .empty_o(fetchbuf_empty)
403                           );
404                         end else begin : fetchbuf_free_index_single_gen
405                           assign fetchbuf_free_index = 1'b0;
406                         end
407                       endgenerate
408                     
409                       assign fetchbuf_windex = (FETCHBUF_FALLTHROUGH && fetchbuf_r) ? fetchbuf_rindex : fetchbuf_free_index;
410                     
411                       always_comb begin : fetchbuf_comb
412        1/1              fetchbuf_flushed_d = fetchbuf_flushed_q;
413        1/1              fetchbuf_valid_d   = fetchbuf_valid_q;
414                     
415                         //  In case of flush, raise the flushed flag in all slots.
416        1/1              if (flush_i) begin
417        1/1                fetchbuf_flushed_d = '1;
418                         end
                        MISSING_ELSE
419                         //  Free read entry (in the case of fall-through mode, free the entry
420                         //  only if there is no pending fetch)
421        1/1              if (fetchbuf_r && (!FETCHBUF_FALLTHROUGH || !fetchbuf_w)) begin
422        1/1                fetchbuf_valid_d[fetchbuf_rindex] = 1'b0;
423                         end
                        MISSING_ELSE
424                         // Flush on bp_valid
425        1/1              if (bp_valid) begin
426        1/1                fetchbuf_flushed_d[fetchbuf_last_id_q] = 1'b1;
427                         end
                        MISSING_ELSE
428                         // Free on exception
429                         //if (fetchbuf_w_q && ((CVA6Cfg.MmuPresent && ex_s1) || bp_valid) || kill_req_q) begin
430                         //  fetchbuf_valid_d[fetchbuf_windex_q] = 1'b0;
431                         //end
432                         //  Track a new outstanding operation in the fetch buffer
433        1/1              if (fetchbuf_w) begin
434        1/1                fetchbuf_flushed_d[fetchbuf_windex] = 1'b0;
435        1/1                fetchbuf_valid_d[fetchbuf_windex]   = 1'b1;
436                         end
                        MISSING_ELSE
437                       end
438                     
439                       always_ff @(posedge clk_i or negedge rst_ni) begin : fetchbuf_ff
440        1/1              if (!rst_ni) begin
441        1/1                fetchbuf_flushed_q <= '0;
442        1/1                fetchbuf_valid_q   <= '0;
443        1/1                fetchbuf_last_id_q <= '0;
444        1/1                fetchbuf_q         <= '0;
445                         end else begin
446        1/1                fetchbuf_flushed_q <= fetchbuf_flushed_d;
447        1/1                fetchbuf_valid_q   <= fetchbuf_valid_d;
448        1/1                if (fetchbuf_w) begin
449        1/1                  fetchbuf_last_id_q                <= fetchbuf_windex;
450        1/1                  fetchbuf_q[fetchbuf_windex].vaddr <= vaddr_d;
451                           end
                        MISSING_ELSE
452                         end
453                       end
454                     
455                     
456                     
457                       typedef enum logic [1:0] {
458                         TRANSPARENT,
459                         REGISTRED
460                       } obi_a_state_e;
461                       obi_a_state_e obi_a_state_d, obi_a_state_q;
462                     
463                     
464                       logic stall_obi, stall_translation;
465                       logic data_req, data_rvalid;
466                     
467                       assign stall_ni = spec_req_non_idempot;
468                       assign stall_obi = (obi_a_state_q == REGISTRED);  //&& !obi_load_rsp_i.gnt;
469                       assign stall_translation = CVA6Cfg.MmuPresent ? areq_o.fetch_req && (!arsp_i.fetch_valid) : 1'b0;
470                       assign stall_instr_queue = instr_queue_ready;
471                     
472                       assign ex_s1 = (CVA6Cfg.MmuPresent && arsp_i.fetch_exception.valid);
473                     
474                       // We need to flush the cache pipeline if:
475                       // 1. We mispredicted
476                       // 2. Want to flush the whole processor front-end
477                       // 3. Need to replay an instruction because the fetch-fifo was full
478                       assign kill_s1 = is_mispredict | flush_i | replay;
479                       // if we have a valid branch-prediction we need to only kill the last cache request
480                       // also if we killed the first stage we also need to kill the second stage (inclusive flush)
481                       assign kill_s2 = kill_s1 | bp_valid;
482                     
483                       assign fetch_req_o.kill_req = kill_req_q || kill_s2 || ex_s1;
484                     
485                       assign data_rvalid = fetchbuf_r && !fetchbuf_flushed_q[fetchbuf_rindex] && !kill_s2;
486                     
487                       //assign obi_vaddr_d = pop_fetch ?  : obi_vaddr_qvaddr_d;
488                       assign vaddr_d = (pop_fetch || kill_s2) ? npc_fetch_address : vaddr_q;
489                       assign fetch_req_o.vaddr = npc_fetch_address;
490                       assign paddr = CVA6Cfg.MmuPresent ? arsp_i.fetch_paddr : npc_fetch_address;
491                     
492                       assign data_req = (CVA6Cfg.MmuPresent ? fetchbuf_w_q && !ex_s1 && !bp_valid : fetchbuf_w);
493                     
494                       always_comb begin : p_fsm_common
495                         // default assignmen
496        1/1              kill_req_d = 1'b0;
497        1/1              fetchbuf_w = 1'b0;
498                         //response
499        1/1              vaddr_rvalid = npc_fetch_address;
500        1/1              rvalid    = 1'b0;
501        1/1              ex_rvalid = 1'b0;
502        1/1              pop_fetch = 1'b0; // release lsu_bypass fifo
503                     
504                         // REQUEST
505                         //if (instr_queue_ready) begin
506        1/1              areq_o.fetch_req = 1'b1;
507        1/1              fetch_req_o.req = 1'b1;
508        1/1              if (!CVA6Cfg.MmuPresent || fetch_rsp_i.ready) begin
509        1/1                if (stall_ni || stall_obi || !instr_queue_ready || fetchbuf_full) begin
510        1/1                  kill_req_d = CVA6Cfg.MmuPresent ? 1'b1 :  1'b0; // MmuPresent only : next cycle is s2 but we need to kill because not ready to sent tag
511                           end else begin
512        1/1                  fetchbuf_w  = !kill_s1 && !flush_i; // record request into outstanding fetch fifo and trigger OBI request
513        1/1                  pop_fetch = 1'b1;  // release lsu_bypass fifo
514                           end
515                         end
                   ==>  MISSING_ELSE
516                         //end
517                         // RETIRE FETCH
518                         // we got an rvalid and it's corresponding request was not flushed
519        1/1              if (data_rvalid) begin
520        1/1                vaddr_rvalid = fetchbuf_q[fetchbuf_rindex].vaddr;
521        1/1                rvalid    = !bp_valid && !flush_i;
522        1/1                ex_rvalid = 1'b0;
523                           // RETIRE EXCEPTION (low priority)
524        1/1              end else if (CVA6Cfg.MmuPresent && ex_s1) begin
525        unreachable        vaddr_rvalid = CVA6Cfg.MmuPresent ? fetchbuf_q[fetchbuf_windex_q].vaddr : npc_fetch_address;
526        unreachable        rvalid    = !bp_valid && !flush_i;
527        unreachable        ex_rvalid = 1'b1;
528        unreachable        pop_fetch = 1'b1; // release lsu_bypass fifo
529                         end
                        MISSING_ELSE
530                     
531                       end
532                     
533                       // ---------------
534                       // Retire Load
535                       // ---------------
536                       assign fetchbuf_rindex = (CVA6Cfg.NrFetchBufEntries > 1) ? fetchbuf_id_t'(obi_fetch_rsp_i.r.rid) : 1'b0;
537                       assign fetchbuf_rdata = fetchbuf_q[fetchbuf_rindex];
538                     
539                       //  read the pending fetch buffer
540                       assign fetchbuf_r = obi_fetch_rsp_i.rvalid;
541                     
542                     
543                       //default obi state registred
544                       assign obi_fetch_req_o.reqpar = !obi_fetch_req_o.req;
545                       assign obi_fetch_req_o.a.addr = {
546                         obi_a_state_q == TRANSPARENT ? paddr[CVA6Cfg.PLEN-1:CVA6Cfg.FETCH_ALIGN_BITS] : paddr_q[CVA6Cfg.PLEN-1:CVA6Cfg.FETCH_ALIGN_BITS],
547                         {CVA6Cfg.FETCH_ALIGN_BITS{1'b0}}
548                       };
549                       assign obi_fetch_req_o.a.we = '0;
550                       assign obi_fetch_req_o.a.be = '1;
551                       assign obi_fetch_req_o.a.wdata = '0;
552                       assign obi_fetch_req_o.a.aid = (!CVA6Cfg.MmuPresent && (obi_a_state_q == TRANSPARENT)) ? fetchbuf_windex : fetchbuf_windex_q;
553                       assign obi_fetch_req_o.a.a_optional.auser = '0;
554                       assign obi_fetch_req_o.a.a_optional.wuser = '0;
555                       assign obi_fetch_req_o.a.a_optional.atop = '0;
556                       assign obi_fetch_req_o.a.a_optional.memtype[0] = '0;
557                       assign obi_fetch_req_o.a.a_optional.memtype[1]= (!CVA6Cfg.MmuPresent && (obi_a_state_q == TRANSPARENT)) ? paddr_is_cacheable : paddr_is_cacheable_q;
558                       assign obi_fetch_req_o.a.a_optional.mid = '0;
559                       assign obi_fetch_req_o.a.a_optional.prot[0] = '0;
560                       assign obi_fetch_req_o.a.a_optional.prot[2:1] = 2'b11;
561                       assign obi_fetch_req_o.a.a_optional.dbg = '0;
562                       assign obi_fetch_req_o.a.a_optional.achk = '0;
563                     
564                       assign obi_fetch_req_o.rready = '1;  //always ready
565                       assign obi_fetch_req_o.rreadypar = '0;
566                     
567                     
568                     
569                     
570                       always_comb begin : p_fsm_obi_a
571                         // default assignment
572        1/1              obi_a_state_d = obi_a_state_q;
573        1/1              obi_fetch_req_o.req    = 1'b0;
574                     
575        1/1              unique case (obi_a_state_q)
576                           TRANSPARENT: begin
577        1/1                  if (data_req) begin
578        1/1                    obi_fetch_req_o.req = 1'b1;
579        1/1                    if (!obi_fetch_rsp_i.gnt) begin
580        1/1                      obi_a_state_d = REGISTRED;
581                               end
                        MISSING_ELSE
582                             end
                        MISSING_ELSE
583                           end
584                     
585                           REGISTRED: begin
586        1/1                  obi_fetch_req_o.req = 1'b1;
587        1/1                  if (obi_fetch_rsp_i.gnt) begin
588        1/1                    obi_a_state_d = TRANSPARENT;
589                             end
                        MISSING_ELSE
590                           end
591                     
592                           default: begin
593                             // we should never get here
594        1/1                  obi_a_state_d = TRANSPARENT;
595                           end
596                         endcase
597                       end
598                     
599                       // latch physical address for the tag cycle (one cycle after applying the index)
600                       always_ff @(posedge clk_i or negedge rst_ni) begin
601        1/1              if (~rst_ni) begin
602        1/1                obi_a_state_q <= TRANSPARENT;
603        1/1                paddr_q <= '0;
604        1/1                paddr_is_cacheable_q <= '0;
605        1/1                kill_req_q <= '0;
606        1/1                fetchbuf_windex_q <= '0;
607        1/1                fetchbuf_w_q <= '0;
608        1/1                vaddr_q <= '0;
609                         end else begin
610        1/1                if (obi_a_state_q == TRANSPARENT) begin
611        1/1                  paddr_q <= paddr;
612        1/1                  paddr_is_cacheable_q <= paddr_is_cacheable;
613                           end
                        MISSING_ELSE
614        1/1                obi_a_state_q <= obi_a_state_d;
615        1/1                kill_req_q <= kill_req_d;
616                           //if (!ex_s1) begin
617        1/1                fetchbuf_windex_q <= fetchbuf_windex;
618        1/1                fetchbuf_w_q <= fetchbuf_w;
619                           //end
620        1/1                vaddr_q <= vaddr_d;
621                         end
622                       end
623                     
624                       // Update Control Flow Predictions
625                       bht_update_t bht_update;
626                       btb_update_t btb_update;
627                     
628                       logic speculative_q, speculative_d;
629                       assign speculative_d = (speculative_q && !resolved_branch_i.valid || |is_branch || |is_return || |is_jalr) && !flush_i;
630                     
631                       assign spec_req_non_idempot = CVA6Cfg.NonIdemPotenceEn ? speculative_d && paddr_nonidempotent : 1'b0;
632                     
633                     
634                       assign bht_update.valid = resolved_branch_i.valid
635                                                     & (resolved_branch_i.cf_type == ariane_pkg::Branch);
636                       assign bht_update.pc = resolved_branch_i.pc;
637                       assign bht_update.taken = resolved_branch_i.is_taken;
638                       // only update mispredicted branches e.g. no returns from the RAS
639                       assign btb_update.valid = resolved_branch_i.is_mispredict
640                                                     & (resolved_branch_i.cf_type == ariane_pkg::JumpR);
641                       assign btb_update.pc = resolved_branch_i.pc;
642                       assign btb_update.target_address = resolved_branch_i.target_address;
643                     
644                       // -------------------
645                       // Next PC
646                       // -------------------
647                       // next PC (NPC) can come from (in order of precedence):
648                       // 0. Default assignment/replay instruction
649                       // 1. Branch Predict taken
650                       // 2. Control flow change request (misprediction)
651                       // 3. Return from environment call
652                       // 4. Exception/Interrupt
653                       // 5. Pipeline Flush because of CSR side effects
654                       // Mis-predict handling is a little bit different
655                       // select PC a.k.a PC Gen
656                       always_comb begin : npc_select
657                         automatic logic [CVA6Cfg.VLEN-1:0] fetch_address;
658                         // check whether we come out of reset
659                         // this is a workaround. some tools have issues
660                         // having boot_addr_i in the asynchronous
661                         // reset assignment to npc_q, even though
662                         // boot_addr_i will be assigned a constant
663                         // on the top-level.
664        1/1              if (npc_rst_load_q) begin
665        1/1                npc_d         = boot_addr_i;
666        1/1                fetch_address = boot_addr_i;
667                         end else begin
668        1/1                fetch_address = npc_q;
669                           // keep stable by default
670        1/1                npc_d         = npc_q;
671                         end
672                         // 0. Branch Prediction
673        1/1              if (bp_valid) begin
674        1/1                fetch_address = predict_address;
675        1/1                npc_d = predict_address;
676                         end
                        MISSING_ELSE
677                         // 1. Default assignment
678        1/1              if (pop_fetch) begin
679        1/1                npc_d = {
680                             fetch_address[CVA6Cfg.VLEN-1:CVA6Cfg.FETCH_ALIGN_BITS] + 1, {CVA6Cfg.FETCH_ALIGN_BITS{1'b0}}
681                           };
682                         end
                        MISSING_ELSE
683                         // 2. Replay instruction fetch
684        1/1              if (replay) begin
685        1/1                npc_d = replay_addr;
686                         end
                        MISSING_ELSE
687                         // 3. Control flow change request
688        1/1              if (is_mispredict) begin
689        1/1                npc_d = resolved_branch_i.target_address;
690                         end
                        MISSING_ELSE
691                         // 4. Return from environment call
692        1/1              if (eret_i) begin
693        1/1                npc_d = epc_i;
694                         end
                        MISSING_ELSE
695                         // 5. Exception/Interrupt
696        1/1              if (ex_valid_i) begin
697        1/1                npc_d = trap_vector_base_i;
698                         end
                        MISSING_ELSE
699                         // 6. Pipeline Flush because of CSR side effects
700                         // On a pipeline flush start fetching from the next address
701                         // of the instruction in the commit stage
702                         // we either came here from a flush request of a CSR instruction or AMO,
703                         // so as CSR or AMO instructions do not exist in a compressed form
704                         // we can unconditionally do PC + 4 here
705                         // or if the commit stage is halted, just take the current pc of the
706                         // instruction in the commit stage
707                         // IMPROVEMENT: This adder can at least be merged with the one in the csr_regfile stage
708        1/1              if (set_pc_commit_i) begin
709        1/1                npc_d = pc_commit_i + (halt_i ? '0 : {{CVA6Cfg.VLEN - 3{1'b0}}, 3'b100});
710                         end
                        MISSING_ELSE
711                         // 7. Debug
712                         // enter debug on a hard-coded base-address
713        1/1              if (CVA6Cfg.DebugEn && set_debug_pc_i)
714        unreachable        npc_d = CVA6Cfg.DmBaseAddress[CVA6Cfg.VLEN-1:0] + CVA6Cfg.HaltAddress[CVA6Cfg.VLEN-1:0];
                        MISSING_ELSE
715        1/1              npc_fetch_address = fetch_address;
716                       end
717                     
718                       logic [CVA6Cfg.FETCH_WIDTH-1:0] fetch_data;
719                       logic fetch_valid_d;
720                     
721                       // re-align the cache line
722                       assign fetch_data = ex_rvalid && CVA6Cfg.MmuPresent ? '0 : obi_fetch_rsp_i.r.rdata >> {shamt, 4'b0};
723                       assign fetch_valid_d = rvalid;
724                       assign fetch_vaddr_d = vaddr_rvalid;
725                     
726                       always_ff @(posedge clk_i or negedge rst_ni) begin
727        1/1              if (!rst_ni) begin
728        1/1                npc_rst_load_q   <= 1'b1;
729        1/1                npc_q            <= '0;
730        1/1                speculative_q    <= '0;
731        1/1                fetch_data_q     <= '0;
732        1/1                fetch_valid_q    <= 1'b0;
733        1/1                fetch_vaddr_q    <= 'b0;
734        1/1                fetch_gpaddr_q   <= 'b0;
735        1/1                fetch_tinst_q    <= 'b0;
736        1/1                fetch_gva_q      <= 1'b0;
737        1/1                fetch_ex_valid_q <= ariane_pkg::FE_NONE;
738        1/1                btb_q            <= '0;
739        1/1                bht_q            <= '0;
740                         end else begin
741        1/1                npc_rst_load_q <= 1'b0;
742        1/1                npc_q <= npc_d;
743        1/1                speculative_q <= speculative_d;
744        1/1                fetch_valid_q <= fetch_valid_d;
745        1/1                if (fetch_valid_d) begin
746        1/1                  fetch_data_q  <= fetch_data;
747        1/1                  fetch_vaddr_q <= fetch_vaddr_d;
748        1/1                  if (CVA6Cfg.RVH) begin
749        unreachable            fetch_gpaddr_q <= arsp_i.fetch_exception.tval2[CVA6Cfg.GPLEN-1:0];
750        unreachable            fetch_tinst_q  <= arsp_i.fetch_exception.tinst;
751        unreachable            fetch_gva_q    <= arsp_i.fetch_exception.gva;
752                             end else begin
753        1/1                    fetch_gpaddr_q <= 'b0;
754        1/1                    fetch_tinst_q  <= 'b0;
755        1/1                    fetch_gva_q    <= 1'b0;
756                             end
757                     
758                             // Map the only three exceptions which can occur in the frontend to a two bit enum
759        1/1                  if (CVA6Cfg.MmuPresent && arsp_i.fetch_exception.cause == riscv::INSTR_GUEST_PAGE_FAULT) begin
760        unreachable            fetch_ex_valid_q <= ariane_pkg::FE_INSTR_GUEST_PAGE_FAULT;
761        1/1                  end else if (CVA6Cfg.MmuPresent && arsp_i.fetch_exception.cause == riscv::INSTR_PAGE_FAULT) begin
762        unreachable            fetch_ex_valid_q <= ariane_pkg::FE_INSTR_PAGE_FAULT;
763        1/1                  end else if (CVA6Cfg.NrPMPEntries != 0 && arsp_i.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT) begin
764        unreachable            fetch_ex_valid_q <= ariane_pkg::FE_INSTR_ACCESS_FAULT;
765                             end else begin
766        1/1                    fetch_ex_valid_q <= ariane_pkg::FE_NONE;
767                             end
768                             // save the uppermost prediction
769        1/1                  btb_q <= btb_prediction[CVA6Cfg.INSTR_PER_FETCH-1];
770        1/1                  bht_q <= bht_prediction[CVA6Cfg.INSTR_PER_FETCH-1];
771                           end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : frontend

               Total   Covered  Percent
Conditions        131      129    98.47
Logical           131      129    98.47
Non-Logical         0        0
Event               0        0

 LINE       279
 EXPRESSION (ras_predict.valid & instr_queue_consumed[i])
             --------1--------   -----------2-----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       290
 EXPRESSION (rvi_branch[i] & bht_prediction_shifted[i].taken)
             ------1------   ---------------2---------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       291
 EXPRESSION (rvc_branch[i] & bht_prediction_shifted[i].taken)
             ------1------   ---------------2---------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       295
 EXPRESSION (rvi_branch[i] & rvi_imm[i][(32'b00000000000000000000000000100000 - 1)])
             ------1------   ---------------------------2--------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       296
 EXPRESSION (rvc_branch[i] & rvc_imm[i][(32'b00000000000000000000000000100000 - 1)])
             ------1------   ---------------------------2--------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       298
 EXPRESSION (taken_rvi_cf[i] || taken_rvc_cf[i])
             -------1-------    -------2-------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       309
 EXPRESSION (rvc_call[i] ? 2 : 4)
             -----1-----

-1- Status
 0  Covered
 1  Covered

 LINE       312
 EXPRESSION (taken_rvc_cf[i] || taken_rvi_cf[i])
             -------1-------    -------2-------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       313
 EXPRESSION (taken_rvc_cf[i] ? rvc_imm[i] : rvi_imm[i])
             -------1-------

-1- Status
 0  Covered
 1  Covered

 LINE       324
 EXPRESSION (((cf_type[i] != NoCF) & (cf_type[i] != Return)) | ((cf_type[i] == Return) & ras_predict.valid))
             -----------------------1-----------------------   ----------------------2---------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       324
 SUB-EXPRESSION ((cf_type[i] != NoCF) & (cf_type[i] != Return))
                 ----------1---------   -----------2----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       324
 SUB-EXPRESSION (cf_type[i] != NoCF)
                ----------1---------

-1- Status
 0  Covered
 1  Covered

 LINE       324
 SUB-EXPRESSION (cf_type[i] != Return)
                -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       324
 SUB-EXPRESSION ((cf_type[i] == Return) & ras_predict.valid)
                 -----------1----------   --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       324
 SUB-EXPRESSION (cf_type[i] == Return)
                -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       421
 EXPRESSION (fetchbuf_r && (((!FETCHBUF_FALLTHROUGH)) || ((!fetchbuf_w))))
             -----1----    -----------------------2----------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       421
 SUB-EXPRESSION (((!FETCHBUF_FALLTHROUGH)) || ((!fetchbuf_w)))
                 ------------1------------    -------2-------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       509
 EXPRESSION (stall_ni || stall_obi || ((!instr_queue_ready)) || fetchbuf_full)
             ----1---    ----2----    -----------3----------    ------4------

-1- -2- -3- -4- Status
 0   0   0   0  Covered
 0   0   0   1  Covered
 0   0   1   0  Covered
 0   1   0   0  Covered
 1   0   0   0  Unreachable

 LINE       512
 EXPRESSION (((!kill_s1)) && ((!flush_i)))
             ------1-----    ------2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       521
 EXPRESSION (((!bp_valid)) && ((!flush_i)))
             ------1------    ------2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       526
 EXPRESSION (((!bp_valid)) && ((!flush_i)))
             ------1------    ------2-----

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       610
 EXPRESSION (obi_a_state_q == TRANSPARENT)
            ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       709
 EXPRESSION (halt_i ? '0 : ({{(32'b00000000000000000000000000100000 - 3) {1'b0}}, 3'b100}))
             ---1--

-1- Status
 0  Covered
 1  Not Covered

 LINE       387
 EXPRESSION (((&fetchbuf_valid_q)) && ( ! (FETCHBUF_FALLTHROUGH && fetchbuf_r) ))
             ----------1----------    ---------------------2--------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       387
 SUB-EXPRESSION ( ! (FETCHBUF_FALLTHROUGH && fetchbuf_r) )
                    ------------------1-----------------

-1- Status
 0  Covered
 1  Covered

 LINE       387
 SUB-EXPRESSION (FETCHBUF_FALLTHROUGH && fetchbuf_r)
                 ----------1---------    -----2----

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       409
 EXPRESSION ((FETCHBUF_FALLTHROUGH && fetchbuf_r) ? fetchbuf_rindex : fetchbuf_free_index)
             ------------------1-----------------

-1- Status
 0  Covered
 1  Covered

 LINE       409
 SUB-EXPRESSION (FETCHBUF_FALLTHROUGH && fetchbuf_r)
                 ----------1---------    -----2----

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       468
 EXPRESSION (obi_a_state_q == REGISTRED)
            --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       478
 EXPRESSION (is_mispredict | flush_i | replay)
             ------1------   ---2---   ---3--

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Covered
 0   1   0  Covered
 1   0   0  Covered

 LINE       481
 EXPRESSION (kill_s1 | bp_valid)
             ---1---   ----2---

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       483
 EXPRESSION (kill_req_q || kill_s2 || ex_s1)
             -----1----    ---2---    --3--

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Unreachable
 0   1   0  Covered
 1   0   0  Unreachable

 LINE       485
 EXPRESSION (fetchbuf_r && ((!fetchbuf_flushed_q[fetchbuf_rindex])) && ((!kill_s2)))
             -----1----    --------------------2-------------------    ------3-----

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       488
 EXPRESSION ((pop_fetch || kill_s2) ? npc_fetch_address : vaddr_q)
             -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       488
 SUB-EXPRESSION (pop_fetch || kill_s2)
                 ----1----    ---2---

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       545
 SUB-EXPRESSION 
 Number  Term
      1  (obi_a_state_q == TRANSPARENT) ? paddr[32'b00000000000000000000000000100001:32'b00000000000000000000000000000010] : paddr_q[32'b00000000000000000000000000100001:32'b00000000000000000000000000000010])

-1- Status
 0  Covered
 1  Covered

 LINE       545
 SUB-EXPRESSION (obi_a_state_q == TRANSPARENT)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       552
 EXPRESSION ((((!1'b0)) && (obi_a_state_q == TRANSPARENT)) ? fetchbuf_windex : fetchbuf_windex_q)
             ----------------------1----------------------

-1- Status
 0  Covered
 1  Covered

 LINE       552
 SUB-EXPRESSION (((!1'b0)) && (obi_a_state_q == TRANSPARENT))
                 ----1----    ---------------2--------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       552
 SUB-EXPRESSION (obi_a_state_q == TRANSPARENT)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       557
 EXPRESSION ((((!1'b0)) && (obi_a_state_q == TRANSPARENT)) ? paddr_is_cacheable : paddr_is_cacheable_q)
             ----------------------1----------------------

-1- Status
 0  Covered
 1  Covered

 LINE       557
 SUB-EXPRESSION (((!1'b0)) && (obi_a_state_q == TRANSPARENT))
                 ----1----    ---------------2--------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       557
 SUB-EXPRESSION (obi_a_state_q == TRANSPARENT)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       629
 EXPRESSION (((speculative_q && ((!resolved_branch_i.valid))) || ((|is_branch)) || ((|is_return)) || ((|is_jalr))) && ((!flush_i)))
             --------------------------------------------------1--------------------------------------------------    ------2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       629
 SUB-EXPRESSION ((speculative_q && ((!resolved_branch_i.valid))) || ((|is_branch)) || ((|is_return)) || ((|is_jalr)))
                 -----------------------1-----------------------    -------2------    -------3------    ------4-----

-1- -2- -3- -4- Status
 0   0   0   0  Covered
 0   0   0   1  Covered
 0   0   1   0  Covered
 0   1   0   0  Covered
 1   0   0   0  Covered

 LINE       629
 SUB-EXPRESSION (speculative_q && ((!resolved_branch_i.valid)))
                 ------1------    --------------2-------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       634
 EXPRESSION (resolved_branch_i.valid & (resolved_branch_i.cf_type == Branch))
             -----------1-----------   ------------------2------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       634
 SUB-EXPRESSION (resolved_branch_i.cf_type == Branch)
                ------------------1------------------

-1- Status
 0  Covered
 1  Covered

 LINE       639
 EXPRESSION (resolved_branch_i.is_mispredict & (resolved_branch_i.cf_type == JumpR))
             ---------------1---------------   ------------------2-----------------

-1- -2- Status
 0   1  Not Covered
 1   0  Covered
 1   1  Covered

 LINE       639
 SUB-EXPRESSION (resolved_branch_i.cf_type == JumpR)
                ------------------1-----------------

-1- Status
 0  Covered
 1  Covered

 LINE       201
 EXPRESSION (serving_unaligned ? bht_q : bht_prediction[addr[0][$clog2(32'b00000000000000000000000000000010):1]])
             --------1--------

-1- Status
 0  Covered
 1  Covered

 LINE       204
 EXPRESSION (serving_unaligned ? btb_q : btb_prediction[addr[0][$clog2(32'b00000000000000000000000000000010):1]])
             --------1--------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
 99.24 100.00  98.47 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.70 100.00  99.39 --     


Module : 

SCORE  LINE   COND   ASSERT NAME     
 99.24 100.00  98.47 --     frontend 


Parent : 

SCORE  LINE   COND   ASSERT NAME                               
100.00 100.00 100.00 --     cva6_only_pipeline.i_cva6_pipeline 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                           
100.00 100.00 100.00 --     bht_gen.i_bht                  
100.00 100.00 100.00 --     gen_instr_scan[0].i_instr_scan 
100.00 100.00 100.00 --     i_instr_queue                  
100.00 100.00 100.00 --     i_instr_realign                
100.00 100.00 100.00 --     ras_gen.i_ras                  



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ariane_regfile
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/ariane_regfile_ff.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                                                  
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.gen_asic_regfile.i_ariane_regfile 



-------------------------------------------------------------------------------
Line Coverage for Module : ariane_regfile

             Line No.   Total   Covered  Percent
TOTAL                       13       13   100.00
ALWAYS             53        0        0
ALWAYS             53        5        5   100.00
ALWAYS             63        8        8   100.00

52                        always_comb begin : we_decoder
53         1/1              for (int unsigned j = 0; j < CVA6Cfg.NrCommitPorts; j++) begin
54         1/1                for (int unsigned i = 0; i < NUM_WORDS; i++) begin
55         2/2                  if (waddr_i[j] == i) we_dec[j][i] = we_i[j];
56         1/1                  else we_dec[j][i] = 1'b0;
57                            end
58                          end
59                        end
60                      
61                        // loop from 1 to NUM_WORDS-1 as R0 is nil
62                        always_ff @(posedge clk_i, negedge rst_ni) begin : register_write_behavioral
63         1/1              if (~rst_ni) begin
64         1/1                mem <= '{default: '0};
65                          end else begin
66         1/1                for (int unsigned j = 0; j < CVA6Cfg.NrCommitPorts; j++) begin
67         1/1                  for (int unsigned i = 0; i < NUM_WORDS; i++) begin
68         1/1                    if (we_dec[j][i]) begin
69         1/1                      mem[i] <= wdata_i[j];
70                                end
                        MISSING_ELSE
71                              end
72         1/1                  if (ZERO_REG_ZERO) begin
73         1/1                    mem[0] <= '0;
74                              end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : ariane_regfile

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       55
 EXPRESSION (waddr_i[j] == i)
            --------1--------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.gen_asic_regfile.i_ariane_regfile
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME           
100.00 100.00 100.00 --     ariane_regfile 


Parent : 

SCORE  LINE   COND   ASSERT NAME                  
100.00 100.00 100.00 --     i_issue_read_operands 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : issue_read_operands
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/issue_read_operands.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands 



-------------------------------------------------------------------------------
Line Coverage for Module : issue_read_operands

             Line No.   Total   Covered  Percent
TOTAL                      192      192   100.00
ALWAYS            284       15       15   100.00
ALWAYS            382       12       12   100.00
ALWAYS            417       11       11   100.00
ALWAYS            639       22       22   100.00
ALWAYS            722       19       19   100.00
ALWAYS            776       28       28   100.00
ALWAYS            836       19       19   100.00
ALWAYS            861       11       11   100.00
ALWAYS            880        5        5   100.00
ALWAYS            891        9        9   100.00
ALWAYS            928        0        0
ALWAYS            928       11       11   100.00
ALWAYS           1024        2        2   100.00
ALWAYS           1107       11       11   100.00
ALWAYS           1130       17       17   100.00
INITIAL          1158        0        0
INITIAL          1173        0        0

283                       always_comb begin : structural_hazards
284        1/1              fus_busy = '0;
285                         // CVXIF is always ready to try a new transaction on 1st issue port
286                         // If a transaction is already pending then we stall until the transaction is done.(issue_ack_o[0] = 0)
287                         // Since we can not have two CVXIF instruction on 1st issue port, CVXIF is always ready for the pending instruction.
288        1/1              if (!flu_ready_i) begin
289        1/1                fus_busy[0].alu = 1'b1;
290        1/1                fus_busy[0].ctrl_flow = 1'b1;
291        1/1                fus_busy[0].csr = 1'b1;
292        1/1                fus_busy[0].mult = 1'b1;
293                         end
                        MISSING_ELSE
294                     
295                         // after a multiplication was issued we can only issue another multiplication
296                         // otherwise we will get contentions on the fixed latency bus
297        1/1              if (|mult_valid_q) begin
298        1/1                fus_busy[0].alu = 1'b1;
299        1/1                fus_busy[0].ctrl_flow = 1'b1;
300        1/1                fus_busy[0].csr = 1'b1;
301                         end
                        MISSING_ELSE
302                     
303        1/1              if (CVA6Cfg.FpPresent && !fpu_ready_i) begin
304        unreachable        fus_busy[0].fpu = 1'b1;
305        unreachable        fus_busy[0].fpu_vec = 1'b1;
306        unreachable        if (CVA6Cfg.SuperscalarEn) fus_busy[0].alu2 = 1'b1;
                   ==>  MISSING_ELSE
307                         end
                        MISSING_ELSE
308                     
309        1/1              if (!lsu_ready_i) begin
310        1/1                fus_busy[0].load  = 1'b1;
311        1/1                fus_busy[0].store = 1'b1;
312                         end
                        MISSING_ELSE
313                     
314        1/1              if (CVA6Cfg.SuperscalarEn) begin
315        unreachable        fus_busy[1] = fus_busy[0];
316                     
317                           // Never issue CSR instruction on second issue port.
318        unreachable        fus_busy[1].csr = 1'b1;
319                           // Never issue CVXIF instruction on second issue port.
320        unreachable        fus_busy[1].cvxif = 1'b1;
321                     
322        unreachable        unique case (issue_instr_i[0].fu)
323        unreachable          NONE: fus_busy[1].none = 1'b1;
324                             CTRL_FLOW: begin
325        unreachable            if (CVA6Cfg.SpeculativeSb) begin
326                                 // Issue speculative instruction, will be removed on BMISS
327        unreachable              fus_busy[1].alu = 1'b1;
328        unreachable              fus_busy[1].ctrl_flow = 1'b1;
329        unreachable              fus_busy[1].csr = 1'b1;
330                                 // Speculative non-idempotent loads are not supported yet
331        unreachable              fus_busy[1].load = 1'b1;
332                                 // The store buffer cannot be partially flushed yet
333        unreachable              fus_busy[1].store = 1'b1;
334                               end else begin
335                                 // There are no branch misses on a JAL
336        unreachable              if (issue_instr_i[0].op == ariane_pkg::ADD) begin
337        unreachable                fus_busy[1].alu = 1'b1;
338        unreachable                fus_busy[1].ctrl_flow = 1'b1;
339        unreachable                fus_busy[1].csr = 1'b1;
340                                 end else begin
341                                   // Control hazard
342        unreachable                fus_busy[1] = '1;
343                                 end
344                               end
345                             end
346                             ALU: begin
347        unreachable            if (CVA6Cfg.SuperscalarEn && !fus_busy[0].alu2) begin
348        unreachable              fus_busy[1].alu2 = 1'b1;
349                                 // TODO is there a minimum float execution time?
350                                 // If so we could issue FPU & ALU2 the same cycle
351        unreachable              fus_busy[1].fpu = 1'b1;
352        unreachable              fus_busy[1].fpu_vec = 1'b1;
353                               end else begin
354        unreachable              fus_busy[1].alu = 1'b1;
355        unreachable              fus_busy[1].ctrl_flow = 1'b1;
356        unreachable              fus_busy[1].csr = 1'b1;
357                               end
358                             end
359                             CSR: begin
360                               // Control hazard
361        unreachable            fus_busy[1] = '1;
362                             end
363        unreachable          MULT: fus_busy[1].mult = 1'b1;
364                             FPU, FPU_VEC: begin
365        unreachable            fus_busy[1].fpu = 1'b1;
366        unreachable            fus_busy[1].fpu_vec = 1'b1;
367                             end
368                             LOAD, STORE: begin
369        unreachable            fus_busy[1].load  = 1'b1;
370        unreachable            fus_busy[1].store = 1'b1;
371                             end
372        unreachable          CVXIF: ;
373        unreachable          default: ;
374                           endcase
375                         end
                        MISSING_ELSE
376                       end
377                     
378                       // select the right busy signal
379                       // this obviously depends on the functional unit we need
380                       for (genvar i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
381                         always_comb begin
382        1/1                unique case (issue_instr_i[i].fu)
383        1/1                  NONE: fu_busy[i] = fus_busy[i].none;
384                             ALU: begin
385        1/1                    if (CVA6Cfg.SuperscalarEn && !fus_busy[i].alu2) begin
386        unreachable              fu_busy[i] = fus_busy[i].alu2;
387                               end else begin
388        1/1                      fu_busy[i] = fus_busy[i].alu;
389                               end
390                             end
391        1/1                  CTRL_FLOW: fu_busy[i] = fus_busy[i].ctrl_flow;
392        1/1                  CSR: fu_busy[i] = fus_busy[i].csr;
393        1/1                  MULT: fu_busy[i] = fus_busy[i].mult;
394        1/1                  LOAD: fu_busy[i] = fus_busy[i].load;
395        1/1                  STORE: fu_busy[i] = fus_busy[i].store;
396        1/1                  CVXIF: fu_busy[i] = fus_busy[i].cvxif;
397                             default:
398        1/1                  if (CVA6Cfg.FpPresent) begin
399        unreachable            unique case (issue_instr_i[i].fu)
400        unreachable              FPU: fu_busy[i] = fus_busy[i].fpu;
401        unreachable              FPU_VEC: fu_busy[i] = fus_busy[i].fpu_vec;
402        unreachable              default: fu_busy[i] = 1'b0;
403                               endcase
404                             end else begin
405        1/1                    fu_busy[i] = 1'b0;
406                             end
407                           endcase
408                         end
409                       end
410                     
411                       // -------------------
412                       // RD clobber process
413                       // -------------------
414                       // rd_clobber output: output currently clobbered destination registers
415                     
416                       always_comb begin : clobber_assign
417        1/1              gpr_clobber_vld = '0;
418        1/1              fpr_clobber_vld = '0;
419                     
420                         // default (highest entry hast lowest prio in arbiter tree below)
421        1/1              clobber_fu[CVA6Cfg.NR_SB_ENTRIES] = ariane_pkg::NONE;
422        1/1              for (int unsigned i = 0; i < 2 ** ariane_pkg::REG_ADDR_SIZE; i++) begin
423        1/1                gpr_clobber_vld[i][CVA6Cfg.NR_SB_ENTRIES] = 1'b1;
424        1/1                fpr_clobber_vld[i][CVA6Cfg.NR_SB_ENTRIES] = 1'b1;
425                         end
426                     
427                         // check for all valid entries and set the clobber accordingly
428                     
429        1/1              for (int unsigned i = 0; i < CVA6Cfg.NR_SB_ENTRIES; i++) begin
430        1/1                gpr_clobber_vld[fwd_i.sbe[i].rd][i] = fwd_i.still_issued[i] & ~(CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
431                               fwd_i.sbe[i].op));
432        1/1                fpr_clobber_vld[fwd_i.sbe[i].rd][i] = fwd_i.still_issued[i] & (CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
433                               fwd_i.sbe[i].op));
434        1/1                clobber_fu[i] = fwd_i.sbe[i].fu;
435                         end
436                     
437                         // GPR[0] is always free
438        1/1              gpr_clobber_vld[0] = '0;
439                       end
440                     
441                       for (genvar k = 0; k < 2 ** ariane_pkg::REG_ADDR_SIZE; k++) begin : gen_sel_clobbers
442                         // get fu that is going to clobber this register (there should be only one)
443                         rr_arb_tree #(
444                             .NumIn(CVA6Cfg.NR_SB_ENTRIES + 1),
445                             .DataType(ariane_pkg::fu_t),
446                             .ExtPrio(1'b1),
447                             .AxiVldRdy(1'b1)
448                         ) i_sel_gpr_clobbers (
449                             .clk_i  (clk_i),
450                             .rst_ni (rst_ni),
451                             .flush_i(1'b0),
452                             .rr_i   ('0),
453                             .req_i  (gpr_clobber_vld[k]),
454                             .gnt_o  (),
455                             .data_i (clobber_fu),
456                             .gnt_i  (1'b1),
457                             .req_o  (),
458                             .data_o (rd_clobber_gpr[k]),
459                             .idx_o  ()
460                         );
461                         if (CVA6Cfg.FpPresent) begin
462                           rr_arb_tree #(
463                               .NumIn(CVA6Cfg.NR_SB_ENTRIES + 1),
464                               .DataType(ariane_pkg::fu_t),
465                               .ExtPrio(1'b1),
466                               .AxiVldRdy(1'b1)
467                           ) i_sel_fpr_clobbers (
468                               .clk_i  (clk_i),
469                               .rst_ni (rst_ni),
470                               .flush_i(1'b0),
471                               .rr_i   ('0),
472                               .req_i  (fpr_clobber_vld[k]),
473                               .gnt_o  (),
474                               .data_i (clobber_fu),
475                               .gnt_i  (1'b1),
476                               .req_o  (),
477                               .data_o (rd_clobber_fpr[k]),
478                               .idx_o  ()
479                           );
480                         end else begin
481                           assign rd_clobber_fpr[k] = NONE;
482                         end
483                       end
484                     
485                       // ----------------------------------
486                       // Read Operands (a.k.a forwarding)
487                       // ----------------------------------
488                       // read operand interface: same logic as register file
489                     
490                       // WB ports have higher prio than entries
491                       for (genvar i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
492                         for (genvar k = 0; unsigned'(k) < CVA6Cfg.NrWbPorts; k++) begin : gen_rs_wb
493                     
494                           assign rs1_fwd_req[i][k] = (fwd_i.sbe[fwd_i.wb[k].trans_id].rd == issue_instr_i[i].rs1) & (fwd_i.still_issued[fwd_i.wb[k].trans_id]) & fwd_i.wb[k].valid & (~fwd_i.wb[k].ex_valid) & ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
495                               fwd_i.sbe[fwd_i.wb[k].trans_id].op
496                           )) == (CVA6Cfg.FpPresent && ariane_pkg::is_rs1_fpr(
497                               issue_instr_i[i].op
498                           )));
499                     
500                           assign rs2_fwd_req[i][k] = (fwd_i.sbe[fwd_i.wb[k].trans_id].rd == issue_instr_i[i].rs2) & (fwd_i.still_issued[fwd_i.wb[k].trans_id]) & fwd_i.wb[k].valid & (~fwd_i.wb[k].ex_valid) & ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
501                               fwd_i.sbe[fwd_i.wb[k].trans_id].op
502                           )) == (CVA6Cfg.FpPresent && ariane_pkg::is_rs2_fpr(
503                               issue_instr_i[i].op
504                           )));
505                     
506                           assign rs3_fwd_req[i][k] = (fwd_i.sbe[fwd_i.wb[k].trans_id].rd == issue_instr_i[i].result[ariane_pkg::REG_ADDR_SIZE-1:0]) & (fwd_i.still_issued[fwd_i.wb[k].trans_id]) & fwd_i.wb[k].valid & (~fwd_i.wb[k].ex_valid) & ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
507                               fwd_i.sbe[fwd_i.wb[k].trans_id].op
508                           )) == (CVA6Cfg.FpPresent && ariane_pkg::is_imm_fpr(
509                               issue_instr_i[i].op
510                           )));
511                     
512                           assign rs_data[i][k] = fwd_i.wb[k].data;
513                         end
514                     
515                         for (genvar k = 0; unsigned'(k) < CVA6Cfg.NR_SB_ENTRIES; k++) begin : gen_rs_entries
516                     
517                           assign rs1_fwd_req[i][k+CVA6Cfg.NrWbPorts] = (fwd_i.sbe[k].rd == issue_instr_i[i].rs1) & fwd_i.still_issued[k] & fwd_i.sbe[k].valid & ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
518                               fwd_i.sbe[k].op
519                           )) == (CVA6Cfg.FpPresent && ariane_pkg::is_rs1_fpr(
520                               issue_instr_i[i].op
521                           )));
522                     
523                           assign rs2_fwd_req[i][k+CVA6Cfg.NrWbPorts] = (fwd_i.sbe[k].rd == issue_instr_i[i].rs2) & fwd_i.still_issued[k] & fwd_i.sbe[k].valid & ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
524                               fwd_i.sbe[k].op
525                           )) == (CVA6Cfg.FpPresent && ariane_pkg::is_rs2_fpr(
526                               issue_instr_i[i].op
527                           )));
528                     
529                           assign rs3_fwd_req[i][k+CVA6Cfg.NrWbPorts] = (fwd_i.sbe[k].rd == issue_instr_i[i].result[ariane_pkg::REG_ADDR_SIZE-1:0]) & fwd_i.still_issued[k] & fwd_i.sbe[k].valid & ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
530                               fwd_i.sbe[k].op
531                           )) == (CVA6Cfg.FpPresent && ariane_pkg::is_imm_fpr(
532                               issue_instr_i[i].op
533                           )));
534                     
535                           assign rs_data[i][k+CVA6Cfg.NrWbPorts] = fwd_i.sbe[k].result;
536                         end
537                     
538                         // use fixed prio here
539                         // this implicitly gives higher prio to WB ports
540                         rr_arb_tree #(
541                             .NumIn(CVA6Cfg.NR_SB_ENTRIES + CVA6Cfg.NrWbPorts),
542                             .DataWidth(CVA6Cfg.XLEN),
543                             .ExtPrio(1'b1),
544                             .AxiVldRdy(1'b1)
545                         ) i_sel_rs1 (
546                             .clk_i  (clk_i),
547                             .rst_ni (rst_ni),
548                             .flush_i(1'b0),
549                             .rr_i   ('0),
550                             .req_i  (rs1_fwd_req[i]),
551                             .gnt_o  (),
552                             .data_i (rs_data[i]),
553                             .gnt_i  (1'b1),
554                             .req_o  (rs1_available[i]),
555                             .data_o (rs1_res[i]),
556                             .idx_o  ()
557                         );
558                     
559                         rr_arb_tree #(
560                             .NumIn(CVA6Cfg.NR_SB_ENTRIES + CVA6Cfg.NrWbPorts),
561                             .DataWidth(CVA6Cfg.XLEN),
562                             .ExtPrio(1'b1),
563                             .AxiVldRdy(1'b1)
564                         ) i_sel_rs2 (
565                             .clk_i  (clk_i),
566                             .rst_ni (rst_ni),
567                             .flush_i(1'b0),
568                             .rr_i   ('0),
569                             .req_i  (rs2_fwd_req[i]),
570                             .gnt_o  (),
571                             .data_i (rs_data[i]),
572                             .gnt_i  (1'b1),
573                             .req_o  (rs2_available[i]),
574                             .data_o (rs2_res[i]),
575                             .idx_o  ()
576                         );
577                     
578                     
579                         rr_arb_tree #(
580                             .NumIn(CVA6Cfg.NR_SB_ENTRIES + CVA6Cfg.NrWbPorts),
581                             .DataWidth(CVA6Cfg.XLEN),
582                             .ExtPrio(1'b1),
583                             .AxiVldRdy(1'b1)
584                         ) i_sel_rs3 (
585                             .clk_i  (clk_i),
586                             .rst_ni (rst_ni),
587                             .flush_i(1'b0),
588                             .rr_i   ('0),
589                             .req_i  (rs3_fwd_req[i]),
590                             .gnt_o  (),
591                             .data_i (rs_data[i]),
592                             .gnt_i  (1'b1),
593                             .req_o  (rs3_available[i]),
594                             .data_o (rs3[i]),
595                             .idx_o  ()
596                         );
597                     
598                         if (CVA6Cfg.NrRgprPorts == 3) begin : gen_gp_three_port
599                           assign rs3_res[i] = rs3[i][riscv::XLEN-1:0];
600                         end else begin : gen_fp_three_port
601                           assign rs3_res[i] = rs3[i][CVA6Cfg.FLen-1:0];
602                         end
603                     
604                         assign rs1_has_raw[i] = !issue_instr_i[i].use_zimm && ((CVA6Cfg.FpPresent && is_rs1_fpr(
605                             issue_instr_i[i].op
606                         )) ? rd_clobber_fpr[issue_instr_i[i].rs1] != NONE :
607                             rd_clobber_gpr[issue_instr_i[i].rs1] != NONE);
608                     
609                         assign rs1_valid[i] = rs1_available[i] && (CVA6Cfg.FpPresent && is_rs1_fpr(
610                             issue_instr_i[i].op
611                         ) ? 1'b1 : ((rd_clobber_gpr[issue_instr_i[i].rs1] != CSR) ||
612                                     (CVA6Cfg.RVS && issue_instr_i[i].op == SFENCE_VMA)));
613                     
614                         assign rs2_has_raw[i] = ((CVA6Cfg.FpPresent && is_rs2_fpr(
615                             issue_instr_i[i].op
616                         )) ? rd_clobber_fpr[issue_instr_i[i].rs2] != NONE :
617                             rd_clobber_gpr[issue_instr_i[i].rs2] != NONE);
618                     
619                         assign rs2_valid[i] = rs2_available[i] && (CVA6Cfg.FpPresent && is_rs2_fpr(
620                             issue_instr_i[i].op
621                         ) ? 1'b1 : ((rd_clobber_gpr[issue_instr_i[i].rs2] != CSR) ||
622                                     (CVA6Cfg.RVS && issue_instr_i[i].op == SFENCE_VMA)));
623                     
624                         assign rs3_has_raw[i] = ((CVA6Cfg.FpPresent && is_imm_fpr(
625                             issue_instr_i[i].op
626                         )) ? rd_clobber_fpr[issue_instr_i[i].result[REG_ADDR_SIZE-1:0]] != NONE : 0);
627                     
628                         assign rs3_valid[i] = rs3_available[i];
629                         assign rs3_fpr[i] = (CVA6Cfg.FpPresent && ariane_pkg::is_imm_fpr(issue_instr_i[i].op));
630                     
631                       end
632                     
633                       // ---------------
634                       // Register stage
635                       // ---------------
636                       // check that all operands are available, otherwise stall
637                       // forward corresponding register
638                       always_comb begin : operands_available
639        1/1              stall_raw   = '{default: stall_i};
640        1/1              stall_rs1   = '{default: stall_i};
641        1/1              stall_rs2   = '{default: stall_i};
642        1/1              stall_rs3   = '{default: stall_i};
643                         // operand forwarding signals
644        1/1              forward_rs1 = '0;
645        1/1              forward_rs2 = '0;
646        1/1              forward_rs3 = '0;  // FPR only
647                     
648        1/1              for (int unsigned i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
649        1/1                if (rs1_has_raw[i]) begin
650        1/1                  if (rs1_valid[i]) begin
651        1/1                    forward_rs1[i] = 1'b1;
652                             end else begin  // the operand is not available -> stall
653        1/1                    stall_raw[i] = 1'b1;
654        1/1                    stall_rs1[i] = 1'b1;
655                             end
656                           end
                        MISSING_ELSE
657                     
658        1/1                if (rs2_has_raw[i]) begin
659        1/1                  if (rs2_valid[i]) begin
660        1/1                    forward_rs2[i] = 1'b1;
661                             end else begin  // the operand is not available -> stall
662        1/1                    stall_raw[i] = 1'b1;
663        1/1                    stall_rs2[i] = 1'b1;
664                             end
665                           end
                        MISSING_ELSE
666                     
667        1/1                if (CVA6Cfg.NrRgprPorts == 3 && rs3_has_raw[i] && rs3_fpr[i]) begin
668        unreachable          if (rs3_valid[i]) begin
669        unreachable            forward_rs3[i] = 1'b1;
670                             end else begin  // the operand is not available -> stall
671        unreachable            stall_raw[i] = 1'b1;
672        unreachable            stall_rs3[i] = 1'b1;
673                             end
674                           end
                        MISSING_ELSE
675                     
676        1/1                if (CVA6Cfg.CvxifEn) begin
677        1/1                  stall_raw[0] = x_transaction_rejected ? 1'b0 : stall_rs1[0] || stall_rs2[0] || (CVA6Cfg.NrRgprPorts == 3 && stall_rs3[0]);
678                           end
                   ==>  MISSING_ELSE
679                         end
680                     
681        1/1              if (CVA6Cfg.SuperscalarEn) begin
682        unreachable        if (!issue_instr_i[1].use_zimm && (!CVA6Cfg.FpPresent || (is_rs1_fpr(
683                                   issue_instr_i[1].op
684                               ) == is_rd_fpr(
685                                   issue_instr_i[0].op
686                               ))) && issue_instr_i[1].rs1 == issue_instr_i[0].rd && issue_instr_i[1].rs1 != '0) begin
687        unreachable          stall_raw[1] = 1'b1;
688                           end
                   ==>  MISSING_ELSE
689                     
690        unreachable        if ((!CVA6Cfg.FpPresent || (is_rs2_fpr(
691                                   issue_instr_i[1].op
692                               ) == is_rd_fpr(
693                                   issue_instr_i[0].op
694                               ))) && issue_instr_i[1].rs2 == issue_instr_i[0].rd && issue_instr_i[1].rs2 != '0) begin
695        unreachable          stall_raw[1] = 1'b1;
696                           end
                   ==>  MISSING_ELSE
697                     
698                           // Only check clobbered gpr for OFFLOADED instruction
699        unreachable        if ((CVA6Cfg.FpPresent && is_imm_fpr(
700                                   issue_instr_i[1].op
701                               )) ? is_rd_fpr(
702                                   issue_instr_i[0].op
703                               ) && issue_instr_i[0].rd == issue_instr_i[1].result[REG_ADDR_SIZE-1:0] :
704                                   issue_instr_i[1].op == OFFLOAD && OPERANDS_PER_INSTR == 3 ?
705                                   issue_instr_i[0].rd == issue_instr_i[1].result[REG_ADDR_SIZE-1:0] : 1'b0) begin
706        unreachable          stall_raw[1] = 1'b1;
707                           end
                   ==>  MISSING_ELSE
708                         end
                        MISSING_ELSE
709                       end
710                     
711                       // third operand from fp regfile or gp regfile if NR_RGPR_PORTS == 3
712                       if (OPERANDS_PER_INSTR == 3) begin : gen_gp_rs3
713                         assign imm_forward_rs3 = rs3_res[0];
714                       end else begin : gen_fp_rs3
715                         assign imm_forward_rs3 = {{CVA6Cfg.XLEN - CVA6Cfg.FLen{1'b0}}, rs3_res[0]};
716                       end
717                     
718                       // Forwarding/Output MUX
719                       for (genvar i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
720                         always_comb begin : forwarding_operand_select
721                           // default is regfiles (gpr or fpr)
722        1/1                fu_data_n[i].operand_a = operand_a_regfile[i];
723        1/1                fu_data_n[i].operand_b = operand_b_regfile[i];
724                     
725                           // immediates are the third operands in the store case
726                           // for FP operations, the imm field can also be the third operand from the regfile
727        1/1                if (OPERANDS_PER_INSTR == 3) begin
728        unreachable          fu_data_n[i].imm = (CVA6Cfg.FpPresent && is_imm_fpr(issue_instr_i[i].op)) ?
729                                 {{CVA6Cfg.XLEN - CVA6Cfg.FLen{1'b0}}, operand_c_regfile[i]} :
730                                 issue_instr_i[i].op == OFFLOAD ? operand_c_regfile[i] : issue_instr_i[i].result;
731                           end else begin
732        1/1                  fu_data_n[i].imm = (CVA6Cfg.FpPresent && is_imm_fpr(issue_instr_i[i].op)) ?
733                                 {{CVA6Cfg.XLEN - CVA6Cfg.FLen{1'b0}}, operand_c_regfile[i]} : issue_instr_i[i].result;
734                           end
735        1/1                fu_data_n[i].trans_id  = issue_instr_i[i].trans_id;
736        1/1                fu_data_n[i].fu        = issue_instr_i[i].fu;
737        1/1                fu_data_n[i].operation = issue_instr_i[i].op;
738        1/1                if (CVA6Cfg.RVH) begin
739        unreachable          tinst_n[i] = issue_instr_i[i].ex.tinst;
740                           end
                        MISSING_ELSE
741                     
742                           // or should we forward
743        1/1                if (forward_rs1[i]) begin
744        1/1                  fu_data_n[i].operand_a = rs1_res[i];
745                           end
                        MISSING_ELSE
746        1/1                if (forward_rs2[i]) begin
747        1/1                  fu_data_n[i].operand_b = rs2_res[i];
748                           end
                        MISSING_ELSE
749        1/1                if ((CVA6Cfg.FpPresent || (CVA6Cfg.CvxifEn && OPERANDS_PER_INSTR == 3)) && forward_rs3[i]) begin
750        unreachable          fu_data_n[i].imm = imm_forward_rs3;
751                           end
                        MISSING_ELSE
752                     
753                           // use the PC as operand a
754        1/1                if (issue_instr_i[i].use_pc) begin
755        1/1                  fu_data_n[i].operand_a = {
756                               {CVA6Cfg.XLEN - CVA6Cfg.VLEN{issue_instr_i[i].pc[CVA6Cfg.VLEN-1]}}, issue_instr_i[i].pc
757                             };
758                           end
                        MISSING_ELSE
759                     
760                           // use the zimm as operand a
761        1/1                if (issue_instr_i[i].use_zimm) begin
762                             // zero extend operand a
763        1/1                  fu_data_n[i].operand_a = {{CVA6Cfg.XLEN - 5{1'b0}}, issue_instr_i[i].rs1[4:0]};
764                           end
                        MISSING_ELSE
765                           // or is it an immediate (including PC), this is not the case for a store, control flow, and accelerator instructions
766                           // also make sure operand B is not already used as an FP operand
767        1/1                if (issue_instr_i[i].use_imm && (issue_instr_i[i].fu != STORE) && (issue_instr_i[i].fu != CTRL_FLOW) && (issue_instr_i[i].fu != ACCEL) && !(CVA6Cfg.FpPresent && is_rs2_fpr(
768                                   issue_instr_i[i].op
769                               ))) begin
770        1/1                  fu_data_n[i].operand_b = issue_instr_i[i].result;
771                           end
                        MISSING_ELSE
772                         end
773                       end
774                     
775                       always_comb begin
776        1/1              alu_valid_n    = '0;
777        1/1              lsu_valid_n    = '0;
778        1/1              mult_valid_n   = '0;
779        1/1              fpu_valid_n    = '0;
780        1/1              fpu_fmt_n      = '0;
781        1/1              fpu_rm_n       = '0;
782        1/1              alu2_valid_n   = '0;
783        1/1              csr_valid_n    = '0;
784        1/1              branch_valid_n = '0;
785        1/1              for (int unsigned i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
786        1/1                if (!issue_instr_i[i].ex.valid && issue_instr_valid_i[i] && issue_ack_o[i]) begin
787        1/1                  case (issue_instr_i[i].fu)
788                               ALU: begin
789        1/1                      if (CVA6Cfg.SuperscalarEn && !fus_busy[i].alu2) begin
790        unreachable                alu2_valid_n[i] = 1'b1;
791                                 end else begin
792        1/1                        alu_valid_n[i] = 1'b1;
793                                 end
794                               end
795                               CTRL_FLOW: begin
796        1/1                      branch_valid_n[i] = 1'b1;
797                               end
798                               MULT: begin
799        1/1                      mult_valid_n[i] = 1'b1;
800                               end
801                               LOAD, STORE: begin
802        1/1                      lsu_valid_n[i] = 1'b1;
803                               end
804                               CSR: begin
805        1/1                      csr_valid_n[i] = 1'b1;
806                               end
807                               default: begin
808        1/1                      if (issue_instr_i[i].fu == FPU && CVA6Cfg.FpPresent) begin
809        unreachable                fpu_valid_n[i] = 1'b1;
810        unreachable                fpu_fmt_n      = orig_instr.rftype.fmt;  // fmt bits from instruction
811        unreachable                fpu_rm_n       = orig_instr.rftype.rm;  // rm bits from instruction
812        1/1                      end else if (issue_instr_i[i].fu == FPU_VEC && CVA6Cfg.FpPresent) begin
813        unreachable                fpu_valid_n[i] = 1'b1;
814        unreachable                fpu_fmt_n      = orig_instr.rvftype.vfmt;  // vfmt bits from instruction
815        unreachable                fpu_rm_n       = {2'b0, orig_instr.rvftype.repl};  // repl bit from instruction
816                                 end
                        MISSING_ELSE
817                               end
818                             endcase
819                           end
                        MISSING_ELSE
820                         end
821                         // if we got a flush request, de-assert the valid flag, otherwise we will start this
822                         // functional unit with the wrong inputs
823        1/1              if (flush_i) begin
824        1/1                alu_valid_n    = '0;
825        1/1                lsu_valid_n    = '0;
826        1/1                mult_valid_n   = '0;
827        1/1                fpu_valid_n    = '0;
828        1/1                alu2_valid_n   = '0;
829        1/1                csr_valid_n    = '0;
830        1/1                branch_valid_n = '0;
831                         end
                        MISSING_ELSE
832                       end
833                       // FU select, assert the correct valid out signal (in the next cycle)
834                       // This needs to be like this to make verilator happy. I know its ugly.
835                       always_ff @(posedge clk_i or negedge rst_ni) begin
836        1/1              if (!rst_ni) begin
837        1/1                alu_valid_q    <= '0;
838        1/1                lsu_valid_q    <= '0;
839        1/1                mult_valid_q   <= '0;
840        1/1                fpu_valid_q    <= '0;
841        1/1                fpu_fmt_q      <= '0;
842        1/1                fpu_rm_q       <= '0;
843        1/1                alu2_valid_q   <= '0;
844        1/1                csr_valid_q    <= '0;
845        1/1                branch_valid_q <= '0;
846                         end else begin
847        1/1                alu_valid_q    <= alu_valid_n;
848        1/1                lsu_valid_q    <= lsu_valid_n;
849        1/1                mult_valid_q   <= mult_valid_n;
850        1/1                fpu_valid_q    <= fpu_valid_n;
851        1/1                fpu_fmt_q      <= fpu_fmt_n;
852        1/1                fpu_rm_q       <= fpu_rm_n;
853        1/1                alu2_valid_q   <= alu2_valid_n;
854        1/1                csr_valid_q    <= csr_valid_n;
855        1/1                branch_valid_q <= branch_valid_n;
856                         end
857                       end
858                     
859                       if (CVA6Cfg.CvxifEn) begin
860                         always_comb begin
861        1/1                cvxif_valid_n = '0;
862        1/1                cvxif_off_instr_n = 32'b0;
863        1/1                for (int unsigned i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
864        1/1                  if (!issue_instr_i[i].ex.valid && issue_instr_valid_i[i] && issue_ack_o[i]) begin
865        1/1                    case (issue_instr_i[i].fu)
866                                 CVXIF: begin
867        1/1                        cvxif_valid_n[i]  = 1'b1;
868        1/1                        cvxif_off_instr_n = orig_instr[i];
869                                 end
870        1/1                      default: ;
871                               endcase
872                             end
                        MISSING_ELSE
873                           end
874        1/1                if (flush_i) begin
875        1/1                  cvxif_valid_n = '0;
876        1/1                  cvxif_off_instr_n = 32'b0;
877                           end
                        MISSING_ELSE
878                         end
879                         always_ff @(posedge clk_i or negedge rst_ni) begin
880        1/1                if (!rst_ni) begin
881        1/1                  cvxif_valid_q <= '0;
882        1/1                  cvxif_off_instr_q <= 32'b0;
883                           end else begin
884        1/1                  cvxif_valid_q <= cvxif_valid_n;
885        1/1                  cvxif_off_instr_q <= cvxif_off_instr_n;
886                           end
887                         end
888                       end
889                     
890                       always_comb begin : gen_check_waw_dependencies
891        1/1              stall_waw = '1;
892        1/1              for (int unsigned i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
893        1/1                if (issue_instr_valid_i[i] && !fu_busy[i]) begin
894                             // -----------------------------------------
895                             // WAW - Write After Write Dependency Check
896                             // -----------------------------------------
897                             // no other instruction has the same destination register -> issue the instruction
898        1/1                  if ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
899                                     issue_instr_i[i].op
900                                 )) ? (rd_clobber_fpr[issue_instr_i[i].rd] == NONE) :
901                                     (rd_clobber_gpr[issue_instr_i[i].rd] == NONE)) begin
902        1/1                    stall_waw[i] = 1'b0;
903                             end
                        MISSING_ELSE
904                             // or check that the target destination register will be written in this cycle by the
905                             // commit stage
906        1/1                  for (int unsigned c = 0; c < CVA6Cfg.NrCommitPorts; c++) begin
907        1/1                    if ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
908                                       issue_instr_i[i].op
909                                   )) ? (we_fpr_i[c] && waddr_i[c] == issue_instr_i[i].rd) :
910                                       (we_gpr_i[c] && waddr_i[c] == issue_instr_i[i].rd)) begin
911        1/1                      stall_waw[i] = 1'b0;
912                               end
                        MISSING_ELSE
913                             end
914        1/1                  if (CVA6Cfg.SuperscalarEn && i > 0) begin
915        unreachable            if ((issue_instr_i[i].rd == issue_instr_i[i-1].rd) && (issue_instr_i[i].rd != '0)) begin
916        unreachable              stall_waw[i] = 1'b1;
917                               end
                   ==>  MISSING_ELSE
918                             end
                        MISSING_ELSE
919                           end
                        MISSING_ELSE
920                         end
921                       end
922                     
923                     
924                       // We can issue an instruction if we do not detect that any other instruction is writing the same
925                       // destination register.
926                       // We also need to check if there is an unresolved branch in the scoreboard.
927                       always_comb begin : issue_scoreboard
928        1/1              for (int unsigned i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
929                           // default assignment
930        1/1                issue_ack[i] = 1'b0;
931                           // check that the instruction we got is valid
932                           // and that the functional unit we need is not busy
933        1/1                if (issue_instr_valid_i[i] && !fu_busy[i]) begin
934        1/1                  if (!stall_raw[i] && !stall_waw[i]) begin
935        1/1                    issue_ack[i] = 1'b1;
936                             end
                        MISSING_ELSE
937        1/1                  if (issue_instr_i[i].ex.valid) begin
938        1/1                    issue_ack[i] = 1'b1;
939                             end
                        MISSING_ELSE
940                           end
                        MISSING_ELSE
941                         end
942                     
943        1/1              issue_ack_o = issue_ack;
944                         // Do not acknoledge the issued instruction if transaction is not completed.
945        1/1              if (issue_instr_i[0].fu == CVXIF && !(x_transaction_accepted_o || x_transaction_rejected)) begin
946        1/1                issue_ack_o[0] = issue_instr_i[0].ex.valid && issue_instr_valid_i[0];
947                         end
                        MISSING_ELSE
948        1/1              if (CVA6Cfg.SuperscalarEn) begin
949        unreachable        if (!issue_ack_o[0]) begin
950        unreachable          issue_ack_o[1] = 1'b0;
951                           end
                   ==>  MISSING_ELSE
952                         end
                        MISSING_ELSE
953                       end
954                     
955                       // ----------------------
956                       // Integer Register File
957                       // ----------------------
958                       logic [  CVA6Cfg.NrRgprPorts-1:0][CVA6Cfg.XLEN-1:0] rdata;
959                       logic [  CVA6Cfg.NrRgprPorts-1:0][             4:0] raddr_pack;
960                     
961                       // pack signals
962                       logic [CVA6Cfg.NrCommitPorts-1:0][             4:0] waddr_pack;
963                       logic [CVA6Cfg.NrCommitPorts-1:0][CVA6Cfg.XLEN-1:0] wdata_pack;
964                       logic [CVA6Cfg.NrCommitPorts-1:0]                   we_pack;
965                     
966                       //adjust address to read from register file (when synchronous RAM is used reads take one cycle, so we advance the address)   
967                       for (genvar i = 0; i <= CVA6Cfg.NrIssuePorts - 1; i++) begin
968                         assign raddr_pack[i*OPERANDS_PER_INSTR+0] = CVA6Cfg.FpgaEn && CVA6Cfg.FpgaAlteraEn ? issue_instr_i_prev[i].rs1[4:0] : issue_instr_i[i].rs1[4:0];
969                         assign raddr_pack[i*OPERANDS_PER_INSTR+1] = CVA6Cfg.FpgaEn && CVA6Cfg.FpgaAlteraEn ? issue_instr_i_prev[i].rs2[4:0] : issue_instr_i[i].rs2[4:0];
970                         if (OPERANDS_PER_INSTR == 3) begin
971                           assign raddr_pack[i*OPERANDS_PER_INSTR+2] = CVA6Cfg.FpgaEn && CVA6Cfg.FpgaAlteraEn ? issue_instr_i_prev[i].result[4:0] : issue_instr_i[i].result[4:0];
972                         end
973                       end
974                     
975                       for (genvar i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin : gen_write_back_port
976                         assign waddr_pack[i] = waddr_i[i];
977                         assign wdata_pack[i] = wdata_i[i];
978                         assign we_pack[i]    = we_gpr_i[i];
979                       end
980                       if (CVA6Cfg.FpgaEn) begin : gen_fpga_regfile
981                         ariane_regfile_fpga #(
982                             .CVA6Cfg      (CVA6Cfg),
983                             .DATA_WIDTH   (CVA6Cfg.XLEN),
984                             .NR_READ_PORTS(CVA6Cfg.NrRgprPorts),
985                             .ZERO_REG_ZERO(1)
986                         ) i_ariane_regfile_fpga (
987                             .clk_i,
988                             .rst_ni,
989                             .test_en_i(1'b0),
990                             .raddr_i  (raddr_pack),
991                             .rdata_o  (rdata),
992                             .waddr_i  (waddr_pack),
993                             .wdata_i  (wdata_pack),
994                             .we_i     (we_pack)
995                         );
996                       end else begin : gen_asic_regfile
997                         ariane_regfile #(
998                             .CVA6Cfg      (CVA6Cfg),
999                             .DATA_WIDTH   (CVA6Cfg.XLEN),
1000                            .NR_READ_PORTS(CVA6Cfg.NrRgprPorts),
1001                            .ZERO_REG_ZERO(1)
1002                        ) i_ariane_regfile (
1003                            .clk_i,
1004                            .rst_ni,
1005                            .test_en_i(1'b0),
1006                            .raddr_i  (raddr_pack),
1007                            .rdata_o  (rdata),
1008                            .waddr_i  (waddr_pack),
1009                            .wdata_i  (wdata_pack),
1010                            .we_i     (we_pack)
1011                        );
1012                      end
1013                    
1014                      // -----------------------------
1015                      // Floating-Point Register File
1016                      // -----------------------------
1017                      logic [2:0][CVA6Cfg.FLen-1:0] fprdata;
1018                    
1019                      // pack signals
1020                      logic [2:0][4:0] fp_raddr_pack;
1021                      logic [CVA6Cfg.NrCommitPorts-1:0][CVA6Cfg.XLEN-1:0] fp_wdata_pack;
1022                    
1023                      always_comb begin : assign_fp_raddr_pack
1024       1/1              fp_raddr_pack = {
1025                          issue_instr_i[0].result[4:0], issue_instr_i[0].rs2[4:0], issue_instr_i[0].rs1[4:0]
1026                        };
1027                    
1028       1/1              if (CVA6Cfg.SuperscalarEn) begin
1029       unreachable        if (!(issue_instr_i[0].fu inside {FPU, FPU_VEC})) begin
1030       unreachable          fp_raddr_pack = {
1031                              issue_instr_i[1].result[4:0], issue_instr_i[1].rs2[4:0], issue_instr_i[1].rs1[4:0]
1032                            };
1033                          end
                   ==>  MISSING_ELSE
1034                        end
                        MISSING_ELSE
1035                      end
1036                    
1037                      generate
1038                        if (CVA6Cfg.FpPresent) begin : float_regfile_gen
1039                          for (genvar i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin : gen_fp_wdata_pack
1040                            assign fp_wdata_pack[i] = {wdata_i[i][CVA6Cfg.FLen-1:0]};
1041                          end
1042                          if (CVA6Cfg.FpgaEn) begin : gen_fpga_fp_regfile
1043                            ariane_regfile_fpga #(
1044                                .CVA6Cfg      (CVA6Cfg),
1045                                .DATA_WIDTH   (CVA6Cfg.FLen),
1046                                .NR_READ_PORTS(3),
1047                                .ZERO_REG_ZERO(0)
1048                            ) i_ariane_fp_regfile_fpga (
1049                                .clk_i,
1050                                .rst_ni,
1051                                .test_en_i(1'b0),
1052                                .raddr_i  (fp_raddr_pack),
1053                                .rdata_o  (fprdata),
1054                                .waddr_i  (waddr_pack),
1055                                .wdata_i  (fp_wdata_pack),
1056                                .we_i     (we_fpr_i)
1057                            );
1058                          end else begin : gen_asic_fp_regfile
1059                            ariane_regfile #(
1060                                .CVA6Cfg      (CVA6Cfg),
1061                                .DATA_WIDTH   (CVA6Cfg.FLen),
1062                                .NR_READ_PORTS(3),
1063                                .ZERO_REG_ZERO(0)
1064                            ) i_ariane_fp_regfile (
1065                                .clk_i,
1066                                .rst_ni,
1067                                .test_en_i(1'b0),
1068                                .raddr_i  (fp_raddr_pack),
1069                                .rdata_o  (fprdata),
1070                                .waddr_i  (waddr_pack),
1071                                .wdata_i  (fp_wdata_pack),
1072                                .we_i     (we_fpr_i)
1073                            );
1074                          end
1075                        end else begin : no_fpr_gen
1076                          assign fprdata = '{default: '0};
1077                        end
1078                      endgenerate
1079                    
1080                      if (OPERANDS_PER_INSTR == 3) begin : gen_operand_c
1081                        assign operand_c_fpr = {{CVA6Cfg.XLEN - CVA6Cfg.FLen{1'b0}}, fprdata[2]};
1082                      end else begin
1083                        assign operand_c_fpr = fprdata[2];
1084                      end
1085                    
1086                      for (genvar i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
1087                        if (OPERANDS_PER_INSTR == 3) begin : gen_operand_c
1088                          assign operand_c_gpr[i] = rdata[i*OPERANDS_PER_INSTR+2];
1089                        end
1090                    
1091                        assign operand_a_regfile[i] = (CVA6Cfg.FpPresent && is_rs1_fpr(
1092                            issue_instr_i[i].op
1093                        )) ? {{CVA6Cfg.XLEN - CVA6Cfg.FLen{1'b0}}, fprdata[0]} : rdata[i*OPERANDS_PER_INSTR+0];
1094                        assign operand_b_regfile[i] = (CVA6Cfg.FpPresent && is_rs2_fpr(
1095                            issue_instr_i[i].op
1096                        )) ? {{CVA6Cfg.XLEN - CVA6Cfg.FLen{1'b0}}, fprdata[1]} : rdata[i*OPERANDS_PER_INSTR+1];
1097                        assign operand_c_regfile[i] = (OPERANDS_PER_INSTR == 3) ? ((CVA6Cfg.FpPresent && is_imm_fpr(
1098                            issue_instr_i[i].op
1099                        )) ? operand_c_fpr : operand_c_gpr[i]) : operand_c_fpr;
1100                      end
1101                    
1102                      // ----------------------
1103                      // Registers (ID <-> EX)
1104                      // ----------------------
1105                    
1106                      always_comb begin
1107       1/1              pc_n = '0;
1108       1/1              is_compressed_instr_n = 1'b0;
1109       1/1              branch_predict_n = {cf_t'(0), {CVA6Cfg.VLEN{1'b0}}};
1110       1/1              if (CVA6Cfg.SuperscalarEn) begin
1111       unreachable        if (issue_instr_i[1].fu == CTRL_FLOW) begin
1112       unreachable          pc_n                  = issue_instr_i[1].pc;
1113       unreachable          is_compressed_instr_n = issue_instr_i[1].is_compressed;
1114       unreachable          branch_predict_n      = issue_instr_i[1].bp;
1115                          end
                   ==>  MISSING_ELSE
1116                        end
                        MISSING_ELSE
1117       1/1              if (issue_instr_i[0].fu == CTRL_FLOW) begin
1118       1/1                pc_n                  = issue_instr_i[0].pc;
1119       1/1                is_compressed_instr_n = issue_instr_i[0].is_compressed;
1120       1/1                branch_predict_n      = issue_instr_i[0].bp;
1121                        end
                        MISSING_ELSE
1122       1/1              x_transaction_rejected_n = 1'b0;
1123       1/1              if (issue_instr_i[0].fu == CVXIF) begin
1124       1/1                x_transaction_rejected_n = x_transaction_rejected;
1125                        end
                        MISSING_ELSE
1126                      end
1127                    
1128                    
1129                      always_ff @(posedge clk_i or negedge rst_ni) begin
1130       1/1              if (!rst_ni) begin
1131       1/1                fu_data_q <= '0;
1132       1/1                if (CVA6Cfg.RVH) begin
1133       unreachable          tinst_q <= '0;
1134                          end
                        MISSING_ELSE
1135       1/1                pc_o                     <= '0;
1136       1/1                is_zcmt_o                <= '0;
1137       1/1                is_compressed_instr_o    <= 1'b0;
1138       1/1                branch_predict_o         <= {cf_t'(0), {CVA6Cfg.VLEN{1'b0}}};
1139       1/1                x_transaction_rejected_o <= 1'b0;
1140                        end else begin
1141       1/1                fu_data_q <= fu_data_n;
1142       1/1                pc_o <= pc_n;
1143       1/1                is_compressed_instr_o <= is_compressed_instr_n;
1144       1/1                branch_predict_o <= branch_predict_n;
1145       1/1                if (CVA6Cfg.RVH) begin
1146       unreachable          tinst_q <= tinst_n;
1147                          end
                        MISSING_ELSE
1148       1/1                if (issue_instr_i[0].fu == CTRL_FLOW) begin
1149       1/1(1 unreachable)          if (CVA6Cfg.RVZCMT) is_zcmt_o <= issue_instr_i[0].is_zcmt;
1150       1/1                  else is_zcmt_o <= '0;
1151                          end
                        MISSING_ELSE
1152       1/1                x_transaction_rejected_o <= x_transaction_rejected_n;

-------------------------------------------------------------------------------
Cond Coverage for Module : issue_read_operands

               Total   Covered  Percent
Conditions         58       58   100.00
Logical            58       58   100.00
Non-Logical         0        0
Event               0        0

 LINE       336
 EXPRESSION (issue_instr_i[0].op == ADD)
            --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       677
 EXPRESSION (x_transaction_rejected ? 1'b0 : (stall_rs1[0] || stall_rs2[0] || (((32'b00000000000000000000000000000010 == 3) && stall_rs3[0]))))
             -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       677
 SUB-EXPRESSION (stall_rs1[0] || stall_rs2[0] || (((32'b00000000000000000000000000000010 == 3) && stall_rs3[0])))
                 ------1-----    ------2-----    -------------------------------3-------------------------------

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Unreachable
 0   1   0  Covered
 1   0   0  Covered

 LINE       786
 EXPRESSION (((!issue_instr_i[i].ex.valid)) && issue_instr_valid_i[i] && issue_ack_o[i])
             ---------------1--------------    -----------2----------    -------3------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       893
 EXPRESSION (issue_instr_valid_i[i] && ((!fu_busy[i])))
             -----------1----------    -------2-------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       915
 EXPRESSION ((issue_instr_i[i].rd == issue_instr_i[(i - 1)].rd) && (issue_instr_i[i].rd != '0))
             -------------------------1------------------------    -------------2-------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       915
 SUB-EXPRESSION (issue_instr_i[i].rd == issue_instr_i[(i - 1)].rd)
                -------------------------1------------------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       915
 SUB-EXPRESSION (issue_instr_i[i].rd != '0)
                -------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       933
 EXPRESSION (issue_instr_valid_i[i] && ((!fu_busy[i])))
             -----------1----------    -------2-------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       934
 EXPRESSION (((!stall_raw[i])) && ((!stall_waw[i])))
             --------1--------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       945
 EXPRESSION ((issue_instr_i[0].fu == CVXIF) && ( ! (x_transaction_accepted_o || x_transaction_rejected) ))
             ---------------1--------------    -----------------------------2----------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       945
 SUB-EXPRESSION (issue_instr_i[0].fu == CVXIF)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       945
 SUB-EXPRESSION ( ! (x_transaction_accepted_o || x_transaction_rejected) )
                    --------------------------1-------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       945
 SUB-EXPRESSION (x_transaction_accepted_o || x_transaction_rejected)
                 ------------1-----------    -----------2----------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       946
 EXPRESSION (issue_instr_i[0].ex.valid && issue_instr_valid_i[0])
             ------------1------------    -----------2----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       1111
 EXPRESSION (issue_instr_i[1].fu == CTRL_FLOW)
            -----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       1117
 EXPRESSION (issue_instr_i[0].fu == CTRL_FLOW)
            -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       1123
 EXPRESSION (issue_instr_i[0].fu == CVXIF)
            ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       1148
 EXPRESSION (issue_instr_i[0].fu == CTRL_FLOW)
            -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       728
 SUB-EXPRESSION ((issue_instr_i[0].op == OFFLOAD) ? operand_c_regfile[0] : issue_instr_i[0].result)
                 ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       728
 SUB-EXPRESSION (issue_instr_i[0].op == OFFLOAD)
                ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       864
 EXPRESSION (((!issue_instr_i[i].ex.valid)) && issue_instr_valid_i[i] && issue_ack_o[i])
             ---------------1--------------    -----------2----------    -------3------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       249
 EXPRESSION ((issue_instr_i[0].fu == CVXIF) && ((!stall_waw[0])))
             ---------------1--------------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       249
 SUB-EXPRESSION (issue_instr_i[0].fu == CVXIF)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       250
 EXPRESSION (((!issue_instr_i[0].ex.valid)) && issue_instr_valid_i[0] && cvxif_req_allowed)
             ---------------1--------------    -----------2----------    --------3--------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       251
 EXPRESSION (x_issue_valid_o && x_issue_ready_i && x_issue_resp_i.accept)
             -------1-------    -------2-------    ----------3----------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       252
 EXPRESSION (x_issue_valid_o && x_issue_ready_i && ((~x_issue_resp_i.accept)))
             -------1-------    -------2-------    -------------3------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 97.46 100.00  94.92 --     


Module : 

SCORE  LINE   COND   ASSERT NAME                
100.00 100.00 100.00 --     issue_read_operands 


Parent : 

SCORE  LINE   COND   ASSERT NAME          
100.00 --     100.00 --     issue_stage_i 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                                    
100.00 100.00 100.00 --     gen_asic_regfile.i_ariane_regfile       
 94.19 --      94.19 --     genblk5[0].i_sel_rs1                    
 94.19 --      94.19 --     genblk5[0].i_sel_rs2                    
 94.19 --      94.19 --     genblk5[0].i_sel_rs3                    
100.00 100.00 100.00 --     i_cvxif_issue_register_commit_if_driver 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : cvxif_compressed_if_driver
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/cvxif_compressed_if_driver.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                                      
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.id_stage_i.genblk1.genblk6.i_cvxif_compressed_if_driver_i 



-------------------------------------------------------------------------------
Line Coverage for Module : cvxif_compressed_if_driver

             Line No.   Total   Covered  Percent
TOTAL                       19       19   100.00
ALWAYS             41       19       19   100.00

40                        always_comb begin
41         1/1              is_illegal_o            = is_illegal_i;
42         1/1              instruction_o           = instruction_i;
43         1/1              is_compressed_o         = is_compressed_i;
44         1/1              compressed_valid_o      = 1'b0;
45         1/1              compressed_req_o.instr  = '0;
46         1/1              compressed_req_o.hartid = hart_id_i;
47         1/1              stall_o                 = stall_i;
48         1/1              if (is_illegal_i) begin
49         1/1                compressed_valid_o = is_illegal_i;
50         1/1                compressed_req_o.instr = instruction_i[15:0];
51         1/1                is_illegal_o = ~compressed_resp_i.accept;
52         1/1                instruction_o = compressed_resp_i.accept ? compressed_resp_i.instr : instruction_i;
53         1/1                is_compressed_o = compressed_resp_i.accept ? 1'b0 : is_compressed_i;
54         1/1                if (~stall_i) begin
55                              // Propagate stall from macro decoder or wait for compressed ready if compressed transaction is happening.
56         1/1                  stall_o = ~compressed_ready_i;
57                            end
                   ==>  MISSING_ELSE
58                          end
                        MISSING_ELSE
59         1/1              if (flush_i) begin
60         1/1                compressed_valid_o      = 1'b0;
61         1/1                compressed_req_o.instr  = '0;
62         1/1                compressed_req_o.hartid = hart_id_i;
63                          end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : cvxif_compressed_if_driver

               Total   Covered  Percent
Conditions          4        4   100.00
Logical             4        4   100.00
Non-Logical         0        0
Event               0        0

 LINE       52
 EXPRESSION (compressed_resp_i.accept ? compressed_resp_i.instr : instruction_i)
             ------------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       53
 EXPRESSION (compressed_resp_i.accept ? 1'b0 : is_compressed_i)
             ------------1-----------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.id_stage_i.genblk1.genblk6.i_cvxif_compressed_if_driver_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME                       
100.00 100.00 100.00 --     cvxif_compressed_if_driver 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     id_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : lzc
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/vendor/pulp-platform/common_cells/src/lzc.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                                                            
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue.gen_multiple_instr_per_fetch_with_C.i_lzc_branch_index 
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.alu_i.gen_bitmanip.i_clz_64b                                         
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_a                                                 
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_b                                                 



-------------------------------------------------------------------------------
Line Coverage for Module : lzc

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
INITIAL            54        0        0
ALWAYS             66        0        0
ALWAYS             66        2        2   100.00

65                          always_comb begin : flip_vector
66         1/1                for (int unsigned i = 0; i < WIDTH; i++) begin
67         1/1                  in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];

-------------------------------------------------------------------------------
Cond Coverage for Module : lzc ( parameter WIDTH=32,MODE=1,CNT_WIDTH=5,gen_lzc.NumLevels=5 ) 
Cond Coverage for Module self-instances : 
uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.alu_i.gen_bitmanip.i_clz_64b
----------------
SCORE  COND   
100.00 100.00 

uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_a
----------------
SCORE  COND   
100.00 100.00 

uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_b
----------------
SCORE  COND   
100.00 100.00 


               Total   Covered  Percent
Conditions        217      217   100.00
Logical           217      217   100.00
Non-Logical         0        0
Event               0        0

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (0 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (0 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (1 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (1 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (1 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (1 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (2 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (2 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (3 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (3 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (2 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (2 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (3 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (3 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (4 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (4 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (5 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (5 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (6 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (6 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (7 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (7 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(0 * 2)] | gen_lzc.in_tmp[((0 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(0 * 2)] == 1'b1) ? gen_lzc.index_lut[(0 * 2)] : gen_lzc.index_lut[((0 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(0 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(1 * 2)] | gen_lzc.in_tmp[((1 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(1 * 2)] == 1'b1) ? gen_lzc.index_lut[(1 * 2)] : gen_lzc.index_lut[((1 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(1 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(2 * 2)] | gen_lzc.in_tmp[((2 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(2 * 2)] == 1'b1) ? gen_lzc.index_lut[(2 * 2)] : gen_lzc.index_lut[((2 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(2 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(3 * 2)] | gen_lzc.in_tmp[((3 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(3 * 2)] == 1'b1) ? gen_lzc.index_lut[(3 * 2)] : gen_lzc.index_lut[((3 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(3 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(4 * 2)] | gen_lzc.in_tmp[((4 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(4 * 2)] == 1'b1) ? gen_lzc.index_lut[(4 * 2)] : gen_lzc.index_lut[((4 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(4 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(5 * 2)] | gen_lzc.in_tmp[((5 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(5 * 2)] == 1'b1) ? gen_lzc.index_lut[(5 * 2)] : gen_lzc.index_lut[((5 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(5 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(6 * 2)] | gen_lzc.in_tmp[((6 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(6 * 2)] == 1'b1) ? gen_lzc.index_lut[(6 * 2)] : gen_lzc.index_lut[((6 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(6 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(7 * 2)] | gen_lzc.in_tmp[((7 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(7 * 2)] == 1'b1) ? gen_lzc.index_lut[(7 * 2)] : gen_lzc.index_lut[((7 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(7 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(8 * 2)] | gen_lzc.in_tmp[((8 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(8 * 2)] == 1'b1) ? gen_lzc.index_lut[(8 * 2)] : gen_lzc.index_lut[((8 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(8 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(9 * 2)] | gen_lzc.in_tmp[((9 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(9 * 2)] == 1'b1) ? gen_lzc.index_lut[(9 * 2)] : gen_lzc.index_lut[((9 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(9 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(10 * 2)] | gen_lzc.in_tmp[((10 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(10 * 2)] == 1'b1) ? gen_lzc.index_lut[(10 * 2)] : gen_lzc.index_lut[((10 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(10 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(11 * 2)] | gen_lzc.in_tmp[((11 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(11 * 2)] == 1'b1) ? gen_lzc.index_lut[(11 * 2)] : gen_lzc.index_lut[((11 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(11 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(12 * 2)] | gen_lzc.in_tmp[((12 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(12 * 2)] == 1'b1) ? gen_lzc.index_lut[(12 * 2)] : gen_lzc.index_lut[((12 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(12 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(13 * 2)] | gen_lzc.in_tmp[((13 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(13 * 2)] == 1'b1) ? gen_lzc.index_lut[(13 * 2)] : gen_lzc.index_lut[((13 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(13 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(14 * 2)] | gen_lzc.in_tmp[((14 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(14 * 2)] == 1'b1) ? gen_lzc.index_lut[(14 * 2)] : gen_lzc.index_lut[((14 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(14 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(15 * 2)] | gen_lzc.in_tmp[((15 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(15 * 2)] == 1'b1) ? gen_lzc.index_lut[(15 * 2)] : gen_lzc.index_lut[((15 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(15 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Cond Coverage for Module : lzc ( parameter WIDTH=2,MODE=0,CNT_WIDTH=1,gen_lzc.NumLevels=1 ) 
Cond Coverage for Module self-instances : 
uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue.gen_multiple_instr_per_fetch_with_C.i_lzc_branch_index
----------------
SCORE  COND   
100.00 100.00 


               Total   Covered  Percent
Conditions          7        7   100.00
Logical             7        7   100.00
Non-Logical         0        0
Event               0        0

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(0 * 2)] | gen_lzc.in_tmp[((0 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(0 * 2)] == 1'b1) ? gen_lzc.index_lut[(0 * 2)] : gen_lzc.index_lut[((0 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(0 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue.gen_multiple_instr_per_fetch_with_C.i_lzc_branch_index
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME 
100.00 100.00 100.00 --     lzc  


Parent : 

SCORE  LINE   COND   ASSERT NAME          
100.00 100.00 100.00 --     i_instr_queue 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue.gen_multiple_instr_per_fetch_with_C.i_lzc_branch_index

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
INITIAL            54        0        0
ALWAYS             66        0        0
ALWAYS             66        2        2   100.00

65                          always_comb begin : flip_vector
66         1/1                for (int unsigned i = 0; i < WIDTH; i++) begin
67         1/1                  in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];

-------------------------------------------------------------------------------
Cond Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue.gen_multiple_instr_per_fetch_with_C.i_lzc_branch_index

               Total   Covered  Percent
Conditions          7        7   100.00
Logical             7        7   100.00
Non-Logical         0        0
Event               0        0

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(0 * 2)] | gen_lzc.in_tmp[((0 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(0 * 2)] == 1'b1) ? gen_lzc.index_lut[(0 * 2)] : gen_lzc.index_lut[((0 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(0 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.alu_i.gen_bitmanip.i_clz_64b
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME 
100.00 100.00 100.00 --     lzc  


Parent : 

SCORE  LINE   COND   ASSERT NAME  
100.00 100.00 100.00 --     alu_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.alu_i.gen_bitmanip.i_clz_64b

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
INITIAL            54        0        0
ALWAYS             66        0        0
ALWAYS             66        2        2   100.00

65                          always_comb begin : flip_vector
66         1/1                for (int unsigned i = 0; i < WIDTH; i++) begin
67         1/1                  in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];

-------------------------------------------------------------------------------
Cond Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.alu_i.gen_bitmanip.i_clz_64b

               Total   Covered  Percent
Conditions        217      217   100.00
Logical           217      217   100.00
Non-Logical         0        0
Event               0        0

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (0 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (0 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (1 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (1 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (1 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (1 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (2 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (2 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (3 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (3 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (2 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (2 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (3 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (3 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (4 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (4 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (5 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (5 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (6 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (6 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (7 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (7 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(0 * 2)] | gen_lzc.in_tmp[((0 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(0 * 2)] == 1'b1) ? gen_lzc.index_lut[(0 * 2)] : gen_lzc.index_lut[((0 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(0 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(1 * 2)] | gen_lzc.in_tmp[((1 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(1 * 2)] == 1'b1) ? gen_lzc.index_lut[(1 * 2)] : gen_lzc.index_lut[((1 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(1 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(2 * 2)] | gen_lzc.in_tmp[((2 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(2 * 2)] == 1'b1) ? gen_lzc.index_lut[(2 * 2)] : gen_lzc.index_lut[((2 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(2 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(3 * 2)] | gen_lzc.in_tmp[((3 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(3 * 2)] == 1'b1) ? gen_lzc.index_lut[(3 * 2)] : gen_lzc.index_lut[((3 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(3 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(4 * 2)] | gen_lzc.in_tmp[((4 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(4 * 2)] == 1'b1) ? gen_lzc.index_lut[(4 * 2)] : gen_lzc.index_lut[((4 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(4 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(5 * 2)] | gen_lzc.in_tmp[((5 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(5 * 2)] == 1'b1) ? gen_lzc.index_lut[(5 * 2)] : gen_lzc.index_lut[((5 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(5 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(6 * 2)] | gen_lzc.in_tmp[((6 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(6 * 2)] == 1'b1) ? gen_lzc.index_lut[(6 * 2)] : gen_lzc.index_lut[((6 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(6 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(7 * 2)] | gen_lzc.in_tmp[((7 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(7 * 2)] == 1'b1) ? gen_lzc.index_lut[(7 * 2)] : gen_lzc.index_lut[((7 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(7 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(8 * 2)] | gen_lzc.in_tmp[((8 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(8 * 2)] == 1'b1) ? gen_lzc.index_lut[(8 * 2)] : gen_lzc.index_lut[((8 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(8 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(9 * 2)] | gen_lzc.in_tmp[((9 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(9 * 2)] == 1'b1) ? gen_lzc.index_lut[(9 * 2)] : gen_lzc.index_lut[((9 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(9 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(10 * 2)] | gen_lzc.in_tmp[((10 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(10 * 2)] == 1'b1) ? gen_lzc.index_lut[(10 * 2)] : gen_lzc.index_lut[((10 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(10 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(11 * 2)] | gen_lzc.in_tmp[((11 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(11 * 2)] == 1'b1) ? gen_lzc.index_lut[(11 * 2)] : gen_lzc.index_lut[((11 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(11 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(12 * 2)] | gen_lzc.in_tmp[((12 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(12 * 2)] == 1'b1) ? gen_lzc.index_lut[(12 * 2)] : gen_lzc.index_lut[((12 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(12 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(13 * 2)] | gen_lzc.in_tmp[((13 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(13 * 2)] == 1'b1) ? gen_lzc.index_lut[(13 * 2)] : gen_lzc.index_lut[((13 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(13 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(14 * 2)] | gen_lzc.in_tmp[((14 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(14 * 2)] == 1'b1) ? gen_lzc.index_lut[(14 * 2)] : gen_lzc.index_lut[((14 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(14 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(15 * 2)] | gen_lzc.in_tmp[((15 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(15 * 2)] == 1'b1) ? gen_lzc.index_lut[(15 * 2)] : gen_lzc.index_lut[((15 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(15 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_a
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME 
100.00 100.00 100.00 --     lzc  


Parent : 

SCORE  LINE   COND   ASSERT NAME  
 99.13 100.00  98.26 --     i_div 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_a

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
INITIAL            54        0        0
ALWAYS             66        0        0
ALWAYS             66        2        2   100.00

65                          always_comb begin : flip_vector
66         1/1                for (int unsigned i = 0; i < WIDTH; i++) begin
67         1/1                  in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];

-------------------------------------------------------------------------------
Cond Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_a

               Total   Covered  Percent
Conditions        217      217   100.00
Logical           217      217   100.00
Non-Logical         0        0
Event               0        0

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (0 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (0 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (1 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (1 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (1 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (1 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (2 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (2 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (3 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (3 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (2 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (2 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (3 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (3 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (4 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (4 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (5 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (5 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (6 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (6 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (7 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (7 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(0 * 2)] | gen_lzc.in_tmp[((0 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(0 * 2)] == 1'b1) ? gen_lzc.index_lut[(0 * 2)] : gen_lzc.index_lut[((0 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(0 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(1 * 2)] | gen_lzc.in_tmp[((1 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(1 * 2)] == 1'b1) ? gen_lzc.index_lut[(1 * 2)] : gen_lzc.index_lut[((1 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(1 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(2 * 2)] | gen_lzc.in_tmp[((2 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(2 * 2)] == 1'b1) ? gen_lzc.index_lut[(2 * 2)] : gen_lzc.index_lut[((2 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(2 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(3 * 2)] | gen_lzc.in_tmp[((3 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(3 * 2)] == 1'b1) ? gen_lzc.index_lut[(3 * 2)] : gen_lzc.index_lut[((3 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(3 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(4 * 2)] | gen_lzc.in_tmp[((4 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(4 * 2)] == 1'b1) ? gen_lzc.index_lut[(4 * 2)] : gen_lzc.index_lut[((4 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(4 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(5 * 2)] | gen_lzc.in_tmp[((5 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(5 * 2)] == 1'b1) ? gen_lzc.index_lut[(5 * 2)] : gen_lzc.index_lut[((5 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(5 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(6 * 2)] | gen_lzc.in_tmp[((6 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(6 * 2)] == 1'b1) ? gen_lzc.index_lut[(6 * 2)] : gen_lzc.index_lut[((6 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(6 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(7 * 2)] | gen_lzc.in_tmp[((7 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(7 * 2)] == 1'b1) ? gen_lzc.index_lut[(7 * 2)] : gen_lzc.index_lut[((7 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(7 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(8 * 2)] | gen_lzc.in_tmp[((8 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(8 * 2)] == 1'b1) ? gen_lzc.index_lut[(8 * 2)] : gen_lzc.index_lut[((8 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(8 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(9 * 2)] | gen_lzc.in_tmp[((9 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(9 * 2)] == 1'b1) ? gen_lzc.index_lut[(9 * 2)] : gen_lzc.index_lut[((9 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(9 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(10 * 2)] | gen_lzc.in_tmp[((10 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(10 * 2)] == 1'b1) ? gen_lzc.index_lut[(10 * 2)] : gen_lzc.index_lut[((10 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(10 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(11 * 2)] | gen_lzc.in_tmp[((11 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(11 * 2)] == 1'b1) ? gen_lzc.index_lut[(11 * 2)] : gen_lzc.index_lut[((11 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(11 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(12 * 2)] | gen_lzc.in_tmp[((12 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(12 * 2)] == 1'b1) ? gen_lzc.index_lut[(12 * 2)] : gen_lzc.index_lut[((12 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(12 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(13 * 2)] | gen_lzc.in_tmp[((13 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(13 * 2)] == 1'b1) ? gen_lzc.index_lut[(13 * 2)] : gen_lzc.index_lut[((13 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(13 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(14 * 2)] | gen_lzc.in_tmp[((14 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(14 * 2)] == 1'b1) ? gen_lzc.index_lut[(14 * 2)] : gen_lzc.index_lut[((14 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(14 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(15 * 2)] | gen_lzc.in_tmp[((15 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(15 * 2)] == 1'b1) ? gen_lzc.index_lut[(15 * 2)] : gen_lzc.index_lut[((15 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(15 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_b
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME 
100.00 100.00 100.00 --     lzc  


Parent : 

SCORE  LINE   COND   ASSERT NAME  
 99.13 100.00  98.26 --     i_div 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_b

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
INITIAL            54        0        0
ALWAYS             66        0        0
ALWAYS             66        2        2   100.00

65                          always_comb begin : flip_vector
66         1/1                for (int unsigned i = 0; i < WIDTH; i++) begin
67         1/1                  in_tmp[i] = (MODE) ? in_i[WIDTH-1-i] : in_i[i];

-------------------------------------------------------------------------------
Cond Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_div.i_lzc_b

               Total   Covered  Percent
Conditions        217      217   100.00
Logical           217      217   100.00
Non-Logical         0        0
Event               0        0

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (0 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (0 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (0 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (1 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (1 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (1 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (1 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (1 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (2 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (2 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (2 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] | gen_lzc.sel_nodes[((((2 ** (2 + 1)) - 1) + (3 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] : gen_lzc.index_nodes[((((2 ** (2 + 1)) - 1) + (3 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (2 + 1)) - 1) + (3 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (0 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (0 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (0 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (1 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (1 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (1 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (2 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (2 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (2 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (3 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (3 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (3 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (4 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (4 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (4 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (5 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (5 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (5 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (6 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (6 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (6 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       98
 EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] | gen_lzc.sel_nodes[((((2 ** (3 + 1)) - 1) + (7 * 2)) + 1)])
             -------------------------1-------------------------   ----------------------------2----------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       100
 EXPRESSION 
 Number  Term
      1  (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] == 1'b1) ? gen_lzc.index_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] : gen_lzc.index_nodes[((((2 ** (3 + 1)) - 1) + (7 * 2)) + 1)])

-1- Status
 0  Covered
 1  Covered

 LINE       100
 SUB-EXPRESSION (gen_lzc.sel_nodes[(((2 ** (3 + 1)) - 1) + (7 * 2))] == 1'b1)
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(0 * 2)] | gen_lzc.in_tmp[((0 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(0 * 2)] == 1'b1) ? gen_lzc.index_lut[(0 * 2)] : gen_lzc.index_lut[((0 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(0 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(1 * 2)] | gen_lzc.in_tmp[((1 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(1 * 2)] == 1'b1) ? gen_lzc.index_lut[(1 * 2)] : gen_lzc.index_lut[((1 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(1 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(2 * 2)] | gen_lzc.in_tmp[((2 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(2 * 2)] == 1'b1) ? gen_lzc.index_lut[(2 * 2)] : gen_lzc.index_lut[((2 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(2 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(3 * 2)] | gen_lzc.in_tmp[((3 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(3 * 2)] == 1'b1) ? gen_lzc.index_lut[(3 * 2)] : gen_lzc.index_lut[((3 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(3 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(4 * 2)] | gen_lzc.in_tmp[((4 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(4 * 2)] == 1'b1) ? gen_lzc.index_lut[(4 * 2)] : gen_lzc.index_lut[((4 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(4 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(5 * 2)] | gen_lzc.in_tmp[((5 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(5 * 2)] == 1'b1) ? gen_lzc.index_lut[(5 * 2)] : gen_lzc.index_lut[((5 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(5 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(6 * 2)] | gen_lzc.in_tmp[((6 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(6 * 2)] == 1'b1) ? gen_lzc.index_lut[(6 * 2)] : gen_lzc.index_lut[((6 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(6 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(7 * 2)] | gen_lzc.in_tmp[((7 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(7 * 2)] == 1'b1) ? gen_lzc.index_lut[(7 * 2)] : gen_lzc.index_lut[((7 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(7 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(8 * 2)] | gen_lzc.in_tmp[((8 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(8 * 2)] == 1'b1) ? gen_lzc.index_lut[(8 * 2)] : gen_lzc.index_lut[((8 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(8 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(9 * 2)] | gen_lzc.in_tmp[((9 * 2) + 1)])
             -----------1-----------   --------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(9 * 2)] == 1'b1) ? gen_lzc.index_lut[(9 * 2)] : gen_lzc.index_lut[((9 * 2) + 1)])
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(9 * 2)] == 1'b1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(10 * 2)] | gen_lzc.in_tmp[((10 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(10 * 2)] == 1'b1) ? gen_lzc.index_lut[(10 * 2)] : gen_lzc.index_lut[((10 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(10 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(11 * 2)] | gen_lzc.in_tmp[((11 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(11 * 2)] == 1'b1) ? gen_lzc.index_lut[(11 * 2)] : gen_lzc.index_lut[((11 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(11 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(12 * 2)] | gen_lzc.in_tmp[((12 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(12 * 2)] == 1'b1) ? gen_lzc.index_lut[(12 * 2)] : gen_lzc.index_lut[((12 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(12 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(13 * 2)] | gen_lzc.in_tmp[((13 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(13 * 2)] == 1'b1) ? gen_lzc.index_lut[(13 * 2)] : gen_lzc.index_lut[((13 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(13 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(14 * 2)] | gen_lzc.in_tmp[((14 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(14 * 2)] == 1'b1) ? gen_lzc.index_lut[(14 * 2)] : gen_lzc.index_lut[((14 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(14 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       80
 EXPRESSION (gen_lzc.in_tmp[(15 * 2)] | gen_lzc.in_tmp[((15 * 2) + 1)])
             ------------1-----------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       81
 EXPRESSION ((gen_lzc.in_tmp[(15 * 2)] == 1'b1) ? gen_lzc.index_lut[(15 * 2)] : gen_lzc.index_lut[((15 * 2) + 1)])
             -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       81
 SUB-EXPRESSION (gen_lzc.in_tmp[(15 * 2)] == 1'b1)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

===============================================================================
Module : alu
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/alu.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                             
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.alu_i 



-------------------------------------------------------------------------------
Line Coverage for Module : alu

             Line No.   Total   Covered  Percent
TOTAL                       53       53   100.00
ALWAYS             78        9        9   100.00
ALWAYS            117        6        6   100.00
ALWAYS            188        4        4   100.00
ALWAYS            295       34       34   100.00

77                        always_comb begin
78         1/1              operand_a_bitmanip = fu_data_i.operand_a;
79                      
80         1/1              if (CVA6Cfg.RVB) begin
81         1/1                if (CVA6Cfg.IS_XLEN64) begin
82         unreachable          unique case (fu_data_i.operation)
83         unreachable            SH1ADDUW:           operand_a_bitmanip = fu_data_i.operand_a[31:0] << 1;
84         unreachable            SH2ADDUW:           operand_a_bitmanip = fu_data_i.operand_a[31:0] << 2;
85         unreachable            SH3ADDUW:           operand_a_bitmanip = fu_data_i.operand_a[31:0] << 3;
86         unreachable            CTZW:               operand_a_bitmanip = operand_a_rev32;
87         unreachable            ADDUW, CPOPW, CLZW: operand_a_bitmanip = fu_data_i.operand_a[31:0];
88         unreachable            default:            ;
89                              endcase
90                            end
                        MISSING_ELSE
91         1/1                unique case (fu_data_i.operation)
92         1/1                  SH1ADD:  operand_a_bitmanip = fu_data_i.operand_a << 1;
93         1/1                  SH2ADD:  operand_a_bitmanip = fu_data_i.operand_a << 2;
94         1/1                  SH3ADD:  operand_a_bitmanip = fu_data_i.operand_a << 3;
95         1/1                  CTZ:     operand_a_bitmanip = operand_a_rev;
96         1/1                  default: ;
97                            endcase
98                          end
                   ==>  MISSING_ELSE
99                        end
100                     
101                       // prepare operand a
102                       assign adder_in_a         = {operand_a_bitmanip, 1'b1};
103                     
104                       // prepare operand b
105                       assign operand_b_neg      = {fu_data_i.operand_b, 1'b0} ^ {CVA6Cfg.XLEN + 1{adder_op_b_negate}};
106                       assign adder_in_b         = operand_b_neg;
107                     
108                       // actual adder
109                       assign adder_result_ext_o = adder_in_a + adder_in_b;
110                       assign adder_result       = adder_result_ext_o[CVA6Cfg.XLEN:1];
111                       assign adder_z_flag       = ~|adder_result;
112                     
113                       // get the right branch comparison result
114                       if (HasBranch) begin
115                         always_comb begin : branch_resolve
116                           // set comparison by default
117        1/1                case (fu_data_i.operation)
118        1/1                  EQ:       alu_branch_res_o = adder_z_flag;
119        1/1                  NE:       alu_branch_res_o = ~adder_z_flag;
120        1/1                  LTS, LTU: alu_branch_res_o = less;
121        1/1                  GES, GEU: alu_branch_res_o = ~less;
122        1/1                  default:  alu_branch_res_o = 1'b1;
123                           endcase
124                         end
125                       end else begin
126                         assign alu_branch_res_o = 1'b0;
127                       end
128                     
129                       // ---------
130                       // Shifts
131                       // ---------
132                     
133                       logic                    shift_left;  // should we shift left
134                       logic                    shift_arithmetic;
135                     
136                       logic [CVA6Cfg.XLEN-1:0] shift_amt;  // amount of shift, to the right
137                       logic [CVA6Cfg.XLEN-1:0] shift_op_a;  // input of the shifter
138                       logic [            31:0] shift_op_a32;  // input to the 32 bit shift operation
139                     
140                       logic [CVA6Cfg.XLEN-1:0] shift_result;
141                       logic [            31:0] shift_result32;
142                     
143                       logic [  CVA6Cfg.XLEN:0] shift_right_result;
144                       logic [            32:0] shift_right_result32;
145                     
146                       logic [CVA6Cfg.XLEN-1:0] shift_left_result;
147                       logic [            31:0] shift_left_result32;
148                     
149                       assign shift_amt = fu_data_i.operand_b;
150                     
151                       assign shift_left = (fu_data_i.operation == SLL) | (CVA6Cfg.IS_XLEN64 && fu_data_i.operation == SLLW);
152                     
153                       assign shift_arithmetic = (fu_data_i.operation == SRA) | (CVA6Cfg.IS_XLEN64 && fu_data_i.operation == SRAW);
154                     
155                       // right shifts, we let the synthesizer optimize this
156                       logic [CVA6Cfg.XLEN:0] shift_op_a_64;
157                       logic [32:0] shift_op_a_32;
158                     
159                       // choose the bit reversed or the normal input for shift operand a
160                       assign shift_op_a           = shift_left ? operand_a_rev : fu_data_i.operand_a;
161                       assign shift_op_a32         = shift_left ? operand_a_rev32 : fu_data_i.operand_a[31:0];
162                     
163                       assign shift_op_a_64        = {shift_arithmetic & shift_op_a[CVA6Cfg.XLEN-1], shift_op_a};
164                       assign shift_op_a_32        = {shift_arithmetic & shift_op_a[31], shift_op_a32};
165                     
166                       assign shift_right_result   = $unsigned($signed(shift_op_a_64) >>> shift_amt[5:0]);
167                     
168                       assign shift_right_result32 = $unsigned($signed(shift_op_a_32) >>> shift_amt[4:0]);
169                       // bit reverse the shift_right_result for left shifts
170                       genvar j;
171                       generate
172                         for (j = 0; j < CVA6Cfg.XLEN; j++)
173                           assign shift_left_result[j] = shift_right_result[CVA6Cfg.XLEN-1-j];
174                     
175                         for (j = 0; j < 32; j++) assign shift_left_result32[j] = shift_right_result32[31-j];
176                     
177                       endgenerate
178                     
179                       assign shift_result   = shift_left ? shift_left_result : shift_right_result[CVA6Cfg.XLEN-1:0];
180                       assign shift_result32 = shift_left ? shift_left_result32 : shift_right_result32[31:0];
181                     
182                       // ------------
183                       // Comparisons
184                       // ------------
185                     
186                       always_comb begin
187                         logic sgn;
188        1/1              sgn = 1'b0;
189                     
190        1/1              if ((fu_data_i.operation == SLTS) ||
191                                 (fu_data_i.operation == LTS)  ||
192                                 (fu_data_i.operation == GES)  ||
193                                 (fu_data_i.operation == MAX)  ||
194                                 (fu_data_i.operation == MIN))
195        1/1                sgn = 1'b1;
                        MISSING_ELSE
196                     
197        1/1              less = ($signed({sgn & fu_data_i.operand_a[CVA6Cfg.XLEN-1], fu_data_i.operand_a}) <
198                                 $signed({sgn & fu_data_i.operand_b[CVA6Cfg.XLEN-1], fu_data_i.operand_b}));
199                       end
200                     
201                       if (CVA6Cfg.RVB) begin : gen_bitmanip
202                         // Count Population + Count population Word
203                     
204                         popcount #(
205                             .INPUT_WIDTH(CVA6Cfg.XLEN)
206                         ) i_cpop_count (
207                             .data_i    (operand_a_bitmanip),
208                             .popcount_o(cpop)
209                         );
210                     
211                         // Count Leading/Trailing Zeros
212                         // 64b
213                         lzc #(
214                             .WIDTH(CVA6Cfg.XLEN),
215                             .MODE (1)
216                         ) i_clz_64b (
217                             .in_i(operand_a_bitmanip),
218                             .cnt_o(lz_tz_count),
219                             .empty_o(lz_tz_empty)
220                         );
221                         if (CVA6Cfg.IS_XLEN64) begin
222                           //32b
223                           lzc #(
224                               .WIDTH(32),
225                               .MODE (1)
226                           ) i_clz_32b (
227                               .in_i(operand_a_bitmanip[31:0]),
228                               .cnt_o(lz_tz_wcount),
229                               .empty_o(lz_tz_wempty)
230                           );
231                         end
232                       end
233                     
234                       if (CVA6Cfg.RVB) begin : gen_orcbw_rev8w_results
235                         assign orcbw = {
236                           {8{|fu_data_i.operand_a[31:24]}},
237                           {8{|fu_data_i.operand_a[23:16]}},
238                           {8{|fu_data_i.operand_a[15:8]}},
239                           {8{|fu_data_i.operand_a[7:0]}}
240                         };
241                         assign rev8w = {
242                           {fu_data_i.operand_a[7:0]},
243                           {fu_data_i.operand_a[15:8]},
244                           {fu_data_i.operand_a[23:16]},
245                           {fu_data_i.operand_a[31:24]}
246                         };
247                         if (CVA6Cfg.IS_XLEN64) begin : gen_64b
248                           assign orcbw_result = {
249                             {8{|fu_data_i.operand_a[63:56]}},
250                             {8{|fu_data_i.operand_a[55:48]}},
251                             {8{|fu_data_i.operand_a[47:40]}},
252                             {8{|fu_data_i.operand_a[39:32]}},
253                             orcbw
254                           };
255                           assign rev8w_result = {
256                             rev8w,
257                             {fu_data_i.operand_a[39:32]},
258                             {fu_data_i.operand_a[47:40]},
259                             {fu_data_i.operand_a[55:48]},
260                             {fu_data_i.operand_a[63:56]}
261                           };
262                         end else begin : gen_32b
263                           assign orcbw_result = orcbw;
264                           assign rev8w_result = rev8w;
265                         end
266                       end
267                     
268                       // ZKN gen block
269                       if (CVA6Cfg.ZKN && CVA6Cfg.RVB) begin : zkn_gen_block
270                         genvar i, m, n;
271                         // Generate brev8_reversed by reversing bits within each byte
272                         for (i = 0; i < (CVA6Cfg.XLEN / 8); i++) begin : brev8_gen
273                           for (m = 0; m < 8; m++) begin : reverse_bits
274                             // Reversing the order of bits within a single byte
275                             assign brev8_reversed[(i<<3)+m] = fu_data_i.operand_a[(i<<3)+(7-m)];
276                           end
277                         end
278                         // Generate zip and unzip results
279                         if (CVA6Cfg.IS_XLEN32) begin
280                           for (n = 0; n < 16; n++) begin : zip_unzip_gen
281                             // Assigning lower and upper half of operand into the even and odd positions of result
282                             assign zip_gen[n<<1] = fu_data_i.operand_a[n];
283                             assign zip_gen[(n<<1)+1] = fu_data_i.operand_a[n+16];
284                             // Assigning even and odd bits of operand into lower and upper halves of result
285                             assign unzip_gen[n] = fu_data_i.operand_a[n<<1];
286                             assign unzip_gen[n+16] = fu_data_i.operand_a[(n<<1)+1];
287                           end
288                         end
289                       end
290                     
291                       // -----------
292                       // Result MUX
293                       // -----------
294                       always_comb begin
295        1/1              result_o = '0;
296        1/1              if (CVA6Cfg.IS_XLEN64) begin
297        unreachable        unique case (fu_data_i.operation)
298                             // Add word: Ignore the upper bits and sign extend to 64 bit
299        unreachable          ADDW, SUBW: result_o = {{CVA6Cfg.XLEN - 32{adder_result[31]}}, adder_result[31:0]};
300        unreachable          SH1ADDUW, SH2ADDUW, SH3ADDUW: result_o = adder_result;
301                             // Shifts 32 bit
302                             SLLW, SRLW, SRAW:
303        unreachable          result_o = {{CVA6Cfg.XLEN - 32{shift_result32[31]}}, shift_result32[31:0]};
304        unreachable          default: ;
305                           endcase
306                         end
                        MISSING_ELSE
307        1/1              unique case (fu_data_i.operation)
308                           // Standard Operations
309        1/1                ANDL, ANDN: result_o = fu_data_i.operand_a & operand_b_neg[CVA6Cfg.XLEN:1];
310        1/1                ORL, ORN: result_o = fu_data_i.operand_a | operand_b_neg[CVA6Cfg.XLEN:1];
311        1/1                XORL, XNOR: result_o = fu_data_i.operand_a ^ operand_b_neg[CVA6Cfg.XLEN:1];
312                           // Adder Operations
313        1/1                ADD, SUB, ADDUW, SH1ADD, SH2ADD, SH3ADD: result_o = adder_result;
314                           // Shift Operations
315        1/1                SLL, SRL, SRA: result_o = (CVA6Cfg.IS_XLEN64) ? shift_result : shift_result32;
316                           // Comparison Operations
317        1/1                SLTS, SLTU: result_o = {{CVA6Cfg.XLEN - 1{1'b0}}, less};
318        1/1                default: ;  // default case to suppress unique warning
319                         endcase
320                     
321        1/1              if (CVA6Cfg.RVB) begin
322                           // Index for Bitwise Rotation
323        1/1                bit_indx = 1 << (fu_data_i.operand_b & (CVA6Cfg.XLEN - 1));
324        1/1                if (CVA6Cfg.IS_XLEN64) begin
325                             // rolw, roriw, rorw
326        unreachable          rolw = ({{CVA6Cfg.XLEN-32{1'b0}},fu_data_i.operand_a[31:0]} << fu_data_i.operand_b[4:0]) | ({{CVA6Cfg.XLEN-32{1'b0}},fu_data_i.operand_a[31:0]} >> (CVA6Cfg.XLEN-32-fu_data_i.operand_b[4:0]));
327        unreachable          rorw = ({{CVA6Cfg.XLEN-32{1'b0}},fu_data_i.operand_a[31:0]} >> fu_data_i.operand_b[4:0]) | ({{CVA6Cfg.XLEN-32{1'b0}},fu_data_i.operand_a[31:0]} << (CVA6Cfg.XLEN-32-fu_data_i.operand_b[4:0]));
328        unreachable          unique case (fu_data_i.operation)
329                               CLZW, CTZW:
330        unreachable            result_o = (lz_tz_wempty) ? 32 : {{CVA6Cfg.XLEN - 5{1'b0}}, lz_tz_wcount};  // change
331        unreachable            ROLW: result_o = {{CVA6Cfg.XLEN - 32{rolw[31]}}, rolw};
332        unreachable            RORW, RORIW: result_o = {{CVA6Cfg.XLEN - 32{rorw[31]}}, rorw};
333        unreachable            default: ;
334                             endcase
335                           end
                        MISSING_ELSE
336        1/1                unique case (fu_data_i.operation)
337                             // Integer minimum/maximum
338        1/1                  MAX:  result_o = less ? fu_data_i.operand_b : fu_data_i.operand_a;
339        1/1                  MAXU: result_o = less ? fu_data_i.operand_b : fu_data_i.operand_a;
340        1/1                  MIN:  result_o = ~less ? fu_data_i.operand_b : fu_data_i.operand_a;
341        1/1                  MINU: result_o = ~less ? fu_data_i.operand_b : fu_data_i.operand_a;
342                     
343                             // Single bit instructions operations
344        1/1                  BCLR, BCLRI: result_o = fu_data_i.operand_a & ~bit_indx;
345        1/1                  BEXT, BEXTI: result_o = {{CVA6Cfg.XLEN - 1{1'b0}}, |(fu_data_i.operand_a & bit_indx)};
346        1/1                  BINV, BINVI: result_o = fu_data_i.operand_a ^ bit_indx;
347        1/1                  BSET, BSETI: result_o = fu_data_i.operand_a | bit_indx;
348                     
349                             // Count Leading/Trailing Zeros
350                             CLZ, CTZ:
351        1/1                  result_o = (lz_tz_empty) ? ({{CVA6Cfg.XLEN - $clog2(CVA6Cfg.XLEN) {1'b0}}, lz_tz_count} + 1)
352                                 : {{CVA6Cfg.XLEN - $clog2(CVA6Cfg.XLEN) {1'b0}}, lz_tz_count};
353                     
354                             // Count population
355        1/1                  CPOP, CPOPW: result_o = {{(CVA6Cfg.XLEN - ($clog2(CVA6Cfg.XLEN) + 1)) {1'b0}}, cpop};
356                     
357                             // Sign and Zero Extend
358        1/1                  SEXTB: result_o = {{CVA6Cfg.XLEN - 8{fu_data_i.operand_a[7]}}, fu_data_i.operand_a[7:0]};
359        1/1                  SEXTH: result_o = {{CVA6Cfg.XLEN - 16{fu_data_i.operand_a[15]}}, fu_data_i.operand_a[15:0]};
360        1/1                  ZEXTH: result_o = {{CVA6Cfg.XLEN - 16{1'b0}}, fu_data_i.operand_a[15:0]};
361                     
362                             // Bitwise Rotation
363                             ROL:
364        1/1                  result_o = (CVA6Cfg.IS_XLEN64) ? ((fu_data_i.operand_a << fu_data_i.operand_b[5:0]) | (fu_data_i.operand_a >> (CVA6Cfg.XLEN-fu_data_i.operand_b[5:0]))) : ((fu_data_i.operand_a << fu_data_i.operand_b[4:0]) | (fu_data_i.operand_a >> (CVA6Cfg.XLEN-fu_data_i.operand_b[4:0])));
365                     
366                             ROR, RORI:
367        1/1                  result_o = (CVA6Cfg.IS_XLEN64) ? ((fu_data_i.operand_a >> fu_data_i.operand_b[5:0]) | (fu_data_i.operand_a << (CVA6Cfg.XLEN-fu_data_i.operand_b[5:0]))) : ((fu_data_i.operand_a >> fu_data_i.operand_b[4:0]) | (fu_data_i.operand_a << (CVA6Cfg.XLEN-fu_data_i.operand_b[4:0])));
368                     
369        1/1                  ORCB: result_o = orcbw_result;
370        1/1                  REV8: result_o = rev8w_result;
371                     
372                             default:
373        1/1                  if (fu_data_i.operation == SLLIUW && CVA6Cfg.IS_XLEN64)
374        unreachable            result_o = {{CVA6Cfg.XLEN-32{1'b0}}, fu_data_i.operand_a[31:0]} << fu_data_i.operand_b[5:0];  // Left Shift 32 bit unsigned
                        MISSING_ELSE
375                           endcase
376                         end
                   ==>  MISSING_ELSE
377        1/1              if (CVA6Cfg.RVZiCond) begin
378        unreachable        unique case (fu_data_i.operation)
379                             CZERO_EQZ:
380        unreachable          result_o = (|fu_data_i.operand_b) ? fu_data_i.operand_a : '0;  // move zero to rd if rs2 is equal to zero else rs1
381                             CZERO_NEZ:
382        unreachable          result_o = (|fu_data_i.operand_b) ? '0 : fu_data_i.operand_a; // move zero to rd if rs2 is nonzero else rs1
383        unreachable          default: ;  // default case to suppress unique warning
384                           endcase
385                         end
                        MISSING_ELSE
386                         // ZKN instructions
387        1/1              if (CVA6Cfg.ZKN && CVA6Cfg.RVB) begin
388        unreachable        unique case (fu_data_i.operation)
389                             PACK:
390        unreachable          result_o = (CVA6Cfg.IS_XLEN32) ? ({fu_data_i.operand_b[15:0], fu_data_i.operand_a[15:0]}) : ({fu_data_i.operand_b[31:0], fu_data_i.operand_a[31:0]});
391                             PACK_H:
392        unreachable          result_o = (CVA6Cfg.IS_XLEN32) ? ({16'b0, fu_data_i.operand_b[7:0], fu_data_i.operand_a[7:0]}) : ({48'b0, fu_data_i.operand_b[7:0], fu_data_i.operand_a[7:0]});
393        unreachable          BREV8: result_o = brev8_reversed;
394        unreachable          default: ;
395                           endcase
396        unreachable        if (fu_data_i.operation == PACK_W && CVA6Cfg.IS_XLEN64)
397        unreachable          result_o = {
                   ==>  MISSING_ELSE
398                               {32{fu_data_i.operand_b[15]}}, {fu_data_i.operand_b[15:0]}, {fu_data_i.operand_a[15:0]}
399                             };
400        unreachable        if (fu_data_i.operation == UNZIP && CVA6Cfg.IS_XLEN32) result_o = unzip_gen;
                   ==>  MISSING_ELSE
401        unreachable        if (fu_data_i.operation == ZIP && CVA6Cfg.IS_XLEN32) result_o = zip_gen;
                   ==>  MISSING_ELSE
402                         end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : alu

               Total   Covered  Percent
Conditions         48       48   100.00
Logical            48       48   100.00
Non-Logical         0        0
Event               0        0

 LINE       190
 EXPRESSION 
 Number  Term
      1  (fu_data_i.operation == SLTS) || 
      2  (fu_data_i.operation == LTS) || 
      3  (fu_data_i.operation == GES) || 
      4  (fu_data_i.operation == MAX) || 
      5  (fu_data_i.operation == MIN))

-1- -2- -3- -4- -5- Status
 0   0   0   0   0  Covered
 0   0   0   0   1  Covered
 0   0   0   1   0  Covered
 0   0   1   0   0  Covered
 0   1   0   0   0  Covered
 1   0   0   0   0  Covered

 LINE       190
 SUB-EXPRESSION (fu_data_i.operation == SLTS)
                --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       190
 SUB-EXPRESSION (fu_data_i.operation == LTS)
                --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       190
 SUB-EXPRESSION (fu_data_i.operation == GES)
                --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       190
 SUB-EXPRESSION (fu_data_i.operation == MAX)
                --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       190
 SUB-EXPRESSION (fu_data_i.operation == MIN)
                --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       330
 EXPRESSION (lz_tz_wempty ? 32 : ({{(32'b00000000000000000000000000100000 - 5) {1'b0}}, lz_tz_wcount}))
             ------1-----

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       338
 EXPRESSION (less ? fu_data_i.operand_b : fu_data_i.operand_a)
             --1-

-1- Status
 0  Covered
 1  Covered

 LINE       339
 EXPRESSION (less ? fu_data_i.operand_b : fu_data_i.operand_a)
             --1-

-1- Status
 0  Covered
 1  Covered

 LINE       340
 EXPRESSION (((~less)) ? fu_data_i.operand_b : fu_data_i.operand_a)
             ----1----

-1- Status
 0  Covered
 1  Covered

 LINE       341
 EXPRESSION (((~less)) ? fu_data_i.operand_b : fu_data_i.operand_a)
             ----1----

-1- Status
 0  Covered
 1  Covered

 LINE       351
 EXPRESSION (lz_tz_empty ? (({{32'b00000000000000000000000000011011 {1'b0}}, lz_tz_count} + 1)) : ({{32'b00000000000000000000000000011011 {1'b0}}, lz_tz_count}))
             -----1-----

-1- Status
 0  Covered
 1  Covered

 LINE       380
 EXPRESSION (((|fu_data_i.operand_b)) ? fu_data_i.operand_a : '0)
             ------------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       382
 EXPRESSION (((|fu_data_i.operand_b)) ? '0 : fu_data_i.operand_a)
             ------------1-----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       400
 EXPRESSION ((fu_data_i.operation == UNZIP) && 1'b1)
             ---------------1--------------    --2-

-1- -2- Status
 0   -  Unreachable
 1   -  Unreachable

 LINE       400
 SUB-EXPRESSION (fu_data_i.operation == UNZIP)
                ---------------1--------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       401
 EXPRESSION ((fu_data_i.operation == ZIP) && 1'b1)
             --------------1-------------    --2-

-1- -2- Status
 0   -  Unreachable
 1   -  Unreachable

 LINE       401
 SUB-EXPRESSION (fu_data_i.operation == ZIP)
                --------------1-------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       151
 EXPRESSION ((fu_data_i.operation == SLL) | ((1'b0 && (fu_data_i.operation == SLLW))))
             --------------1-------------   --------------------2--------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       151
 SUB-EXPRESSION (fu_data_i.operation == SLL)
                --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       153
 EXPRESSION ((fu_data_i.operation == SRA) | ((1'b0 && (fu_data_i.operation == SRAW))))
             --------------1-------------   --------------------2--------------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       153
 SUB-EXPRESSION (fu_data_i.operation == SRA)
                --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       160
 EXPRESSION (shift_left ? operand_a_rev : fu_data_i.operand_a)
             -----1----

-1- Status
 0  Covered
 1  Covered

 LINE       161
 EXPRESSION (shift_left ? operand_a_rev32 : fu_data_i.operand_a[31:0])
             -----1----

-1- Status
 0  Covered
 1  Covered

 LINE       163
 SUB-EXPRESSION (shift_arithmetic & shift_op_a[(32'b00000000000000000000000000100000 - 1)])
                 --------1-------   ---------------------------2--------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       164
 SUB-EXPRESSION (shift_arithmetic & shift_op_a[31])
                 --------1-------   -------2------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       179
 EXPRESSION (shift_left ? shift_left_result : shift_right_result[32'b00000000000000000000000000011111:0])
             -----1----

-1- Status
 0  Covered
 1  Covered

 LINE       180
 EXPRESSION (shift_left ? shift_left_result32 : shift_right_result32[31:0])
             -----1----

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.alu_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME 
100.00 100.00 100.00 --     alu  


Parent : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     ex_stage_i 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                   
100.00 100.00 100.00 --     gen_bitmanip.i_clz_64b 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : instr_scan
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/frontend/instr_scan.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                      
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.gen_instr_scan[0].i_instr_scan 



-------------------------------------------------------------------------------
Line Coverage for Module : instr_scan

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
ROUTINE            52        1        1   100.00
ROUTINE            62        1        1   100.00

51                        function automatic logic [CVA6Cfg.VLEN-1:0] uj_imm(logic [31:0] instruction_i);
52         1/1              return {
53                            {44 + CVA6Cfg.VLEN - 64{instruction_i[31]}},
54                            instruction_i[19:12],
55                            instruction_i[20],
56                            instruction_i[30:21],
57                            1'b0
58                          };
59                        endfunction
60                      
61                        function automatic logic [CVA6Cfg.VLEN-1:0] sb_imm(logic [31:0] instruction_i);
62         1/1              return {

-------------------------------------------------------------------------------
Cond Coverage for Module : instr_scan

               Total   Covered  Percent
Conditions        100      100   100.00
Logical           100      100   100.00
Non-Logical         0        0
Event               0        0

 LINE       73
 EXPRESSION ((32'b00000000000000000000000000100000 == 32) & (instr_i[15:13] == riscv::OpcodeC1Jal) & (instr_i[1:0] == riscv::OpcodeC1))
             ----------------------1---------------------   -------------------2------------------   ----------------3----------------

-1- -2- -3- Status
 -   0   1  Covered
 -   1   0  Covered
 -   1   1  Covered

 LINE       73
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC1Jal)
                -------------------1------------------

-1- Status
 0  Covered
 1  Covered

 LINE       73
 SUB-EXPRESSION (instr_i[1:0] == riscv::OpcodeC1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       76
 EXPRESSION ((logic'((instr_i[31:30] == 2'b0))) & (logic'((instr_i[28:0] == 29'b10000001000000000000001110011))))
             -----------------1----------------   -------------------------------2------------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       79
 EXPRESSION (rvi_jalr_o & ((instr_i[19:15] == 5'b1) | (instr_i[19:15] == 5'd5)) & (instr_i[19:15] != instr_i[11:7]))
             -----1----   --------------------------2--------------------------   ----------------3----------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       79
 SUB-EXPRESSION ((instr_i[19:15] == 5'b1) | (instr_i[19:15] == 5'd5))
                 ------------1-----------   ------------2-----------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       79
 SUB-EXPRESSION (instr_i[19:15] == 5'b1)
                ------------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       79
 SUB-EXPRESSION (instr_i[19:15] == 5'd5)
                ------------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       79
 SUB-EXPRESSION (instr_i[19:15] != instr_i[11:7])
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       82
 EXPRESSION ((rvi_jalr_o | rvi_jump_o) & ((instr_i[11:7] == 5'b1) | (instr_i[11:7] == 5'd5)))
             ------------1------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       82
 SUB-EXPRESSION (rvi_jalr_o | rvi_jump_o)
                 -----1----   -----2----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       82
 SUB-EXPRESSION ((instr_i[11:7] == 5'b1) | (instr_i[11:7] == 5'd5))
                 -----------1-----------   -----------2-----------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       82
 SUB-EXPRESSION (instr_i[11:7] == 5'b1)
                -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       82
 SUB-EXPRESSION (instr_i[11:7] == 5'd5)
                -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       84
 EXPRESSION (is_xret ? '0 : (instr_i[3] ? uj_imm(instr_i) : sb_imm(instr_i)))
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       84
 SUB-EXPRESSION (instr_i[3] ? uj_imm(instr_i) : sb_imm(instr_i))
                 -----1----

-1- Status
 0  Covered
 1  Covered

 LINE       85
 EXPRESSION (instr_i[6:0] == riscv::OpcodeBranch)
            ------------------1------------------

-1- Status
 0  Covered
 1  Covered

 LINE       86
 EXPRESSION (instr_i[6:0] == riscv::OpcodeJalr)
            -----------------1-----------------

-1- Status
 0  Covered
 1  Covered

 LINE       87
 EXPRESSION ((logic'((instr_i[6:0] == riscv::OpcodeJal))) | is_xret)
             ----------------------1---------------------   ---2---

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       90
 EXPRESSION (((instr_i[15:13] == riscv::OpcodeC1J) & (instr_i[1:0] == riscv::OpcodeC1)) | rv32_rvc_jal)
             -------------------------------------1------------------------------------   ------2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       90
 SUB-EXPRESSION ((instr_i[15:13] == riscv::OpcodeC1J) & (instr_i[1:0] == riscv::OpcodeC1))
                 ------------------1-----------------   ----------------2----------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       90
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC1J)
                ------------------1-----------------

-1- Status
 0  Covered
 1  Covered

 LINE       90
 SUB-EXPRESSION (instr_i[1:0] == riscv::OpcodeC1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       94
 EXPRESSION ((instr_i[15:13] == riscv::OpcodeC2JalrMvAdd) & (instr_i[6:2] == 5'b0) & (instr_i[1:0] == riscv::OpcodeC2))
             ----------------------1---------------------   -----------2----------   ----------------3----------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       94
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC2JalrMvAdd)
                ----------------------1---------------------

-1- Status
 0  Covered
 1  Covered

 LINE       94
 SUB-EXPRESSION (instr_i[6:2] == 5'b0)
                -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       94
 SUB-EXPRESSION (instr_i[1:0] == riscv::OpcodeC2)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       97
 EXPRESSION (is_jal_r & ((~instr_i[12])))
             ----1---   --------2-------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       99
 EXPRESSION (is_jal_r & instr_i[12])
             ----1---   -----2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       100
 EXPRESSION (rvc_jalr_o | rv32_rvc_jal)
             -----1----   ------2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       102
 EXPRESSION (((instr_i[15:13] == riscv::OpcodeC1Beqz) | (instr_i[15:13] == riscv::OpcodeC1Bnez)) & (instr_i[1:0] == riscv::OpcodeC1))
             -----------------------------------------1-----------------------------------------   ----------------2----------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       102
 SUB-EXPRESSION ((instr_i[15:13] == riscv::OpcodeC1Beqz) | (instr_i[15:13] == riscv::OpcodeC1Bnez))
                 -------------------1-------------------   -------------------2-------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       102
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC1Beqz)
                -------------------1-------------------

-1- Status
 0  Covered
 1  Covered

 LINE       102
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC1Bnez)
                -------------------1-------------------

-1- Status
 0  Covered
 1  Covered

 LINE       102
 SUB-EXPRESSION (instr_i[1:0] == riscv::OpcodeC1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       105
 EXPRESSION (((instr_i[11:7] == 5'b1) | (instr_i[11:7] == 5'd5)) & rvc_jr_o)
             -------------------------1-------------------------   ----2---

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       105
 SUB-EXPRESSION ((instr_i[11:7] == 5'b1) | (instr_i[11:7] == 5'd5))
                 -----------1-----------   -----------2-----------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       105
 SUB-EXPRESSION (instr_i[11:7] == 5'b1)
                -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       105
 SUB-EXPRESSION (instr_i[11:7] == 5'd5)
                -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       108
 EXPRESSION 
 Number  Term
      1  instr_i[14] ? ({{((56 + 32'b00000000000000000000000000100000) - 64) {instr_i[12]}}, instr_i[6:5], instr_i[2], instr_i[11:10], instr_i[4:3], 1'b0}) : ({{((53 + 32'b00000000000000000000000000100000) - 64) {instr_i[12]}}, instr_i[8], instr_i[10:9], instr_i[6], instr_i[7], instr_i[2], instr_i[11], instr_i[5:3], 1'b0}))

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.gen_instr_scan[0].i_instr_scan
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     instr_scan 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
 99.24 100.00  98.47 --     i_frontend 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.gen_instr_scan[0].i_instr_scan

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
ROUTINE            52        1        1   100.00
ROUTINE            62        1        1   100.00

51                        function automatic logic [CVA6Cfg.VLEN-1:0] uj_imm(logic [31:0] instruction_i);
52         1/1              return {
53                            {44 + CVA6Cfg.VLEN - 64{instruction_i[31]}},
54                            instruction_i[19:12],
55                            instruction_i[20],
56                            instruction_i[30:21],
57                            1'b0
58                          };
59                        endfunction
60                      
61                        function automatic logic [CVA6Cfg.VLEN-1:0] sb_imm(logic [31:0] instruction_i);
62         1/1              return {

-------------------------------------------------------------------------------
Cond Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.gen_instr_scan[0].i_instr_scan

               Total   Covered  Percent
Conditions        100      100   100.00
Logical           100      100   100.00
Non-Logical         0        0
Event               0        0

 LINE       73
 EXPRESSION ((32'b00000000000000000000000000100000 == 32) & (instr_i[15:13] == riscv::OpcodeC1Jal) & (instr_i[1:0] == riscv::OpcodeC1))
             ----------------------1---------------------   -------------------2------------------   ----------------3----------------

-1- -2- -3- Status
 -   0   1  Covered
 -   1   0  Covered
 -   1   1  Covered

 LINE       73
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC1Jal)
                -------------------1------------------

-1- Status
 0  Covered
 1  Covered

 LINE       73
 SUB-EXPRESSION (instr_i[1:0] == riscv::OpcodeC1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       76
 EXPRESSION ((logic'((instr_i[31:30] == 2'b0))) & (logic'((instr_i[28:0] == 29'b10000001000000000000001110011))))
             -----------------1----------------   -------------------------------2------------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       79
 EXPRESSION (rvi_jalr_o & ((instr_i[19:15] == 5'b1) | (instr_i[19:15] == 5'd5)) & (instr_i[19:15] != instr_i[11:7]))
             -----1----   --------------------------2--------------------------   ----------------3----------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       79
 SUB-EXPRESSION ((instr_i[19:15] == 5'b1) | (instr_i[19:15] == 5'd5))
                 ------------1-----------   ------------2-----------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       79
 SUB-EXPRESSION (instr_i[19:15] == 5'b1)
                ------------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       79
 SUB-EXPRESSION (instr_i[19:15] == 5'd5)
                ------------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       79
 SUB-EXPRESSION (instr_i[19:15] != instr_i[11:7])
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       82
 EXPRESSION ((rvi_jalr_o | rvi_jump_o) & ((instr_i[11:7] == 5'b1) | (instr_i[11:7] == 5'd5)))
             ------------1------------   -------------------------2-------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       82
 SUB-EXPRESSION (rvi_jalr_o | rvi_jump_o)
                 -----1----   -----2----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       82
 SUB-EXPRESSION ((instr_i[11:7] == 5'b1) | (instr_i[11:7] == 5'd5))
                 -----------1-----------   -----------2-----------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       82
 SUB-EXPRESSION (instr_i[11:7] == 5'b1)
                -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       82
 SUB-EXPRESSION (instr_i[11:7] == 5'd5)
                -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       84
 EXPRESSION (is_xret ? '0 : (instr_i[3] ? uj_imm(instr_i) : sb_imm(instr_i)))
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       84
 SUB-EXPRESSION (instr_i[3] ? uj_imm(instr_i) : sb_imm(instr_i))
                 -----1----

-1- Status
 0  Covered
 1  Covered

 LINE       85
 EXPRESSION (instr_i[6:0] == riscv::OpcodeBranch)
            ------------------1------------------

-1- Status
 0  Covered
 1  Covered

 LINE       86
 EXPRESSION (instr_i[6:0] == riscv::OpcodeJalr)
            -----------------1-----------------

-1- Status
 0  Covered
 1  Covered

 LINE       87
 EXPRESSION ((logic'((instr_i[6:0] == riscv::OpcodeJal))) | is_xret)
             ----------------------1---------------------   ---2---

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       90
 EXPRESSION (((instr_i[15:13] == riscv::OpcodeC1J) & (instr_i[1:0] == riscv::OpcodeC1)) | rv32_rvc_jal)
             -------------------------------------1------------------------------------   ------2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       90
 SUB-EXPRESSION ((instr_i[15:13] == riscv::OpcodeC1J) & (instr_i[1:0] == riscv::OpcodeC1))
                 ------------------1-----------------   ----------------2----------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       90
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC1J)
                ------------------1-----------------

-1- Status
 0  Covered
 1  Covered

 LINE       90
 SUB-EXPRESSION (instr_i[1:0] == riscv::OpcodeC1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       94
 EXPRESSION ((instr_i[15:13] == riscv::OpcodeC2JalrMvAdd) & (instr_i[6:2] == 5'b0) & (instr_i[1:0] == riscv::OpcodeC2))
             ----------------------1---------------------   -----------2----------   ----------------3----------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       94
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC2JalrMvAdd)
                ----------------------1---------------------

-1- Status
 0  Covered
 1  Covered

 LINE       94
 SUB-EXPRESSION (instr_i[6:2] == 5'b0)
                -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       94
 SUB-EXPRESSION (instr_i[1:0] == riscv::OpcodeC2)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       97
 EXPRESSION (is_jal_r & ((~instr_i[12])))
             ----1---   --------2-------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       99
 EXPRESSION (is_jal_r & instr_i[12])
             ----1---   -----2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       100
 EXPRESSION (rvc_jalr_o | rv32_rvc_jal)
             -----1----   ------2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       102
 EXPRESSION (((instr_i[15:13] == riscv::OpcodeC1Beqz) | (instr_i[15:13] == riscv::OpcodeC1Bnez)) & (instr_i[1:0] == riscv::OpcodeC1))
             -----------------------------------------1-----------------------------------------   ----------------2----------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       102
 SUB-EXPRESSION ((instr_i[15:13] == riscv::OpcodeC1Beqz) | (instr_i[15:13] == riscv::OpcodeC1Bnez))
                 -------------------1-------------------   -------------------2-------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       102
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC1Beqz)
                -------------------1-------------------

-1- Status
 0  Covered
 1  Covered

 LINE       102
 SUB-EXPRESSION (instr_i[15:13] == riscv::OpcodeC1Bnez)
                -------------------1-------------------

-1- Status
 0  Covered
 1  Covered

 LINE       102
 SUB-EXPRESSION (instr_i[1:0] == riscv::OpcodeC1)
                ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       105
 EXPRESSION (((instr_i[11:7] == 5'b1) | (instr_i[11:7] == 5'd5)) & rvc_jr_o)
             -------------------------1-------------------------   ----2---

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       105
 SUB-EXPRESSION ((instr_i[11:7] == 5'b1) | (instr_i[11:7] == 5'd5))
                 -----------1-----------   -----------2-----------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       105
 SUB-EXPRESSION (instr_i[11:7] == 5'b1)
                -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       105
 SUB-EXPRESSION (instr_i[11:7] == 5'd5)
                -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       108
 EXPRESSION 
 Number  Term
      1  instr_i[14] ? ({{((56 + 32'b00000000000000000000000000100000) - 64) {instr_i[12]}}, instr_i[6:5], instr_i[2], instr_i[11:10], instr_i[4:3], 1'b0}) : ({{((53 + 32'b00000000000000000000000000100000) - 64) {instr_i[12]}}, instr_i[8], instr_i[10:9], instr_i[6], instr_i[7], instr_i[2], instr_i[11], instr_i[5:3], 1'b0}))

-1- Status
 0  Covered
 1  Covered

===============================================================================
Module : ras
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/frontend/ras.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                     
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.ras_gen.i_ras 



-------------------------------------------------------------------------------
Line Coverage for Module : ras

             Line No.   Total   Covered  Percent
TOTAL                       17       17   100.00
ALWAYS             43       14       14   100.00
ALWAYS             73        3        3   100.00

42                        always_comb begin
43         1/1              stack_d = stack_q;
44                      
45                          // push on the stack
46         1/1              if (push_i) begin
47         1/1                stack_d[0].ra = data_i;
48                            // mark the new return address as valid
49         1/1                stack_d[0].valid = 1'b1;
50         1/1                stack_d[DEPTH-1:1] = stack_q[DEPTH-2:0];
51                          end
                        MISSING_ELSE
52                      
53         1/1              if (pop_i) begin
54         1/1                stack_d[DEPTH-2:0] = stack_q[DEPTH-1:1];
55                            // we popped the value so invalidate the end of the stack
56         1/1                stack_d[DEPTH-1].valid = 1'b0;
57         1/1                stack_d[DEPTH-1].ra = 'b0;
58                          end
                        MISSING_ELSE
59                          // leave everything untouched and just push the latest value to the
60                          // top of the stack
61         1/1              if (pop_i && push_i) begin
62         1/1                stack_d = stack_q;
63         1/1                stack_d[0].ra = data_i;
64         1/1                stack_d[0].valid = 1'b1;
65                          end
                        MISSING_ELSE
66                      
67         1/1              if (flush_bp_i) begin
68         unreachable        stack_d = '0;
69                          end
                        MISSING_ELSE
70                        end
71                      
72                        always_ff @(posedge clk_i or negedge rst_ni) begin
73         1/1              if (~rst_ni) begin
74         1/1                stack_q <= '0;
75                          end else begin
76         1/1                stack_q <= stack_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : ras

               Total   Covered  Percent
Conditions          3        3   100.00
Logical             3        3   100.00
Non-Logical         0        0
Event               0        0

 LINE       61
 EXPRESSION (pop_i && push_i)
             --1--    ---2--

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.ras_gen.i_ras
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME 
100.00 100.00 100.00 --     ras  


Parent : 

SCORE  LINE   COND   ASSERT NAME       
 99.24 100.00  98.47 --     i_frontend 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : cva6_pipeline
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/cva6_pipeline.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                            
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline 



-------------------------------------------------------------------------------
Line Coverage for Module : cva6_pipeline

             Line No.   Total   Covered  Percent
TOTAL                       16       16   100.00
ALWAYS            760        7        7   100.00
ALWAYS            770        9        9   100.00
INITIAL          1296        0        0

759                       always_comb begin : gen_cvxif_input_assignement
760        1/1              x_compressed_ready = cvxif_resp_i.compressed_ready;
761        1/1              x_compressed_resp  = cvxif_resp_i.compressed_resp;
762        1/1              x_issue_ready      = cvxif_resp_i.issue_ready;
763        1/1              x_issue_resp       = cvxif_resp_i.issue_resp;
764        1/1              x_register_ready   = cvxif_resp_i.register_ready;
765        1/1              x_result_valid     = cvxif_resp_i.result_valid;
766        1/1              x_result           = cvxif_resp_i.result;
767                       end
768                       if (CVA6Cfg.CvxifEn) begin
769                         always_comb begin : gen_cvxif_output_assignement
770        1/1                cvxif_req.compressed_valid = x_compressed_valid;
771        1/1                cvxif_req.compressed_req   = x_compressed_req;
772        1/1                cvxif_req.issue_valid      = x_issue_valid;
773        1/1                cvxif_req.issue_req        = x_issue_req;
774        1/1                cvxif_req.register_valid   = x_register_valid;
775        1/1                cvxif_req.register         = x_register;
776        1/1                cvxif_req.commit_valid     = x_commit_valid;
777        1/1                cvxif_req.commit           = x_commit;
778        1/1                cvxif_req.result_ready     = x_result_ready;
779                         end
780                         assign trans_id_ex_id[X_WB] = x_trans_id_ex_id;
781                         assign wbdata_ex_id[X_WB]   = x_result_ex_id;
782                         assign ex_ex_ex_id[X_WB]    = x_exception_ex_id;
783                         assign wt_valid_ex_id[X_WB] = x_valid_ex_id;
784                       end else begin
785                         assign cvxif_req = '0;
786                       end
787                       assign cvxif_req_o = cvxif_req;
788                     
789                       // ---------
790                       // Issue
791                       // ---------
792                       issue_stage #(
793                           .CVA6Cfg(CVA6Cfg),
794                           .bp_resolve_t(bp_resolve_t),
795                           .branchpredict_sbe_t(branchpredict_sbe_t),
796                           .exception_t(exception_t),
797                           .fu_data_t(fu_data_t),
798                           .scoreboard_entry_t(scoreboard_entry_t),
799                           .writeback_t(writeback_t),
800                           .x_issue_req_t(x_issue_req_t),
801                           .x_issue_resp_t(x_issue_resp_t),
802                           .x_register_t(x_register_t),
803                           .x_commit_t(x_commit_t)
804                       ) issue_stage_i (
805                           .clk_i,
806                           .rst_ni,
807                           .sb_full_o               (sb_full),
808                           .flush_unissued_instr_i  (flush_unissued_instr_ctrl_id),
809                           .flush_i                 (flush_ctrl_id),
810                           // Accelerator
811                           .stall_i                 (('0  /*FIXME*/)),
812                           // ID Stage
813                           .decoded_instr_i         (issue_entry_id_issue),
814                           .decoded_instr_i_prev    (issue_entry_id_issue_prev),
815                           .orig_instr_i            (orig_instr_id_issue),
816                           .decoded_instr_valid_i   (issue_entry_valid_id_issue),
817                           .is_ctrl_flow_i          (is_ctrl_fow_id_issue),
818                           .decoded_instr_ack_o     (issue_instr_issue_id),
819                           // Functional Units
820                           .rs1_forwarding_o        (rs1_forwarding_id_ex),
821                           .rs2_forwarding_o        (rs2_forwarding_id_ex),
822                           .fu_data_o               (fu_data_id_ex),
823                           .pc_o                    (pc_id_ex),
824                           .is_zcmt_o               (zcmt_id_ex),
825                           .is_compressed_instr_o   (is_compressed_instr_id_ex),
826                           .tinst_o                 (tinst_ex),
827                           // fixed latency unit ready
828                           .flu_ready_i             (flu_ready_ex_id),
829                           // ALU
830                           .alu_valid_o             (alu_valid_id_ex),
831                           // Branches and Jumps
832                           .branch_valid_o          (branch_valid_id_ex),            // branch is valid
833                           .branch_predict_o        (branch_predict_id_ex),          // branch predict to ex
834                           .resolve_branch_i        (resolve_branch_ex_id),          // in order to resolve the branch
835                           // LSU
836                           .lsu_ready_i             (lsu_ready_ex_id),
837                           .lsu_valid_o             (lsu_valid_id_ex),
838                           // Multiplier
839                           .mult_valid_o            (mult_valid_id_ex),
840                           // FPU
841                           .fpu_ready_i             (fpu_ready_ex_id),
842                           .fpu_valid_o             (fpu_valid_id_ex),
843                           .fpu_fmt_o               (fpu_fmt_id_ex),
844                           .fpu_rm_o                (fpu_rm_id_ex),
845                           // ALU2
846                           .alu2_valid_o            (alu2_valid_id_ex),
847                           // CSR
848                           .csr_valid_o             (csr_valid_id_ex),
849                           // CVXIF
850                           .xfu_valid_o             (x_issue_valid_id_ex),
851                           .xfu_ready_i             (x_issue_ready_ex_id),
852                           .x_off_instr_o           (x_off_instr_id_ex),
853                           .hart_id_i               (hart_id_i),
854                           .x_issue_ready_i         (x_issue_ready),
855                           .x_issue_resp_i          (x_issue_resp),
856                           .x_issue_valid_o         (x_issue_valid),
857                           .x_issue_req_o           (x_issue_req),
858                           .x_register_ready_i      (x_register_ready),
859                           .x_register_valid_o      (x_register_valid),
860                           .x_register_o            (x_register),
861                           .x_commit_valid_o        (x_commit_valid),
862                           .x_commit_o              (x_commit),
863                           .x_transaction_rejected_o(x_transaction_rejected),
864                           // Accelerator
865                           .issue_instr_o           (  /*FIXME*/),
866                           .issue_instr_hs_o        (  /*FIXME*/),
867                           // Commit
868                           .trans_id_i              (trans_id_ex_id),
869                           .resolved_branch_i       (resolved_branch),
870                           .wbdata_i                (wbdata_ex_id),
871                           .ex_ex_i                 (ex_ex_ex_id),
872                           .wt_valid_i              (wt_valid_ex_id),
873                           .x_we_i                  (x_we_ex_id),
874                           .x_rd_i                  (x_rd_ex_id),
875                     
876                           .waddr_i              (waddr_commit_id),
877                           .wdata_i              (wdata_commit_id),
878                           .we_gpr_i             (we_gpr_commit_id),
879                           .we_fpr_i             (we_fpr_commit_id),
880                           .commit_instr_o       (commit_instr_id_commit),
881                           .commit_drop_o        (commit_drop_id_commit),
882                           .commit_ack_i         (commit_ack_commit_id),
883                           // Performance Counters
884                           .stall_issue_o        (stall_issue),
885                           //RVFI
886                           .rvfi_issue_pointer_o (rvfi_issue_pointer),
887                           .rvfi_commit_pointer_o(rvfi_commit_pointer),
888                           .rvfi_rs1_o           (rvfi_rs1),
889                           .rvfi_rs2_o           (rvfi_rs2)
890                       );
891                     
892                       // ---------
893                       // EX
894                       // ---------
895                       ex_stage #(
896                           .CVA6Cfg            (CVA6Cfg),
897                           .bp_resolve_t       (bp_resolve_t),
898                           .branchpredict_sbe_t(branchpredict_sbe_t),
899                           .load_req_t         (load_req_t),
900                           .load_rsp_t         (load_rsp_t),
901                           .obi_store_req_t    (obi_store_req_t),
902                           .obi_store_rsp_t    (obi_store_rsp_t),
903                           .obi_amo_req_t      (obi_amo_req_t),
904                           .obi_amo_rsp_t      (obi_amo_rsp_t),
905                           .obi_load_req_t     (obi_load_req_t),
906                           .obi_load_rsp_t     (obi_load_rsp_t),
907                           .obi_mmu_ptw_req_t  (obi_mmu_ptw_req_t),
908                           .obi_mmu_ptw_rsp_t  (obi_mmu_ptw_rsp_t),
909                           .exception_t        (exception_t),
910                           .fu_data_t          (fu_data_t),
911                           .fetch_areq_t       (fetch_areq_t),
912                           .fetch_arsp_t       (fetch_arsp_t),
913                           .lsu_ctrl_t         (lsu_ctrl_t),
914                           .x_result_t         (x_result_t)
915                       ) ex_stage_i (
916                           .clk_i(clk_i),
917                           .rst_ni(rst_ni),
918                           .debug_mode_i(debug_mode),
919                           .flush_i(flush_ctrl_ex),
920                           .rs1_forwarding_i(rs1_forwarding_id_ex),
921                           .rs2_forwarding_i(rs2_forwarding_id_ex),
922                           .fu_data_i(fu_data_id_ex),
923                           .pc_i(pc_id_ex),
924                           .is_zcmt_i(zcmt_id_ex),
925                           .is_compressed_instr_i(is_compressed_instr_id_ex),
926                           .tinst_i(tinst_ex),
927                           // fixed latency units
928                           .flu_result_o(flu_result_ex_id),
929                           .flu_trans_id_o(flu_trans_id_ex_id),
930                           .flu_valid_o(flu_valid_ex_id),
931                           .flu_exception_o(flu_exception_ex_id),
932                           .flu_ready_o(flu_ready_ex_id),
933                           // ALU
934                           .alu_valid_i(alu_valid_id_ex),
935                           // Branches and Jumps
936                           .branch_valid_i(branch_valid_id_ex),
937                           .branch_predict_i(branch_predict_id_ex),  // branch predict to ex
938                           .resolved_branch_o(resolved_branch),
939                           .resolve_branch_o(resolve_branch_ex_id),
940                           // CSR
941                           .csr_valid_i(csr_valid_id_ex),
942                           .csr_addr_o(csr_addr_ex_csr),
943                           .csr_commit_i(csr_commit_commit_ex),  // from commit
944                           .csr_hs_ld_st_inst_o(csr_hs_ld_st_inst_ex),  // signals a Hypervisor Load/Store Instruction
945                           // MULT
946                           .mult_valid_i(mult_valid_id_ex),
947                           // LSU
948                           .lsu_ready_o(lsu_ready_ex_id),
949                           .lsu_valid_i(lsu_valid_id_ex),
950                     
951                           .load_result_o   (load_result_ex_id),
952                           .load_trans_id_o (load_trans_id_ex_id),
953                           .load_valid_o    (load_valid_ex_id),
954                           .load_exception_o(load_exception_ex_id),
955                     
956                           .store_result_o   (store_result_ex_id),
957                           .store_trans_id_o (store_trans_id_ex_id),
958                           .store_valid_o    (store_valid_ex_id),
959                           .store_exception_o(store_exception_ex_id),
960                     
961                           .lsu_commit_i            (lsu_commit_commit_ex),           // from commit
962                           .lsu_commit_ready_o      (lsu_commit_ready_ex_commit),     // to commit
963                           .commit_tran_id_i        (lsu_commit_trans_id),            // from commit
964                           // Accelerator
965                           .stall_st_pending_i      ('0  /*FIXME*/),
966                           .no_st_pending_o         (no_st_pending_ex),               //
967                           // FPU
968                           .fpu_ready_o             (fpu_ready_ex_id),
969                           .fpu_valid_i             (fpu_valid_id_ex),
970                           .fpu_fmt_i               (fpu_fmt_id_ex),
971                           .fpu_rm_i                (fpu_rm_id_ex),
972                           .fpu_frm_i               (frm_csr_id_issue_ex),
973                           .fpu_prec_i              (fprec_csr_ex),
974                           .fpu_trans_id_o          (fpu_trans_id_ex_id),
975                           .fpu_result_o            (fpu_result_ex_id),
976                           .fpu_valid_o             (fpu_valid_ex_id),
977                           .fpu_exception_o         (fpu_exception_ex_id),
978                           // ALU2
979                           .alu2_valid_i            (alu2_valid_id_ex),
980                           .amo_valid_commit_i      (amo_valid_commit),
981                           // CoreV-X-Interface
982                           .x_valid_i               (x_issue_valid_id_ex),
983                           .x_ready_o               (x_issue_ready_ex_id),
984                           .x_off_instr_i           (x_off_instr_id_ex),
985                           .x_transaction_rejected_i(x_transaction_rejected),
986                           .x_trans_id_o            (x_trans_id_ex_id),
987                           .x_exception_o           (x_exception_ex_id),
988                           .x_result_o              (x_result_ex_id),
989                           .x_valid_o               (x_valid_ex_id),
990                           .x_we_o                  (x_we_ex_id),
991                           .x_rd_o                  (x_rd_ex_id),
992                           .x_result_valid_i        (x_result_valid),
993                           .x_result_i              (x_result),
994                           .x_result_ready_o        (x_result_ready),
995                           // Accelerator
996                           .acc_valid_i             ('0  /*FIXME*/),
997                           // Performance counters
998                           .itlb_miss_o             (itlb_miss_ex_perf),
999                           .dtlb_miss_o             (dtlb_miss_ex_perf),
1000                          // Memory Management
1001                          .enable_translation_i    (enable_translation_csr_ex),      // from CSR
1002                          .enable_g_translation_i  (enable_g_translation_csr_ex),    // from CSR
1003                          .en_ld_st_translation_i  (en_ld_st_translation_csr_ex),
1004                          .en_ld_st_g_translation_i(en_ld_st_g_translation_csr_ex),
1005                          .flush_tlb_i             (flush_tlb_ctrl_ex),
1006                          .flush_tlb_vvma_i        (flush_tlb_vvma_ctrl_ex),
1007                          .flush_tlb_gvma_i        (flush_tlb_gvma_ctrl_ex),
1008                          .priv_lvl_i              (priv_lvl),                       // from CSR
1009                          .v_i                     (v),                              // from CSR
1010                          .ld_st_priv_lvl_i        (ld_st_priv_lvl_csr_ex),          // from CSR
1011                          .ld_st_v_i               (ld_st_v_csr_ex),                 // from CSR
1012                          .sum_i                   (sum_csr_ex),                     // from CSR
1013                          .vs_sum_i                (vs_sum_csr_ex),                  // from CSR
1014                          .mxr_i                   (mxr_csr_ex),                     // from CSR
1015                          .vmxr_i                  (vmxr_csr_ex),                    // from CSR
1016                          .satp_ppn_i              (satp_ppn_csr_ex),                // from CSR
1017                          .asid_i                  (asid_csr_ex),                    // from CSR
1018                          .vsatp_ppn_i             (vsatp_ppn_csr_ex),               // from CSR
1019                          .vs_asid_i               (vs_asid_csr_ex),                 // from CSR
1020                          .hgatp_ppn_i             (hgatp_ppn_csr_ex),               // from CSR
1021                          .vmid_i                  (vmid_csr_ex),                    // from CSR
1022                          .fetch_areq_i            (fetch_areq_frontend_ex),
1023                          .fetch_arsp_o            (fetch_arsp_ex_frontend),
1024                          // DCACHE interfaces
1025                          .obi_store_req_o         (obi_store_req_o),
1026                          .obi_store_rsp_i         (obi_store_rsp_i),
1027                          .obi_amo_req_o           (obi_amo_req_o),
1028                          .obi_amo_rsp_i           (obi_amo_rsp_i),
1029                          .load_req_o              (load_req_o),
1030                          .load_rsp_i              (load_rsp_i),
1031                          .obi_load_req_o          (obi_load_req_o),
1032                          .obi_load_rsp_i          (obi_load_rsp_i),
1033                          .obi_mmu_ptw_req_o       (obi_mmu_ptw_req_o),
1034                          .obi_mmu_ptw_rsp_i       (obi_mmu_ptw_rsp_i),
1035                    
1036                          .dcache_wbuffer_empty_i (dcache_wbuffer_empty_i),
1037                          .dcache_wbuffer_not_ni_i(dcache_wbuffer_not_ni_i),
1038                          // PMP
1039                          .pmpcfg_i               (pmpcfg),
1040                          .pmpaddr_i              (pmpaddr),
1041                          //RVFI
1042                          .rvfi_lsu_ctrl_o        (rvfi_lsu_ctrl),
1043                          .rvfi_mem_paddr_o       (rvfi_mem_paddr)
1044                      );
1045                    
1046                      // ---------
1047                      // Commit
1048                      // ---------
1049                    
1050                      // we have to make sure that the whole write buffer path is empty before
1051                      // used e.g. for fence instructions.
1052                      assign no_st_pending_commit = no_st_pending_ex & dcache_wbuffer_empty_i;
1053                    
1054                      commit_stage #(
1055                          .CVA6Cfg(CVA6Cfg),
1056                          .exception_t(exception_t),
1057                          .scoreboard_entry_t(scoreboard_entry_t),
1058                          .obi_amo_rsp_t(obi_amo_rsp_t)
1059                      ) commit_stage_i (
1060                          .clk_i,
1061                          .rst_ni,
1062                          .halt_i            (halt_ctrl),
1063                          .flush_dcache_i    (dcache_flush_o),
1064                          .exception_o       (ex_commit),
1065                          .dirty_fp_state_o  (dirty_fp_state),
1066                          .single_step_i     (single_step_csr_commit),         // // Accelerator /*FIXME*/
1067                          .commit_instr_i    (commit_instr_id_commit),
1068                          .commit_drop_i     (commit_drop_id_commit),
1069                          .commit_ack_o      (commit_ack_commit_id),
1070                          .commit_macro_ack_o(commit_macro_ack),
1071                          .waddr_o           (waddr_commit_id),
1072                          .wdata_o           (wdata_commit_id),
1073                          .we_gpr_o          (we_gpr_commit_id),
1074                          .we_fpr_o          (we_fpr_commit_id),
1075                          .obi_amo_rsp_i     (obi_amo_rsp_i),
1076                          .pc_o              (pc_commit),
1077                          .csr_op_o          (csr_op_commit_csr),
1078                          .csr_wdata_o       (csr_wdata_commit_csr),
1079                          .csr_rdata_i       (csr_rdata_csr_commit),
1080                          .csr_write_fflags_o(csr_write_fflags_commit_cs),
1081                          .csr_exception_i   (csr_exception_csr_commit),
1082                          .commit_lsu_o      (lsu_commit_commit_ex),
1083                          .commit_lsu_ready_i(lsu_commit_ready_ex_commit),
1084                          .commit_tran_id_o  (lsu_commit_trans_id),
1085                          .amo_valid_commit_o(amo_valid_commit),
1086                          .no_st_pending_i   (no_st_pending_commit),
1087                          .commit_csr_o      (csr_commit_commit_ex),
1088                          .fence_i_o         (fence_i_commit_controller),
1089                          .fence_o           (fence_commit_controller),
1090                          .flush_commit_o    (flush_commit),
1091                          .sfence_vma_o      (sfence_vma_commit_controller),
1092                          .hfence_vvma_o     (hfence_vvma_commit_controller),
1093                          .hfence_gvma_o     (hfence_gvma_commit_controller)
1094                      );
1095                    
1096                      assign commit_ack = commit_macro_ack & ~(commit_drop_id_commit & CVA6Cfg.SpeculativeSb);
1097                    
1098                      // ---------
1099                      // CSR
1100                      // ---------
1101                      csr_regfile #(
1102                          .CVA6Cfg           (CVA6Cfg),
1103                          .exception_t       (exception_t),
1104                          .jvt_t             (jvt_t),
1105                          .irq_ctrl_t        (irq_ctrl_t),
1106                          .scoreboard_entry_t(scoreboard_entry_t),
1107                          .rvfi_probes_csr_t (rvfi_probes_csr_t),
1108                          .MHPMCounterNum    (MHPMCounterNum)
1109                      ) csr_regfile_i (
1110                          .clk_i,
1111                          .rst_ni,
1112                          .time_irq_i,
1113                          .flush_o                 (flush_csr_ctrl),
1114                          .halt_csr_o              (halt_csr_ctrl),
1115                          .commit_instr_i          (commit_instr_id_commit[0]),
1116                          .commit_ack_i            (commit_ack),
1117                          .boot_addr_i             (boot_addr_i[CVA6Cfg.VLEN-1:0]),
1118                          .hart_id_i               (hart_id_i[CVA6Cfg.XLEN-1:0]),
1119                          .ex_i                    (ex_commit),
1120                          .csr_op_i                (csr_op_commit_csr),
1121                          .csr_addr_i              (csr_addr_ex_csr),
1122                          .csr_wdata_i             (csr_wdata_commit_csr),
1123                          .csr_rdata_o             (csr_rdata_csr_commit),
1124                          .dirty_fp_state_i        (dirty_fp_state),
1125                          .csr_write_fflags_i      (csr_write_fflags_commit_cs),
1126                          // Accelerator
1127                          .dirty_v_state_i         ('0  /*FIXME*/),
1128                          .pc_i                    (pc_commit),
1129                          .csr_exception_o         (csr_exception_csr_commit),
1130                          .epc_o                   (epc_commit_pcgen),
1131                          .eret_o                  (eret),
1132                          .trap_vector_base_o      (trap_vector_base_commit_pcgen),
1133                          .priv_lvl_o              (priv_lvl),
1134                          .v_o                     (v),
1135                          // Accelerator
1136                          .acc_fflags_ex_i         ('0  /*FIXME*/),
1137                          .acc_fflags_ex_valid_i   ('0  /*FIXME*/),
1138                          .fs_o                    (fs),
1139                          .vfs_o                   (vfs),
1140                          .fflags_o                (fflags_csr_commit),
1141                          .frm_o                   (frm_csr_id_issue_ex),
1142                          .fprec_o                 (fprec_csr_ex),
1143                          .vs_o                    (vs),
1144                          .irq_ctrl_o              (irq_ctrl_csr_id),
1145                          .en_translation_o        (enable_translation_csr_ex),
1146                          .en_g_translation_o      (enable_g_translation_csr_ex),
1147                          .en_ld_st_translation_o  (en_ld_st_translation_csr_ex),
1148                          .en_ld_st_g_translation_o(en_ld_st_g_translation_csr_ex),
1149                          .ld_st_priv_lvl_o        (ld_st_priv_lvl_csr_ex),
1150                          .ld_st_v_o               (ld_st_v_csr_ex),
1151                          .csr_hs_ld_st_inst_i     (csr_hs_ld_st_inst_ex),
1152                          .sum_o                   (sum_csr_ex),
1153                          .vs_sum_o                (vs_sum_csr_ex),
1154                          .mxr_o                   (mxr_csr_ex),
1155                          .vmxr_o                  (vmxr_csr_ex),
1156                          .satp_ppn_o              (satp_ppn_csr_ex),
1157                          .asid_o                  (asid_csr_ex),
1158                          .vsatp_ppn_o             (vsatp_ppn_csr_ex),
1159                          .vs_asid_o               (vs_asid_csr_ex),
1160                          .hgatp_ppn_o             (hgatp_ppn_csr_ex),
1161                          .vmid_o                  (vmid_csr_ex),
1162                          .irq_i,
1163                          .ipi_i,
1164                          .debug_req_i,
1165                          .set_debug_pc_o          (set_debug_pc),
1166                          .tvm_o                   (tvm_csr_id),
1167                          .tw_o                    (tw_csr_id),
1168                          .vtw_o                   (vtw_csr_id),
1169                          .tsr_o                   (tsr_csr_id),
1170                          .hu_o                    (hu),
1171                          .debug_mode_o            (debug_mode),
1172                          .single_step_o           (single_step_csr_commit),
1173                          .icache_en_o             (icache_enable_o),
1174                          .dcache_en_o             (dcache_enable_o),
1175                          // Accelerator
1176                          .acc_cons_en_o           (  /*FIXME*/),
1177                          .perf_addr_o             (addr_csr_perf),
1178                          .perf_data_o             (data_csr_perf),
1179                          .perf_data_i             (data_perf_csr),
1180                          .perf_we_o               (we_csr_perf),
1181                          .pmpcfg_o                (pmpcfg),
1182                          .pmpaddr_o               (pmpaddr),
1183                          .mcountinhibit_o         (mcountinhibit_csr_perf),
1184                          .jvt_o                   (jvt),
1185                          //RVFI
1186                          .rvfi_csr_o              (rvfi_csr)
1187                      );
1188                    
1189                      // ------------------------
1190                      // Performance Counters
1191                      // ------------------------
1192                      if (CVA6Cfg.PerfCounterEn) begin : gen_perf_counter
1193                        perf_counters #(
1194                            .CVA6Cfg           (CVA6Cfg),
1195                            .bp_resolve_t      (bp_resolve_t),
1196                            .exception_t       (exception_t),
1197                            .scoreboard_entry_t(scoreboard_entry_t),
1198                            .fetch_req_t       (fetch_req_t),
1199                            .obi_fetch_req_t   (fetch_req_t),
1200                            .obi_store_req_t   (obi_store_req_t),
1201                            .obi_amo_req_t     (obi_amo_req_t),
1202                            .load_req_t        (load_req_t),
1203                            .obi_load_req_t    (obi_load_req_t),
1204                            .obi_mmu_ptw_req_t (obi_mmu_ptw_req_t),
1205                            .NumMissPorts      (1  /*FIXME*/)         //WT cache only ??
1206                        ) perf_counters_i (
1207                            .clk_i         (clk_i),
1208                            .rst_ni        (rst_ni),
1209                            .debug_mode_i  (debug_mode),
1210                            .addr_i        (addr_csr_perf),
1211                            .we_i          (we_csr_perf),
1212                            .data_i        (data_csr_perf),
1213                            .data_o        (data_perf_csr),
1214                            .commit_instr_i(commit_instr_id_commit),
1215                            .commit_ack_i  (commit_ack),
1216                    
1217                            .l1_icache_miss_i   (icache_miss_i),
1218                            .l1_dcache_miss_i   (dcache_miss_i),
1219                            .itlb_miss_i        (itlb_miss_ex_perf),
1220                            .dtlb_miss_i        (dtlb_miss_ex_perf),
1221                            .sb_full_i          (sb_full),
1222                            // TODO this is more complex that that
1223                            // If superscalar then we additionally have to check [1] when transaction 0 succeeded
1224                            .if_empty_i         (~fetch_valid_if_id[0]),
1225                            .ex_i               (ex_commit),
1226                            .eret_i             (eret),
1227                            .resolved_branch_i  (resolved_branch),
1228                            .branch_exceptions_i(flu_exception_ex_id),
1229                    
1230                            .fetch_req_i      (fetch_req_o),
1231                            .fetch_obi_req_i  (obi_fetch_req_o),
1232                            .obi_store_req_i  (obi_store_req_o),
1233                            .obi_amo_req_i    (obi_amo_req_o),
1234                            .load_req_i       (load_req_o),
1235                            .obi_load_req_i   (obi_load_req_o),
1236                            .obi_mmu_ptw_req_i(obi_mmu_ptw_req_o),
1237                    
1238                            .miss_vld_bits_i('0  /*FIXME*/),          //WT cache only ??
1239                            .i_tlb_flush_i  (flush_tlb_ctrl_ex),
1240                            .stall_issue_i  (stall_issue),
1241                            .mcountinhibit_i(mcountinhibit_csr_perf)
1242                        );
1243                      end : gen_perf_counter
1244                      else begin : gen_no_perf_counter
1245                        assign data_perf_csr = '0;
1246                      end : gen_no_perf_counter
1247                    
1248                      // ------------
1249                      // Controller
1250                      // ------------
1251                      controller #(
1252                          .CVA6Cfg(CVA6Cfg),
1253                          .bp_resolve_t(bp_resolve_t)
1254                      ) controller_i (
1255                          .clk_i,
1256                          .rst_ni,
1257                          // virtualization mode
1258                          .v_i                   (v),
1259                          // flush ports
1260                          .set_pc_commit_o       (set_pc_ctrl_pcgen),
1261                          .flush_if_o            (flush_ctrl_if),
1262                          .flush_unissued_instr_o(flush_unissued_instr_ctrl_id),
1263                          .flush_id_o            (flush_ctrl_id),
1264                          .flush_ex_o            (flush_ctrl_ex),
1265                          .flush_bp_o            (flush_ctrl_bp),
1266                          .flush_icache_o        (icache_flush_o),
1267                          .flush_dcache_o        (dcache_flush_o),
1268                          .flush_dcache_ack_i    (dcache_flush_ack_i),
1269                          .flush_tlb_o           (flush_tlb_ctrl_ex),
1270                          .flush_tlb_vvma_o      (flush_tlb_vvma_ctrl_ex),
1271                          .flush_tlb_gvma_o      (flush_tlb_gvma_ctrl_ex),
1272                          .halt_csr_i            (halt_csr_ctrl),
1273                          // Accelerator
1274                          .halt_acc_i            ('0  /*FIXME*/),
1275                          .halt_o                (halt_ctrl),
1276                          // control ports
1277                          .eret_i                (eret),
1278                          .ex_valid_i            (ex_commit.valid),
1279                          .set_debug_pc_i        (set_debug_pc),
1280                          .resolved_branch_i     (resolved_branch),
1281                          .flush_csr_i           (flush_csr_ctrl),
1282                          .fence_i_i             (fence_i_commit_controller),
1283                          .fence_i               (fence_commit_controller),
1284                          .sfence_vma_i          (sfence_vma_commit_controller),
1285                          .hfence_vvma_i         (hfence_vvma_commit_controller),
1286                          .hfence_gvma_i         (hfence_gvma_commit_controller),
1287                          .flush_commit_i        (flush_commit),
1288                          // Accelerator
1289                          .flush_acc_i           ('0  /*FIXME*/)
1290                      );
1291                    
1292                      // -------------------
1293                      // Parameter Check
1294                      // -------------------
1295                      // pragma translate_off
1296       unreachable    initial config_pkg::check_cfg(CVA6Cfg);

-------------------------------------------------------------------------------
Cond Coverage for Module : cva6_pipeline

               Total   Covered  Percent
Conditions          4        4   100.00
Logical             4        4   100.00
Non-Logical         0        0
Event               0        0

 LINE       1052
 EXPRESSION (no_st_pending_ex & dcache_wbuffer_empty_i)
             --------1-------   -----------2----------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       1096
 EXPRESSION (commit_macro_ack & ((~(commit_drop_id_commit & 1'b0))))
             --------1-------   -----------------2-----------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.09  99.79  98.39 --     


Module : 

SCORE  LINE   COND   ASSERT NAME          
100.00 100.00 100.00 --     cva6_pipeline 


Parent : 

SCORE  LINE   COND   ASSERT NAME              
--     --     --     --     cva6_tb_wrapper_i 


Subtrees :

SCORE  LINE   COND   ASSERT NAME           
100.00 100.00 100.00 --     commit_stage_i 
100.00 100.00 100.00 --     controller_i   
 98.78 100.00  97.56 --     csr_regfile_i  
 99.81  99.81  99.81 --     ex_stage_i     
 99.70 100.00  99.39 --     i_frontend     
 99.12  99.42  98.81 --     id_stage_i     
 97.36  99.62  95.10 --     issue_stage_i  



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : ex_stage
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/ex_stage.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                       
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i 



-------------------------------------------------------------------------------
Line Coverage for Module : ex_stage

             Line No.   Total   Covered  Percent
TOTAL                       21       21   100.00
ALWAYS            303        4        4   100.00
ALWAYS            377        9        9   100.00
ALWAYS            393        1        1   100.00
ALWAYS            400        2        2   100.00
ALWAYS            531        3        3   100.00
ALWAYS            633        2        2   100.00

302                         // data silence operation
303        1/1              one_cycle_data = one_cycle_select[0] ? fu_data_i[0] : '0;
304        1/1              rs1_forwarding = rs1_forwarding_i[0];
305        1/1              rs2_forwarding = rs2_forwarding_i[0];
306                     
307        1/1              if (CVA6Cfg.SuperscalarEn) begin
308        unreachable        if (one_cycle_select[1]) begin
309        unreachable          one_cycle_data = fu_data_i[1];
310        unreachable          rs1_forwarding = rs1_forwarding_i[1];
311        unreachable          rs2_forwarding = rs2_forwarding_i[1];
312                           end
                   ==>  MISSING_ELSE
313                         end
                        MISSING_ELSE
314                       end
315                     
316                       // 1. ALU (combinatorial)
317                       alu #(
318                           .CVA6Cfg  (CVA6Cfg),
319                           .HasBranch(1'b1),
320                           .fu_data_t(fu_data_t)
321                       ) alu_i (
322                           .clk_i,
323                           .rst_ni,
324                           .fu_data_i       (one_cycle_data),
325                           .result_o        (alu_result),
326                           .alu_branch_res_o(alu_branch_res)
327                       );
328                     
329                       // 2. Branch Unit (combinatorial)
330                       // we don't silence the branch unit as this is already critical and we do
331                       // not want to add another layer of logic
332                       branch_unit #(
333                           .CVA6Cfg(CVA6Cfg),
334                           .bp_resolve_t(bp_resolve_t),
335                           .branchpredict_sbe_t(branchpredict_sbe_t),
336                           .exception_t(exception_t),
337                           .fu_data_t(fu_data_t)
338                       ) branch_unit_i (
339                           .clk_i,
340                           .rst_ni,
341                           .v_i,
342                           .debug_mode_i,
343                           .fu_data_i         (one_cycle_data),
344                           .pc_i,
345                           .is_zcmt_i,
346                           .is_compressed_instr_i,
347                           .branch_valid_i    (|branch_valid_i),
348                           .branch_comp_res_i (alu_branch_res),
349                           .branch_result_o   (branch_result),
350                           .branch_predict_i,
351                           .resolved_branch_o,
352                           .resolve_branch_o,
353                           .branch_exception_o(flu_exception_o)
354                       );
355                     
356                       // 3. CSR (sequential)
357                       csr_buffer #(
358                           .CVA6Cfg  (CVA6Cfg),
359                           .fu_data_t(fu_data_t)
360                       ) csr_buffer_i (
361                           .clk_i,
362                           .rst_ni,
363                           .flush_i,
364                           .fu_data_i   (one_cycle_data),
365                           .csr_valid_i (|csr_valid_i),
366                           .csr_ready_o (csr_ready),
367                           .csr_result_o(csr_result),
368                           .csr_commit_i,
369                           .csr_addr_o
370                       );
371                     
372                       assign flu_valid_o = |one_cycle_select | mult_valid;
373                     
374                       // result MUX
375                       always_comb begin
376                         // Branch result as default case
377        1/1              flu_result_o   = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{1'b0}}, branch_result};
378        1/1              flu_trans_id_o = one_cycle_data.trans_id;
379                         // ALU result
380        1/1              if (|alu_valid_i) begin
381        1/1                flu_result_o = alu_result;
382                           // CSR result
383        1/1              end else if (|csr_valid_i) begin
384        1/1                flu_result_o = csr_result;
385        1/1              end else if (mult_valid) begin
386        1/1                flu_result_o   = mult_result;
387        1/1                flu_trans_id_o = mult_trans_id;
388                         end
                        MISSING_ELSE
389                       end
390                     
391                       // ready flags for FLU
392                       always_comb begin
393        1/1              flu_ready_o = csr_ready & mult_ready;
394                       end
395                     
396                       // 4. Multiplication (Sequential)
397                       fu_data_t mult_data;
398                       // input silencing of multiplier
399                       always_comb begin
400        1/1              mult_data = mult_valid_i[0] ? fu_data_i[0] : '0;
401        1/1              if (CVA6Cfg.SuperscalarEn) begin
402        unreachable        if (mult_valid_i[1]) begin
403        unreachable          mult_data = fu_data_i[1];
404                           end
                   ==>  MISSING_ELSE
405                         end
                        MISSING_ELSE
406                       end
407                     
408                       mult #(
409                           .CVA6Cfg  (CVA6Cfg),
410                           .fu_data_t(fu_data_t)
411                       ) i_mult (
412                           .clk_i,
413                           .rst_ni,
414                           .flush_i,
415                           .mult_valid_i   (|mult_valid_i),
416                           .fu_data_i      (mult_data),
417                           .result_o       (mult_result),
418                           .mult_valid_o   (mult_valid),
419                           .mult_ready_o   (mult_ready),
420                           .mult_trans_id_o(mult_trans_id)
421                       );
422                     
423                       // ----------------
424                       // FPU
425                       // ----------------
426                       logic fpu_valid;
427                       logic [CVA6Cfg.TRANS_ID_BITS-1:0] fpu_trans_id;
428                       logic [CVA6Cfg.XLEN-1:0] fpu_result;
429                       logic alu2_valid;
430                       logic [CVA6Cfg.XLEN-1:0] alu2_result;
431                     
432                       generate
433                         if (CVA6Cfg.FpPresent) begin : fpu_gen
434                           fu_data_t fpu_data;
435                           always_comb begin
436                             fpu_data = fpu_valid_i[0] ? fu_data_i[0] : '0;
437                             if (CVA6Cfg.SuperscalarEn) begin
438                               if (fpu_valid_i[1]) begin
439                                 fpu_data = fu_data_i[1];
440                               end
441                             end
442                           end
443                     
444                           fpu_wrap #(
445                               .CVA6Cfg(CVA6Cfg),
446                               .exception_t(exception_t),
447                               .fu_data_t(fu_data_t)
448                           ) fpu_i (
449                               .clk_i,
450                               .rst_ni,
451                               .flush_i,
452                               .fpu_valid_i(|fpu_valid_i),
453                               .fpu_ready_o,
454                               .fu_data_i(fpu_data),
455                               .fpu_fmt_i,
456                               .fpu_rm_i,
457                               .fpu_frm_i,
458                               .fpu_prec_i,
459                               .fpu_trans_id_o(fpu_trans_id),
460                               .result_o(fpu_result),
461                               .fpu_valid_o(fpu_valid),
462                               .fpu_exception_o
463                           );
464                         end else begin : no_fpu_gen
465                           assign fpu_ready_o     = '0;
466                           assign fpu_trans_id    = '0;
467                           assign fpu_result      = '0;
468                           assign fpu_valid       = '0;
469                           assign fpu_exception_o = '0;
470                         end
471                       endgenerate
472                     
473                       // ----------------
474                       // ALU2
475                       // ----------------
476                       fu_data_t alu2_data;
477                       if (CVA6Cfg.SuperscalarEn) begin : alu2_gen
478                         always_comb begin
479                           alu2_data = alu2_valid_i[0] ? fu_data_i[0] : '0;
480                           if (alu2_valid_i[1]) begin
481                             alu2_data = fu_data_i[1];
482                           end
483                         end
484                     
485                         alu #(
486                             .CVA6Cfg  (CVA6Cfg),
487                             .HasBranch(1'b0),
488                             .fu_data_t(fu_data_t)
489                         ) alu2_i (
490                             .clk_i,
491                             .rst_ni,
492                             .fu_data_i       (alu2_data),
493                             .result_o        (alu2_result),
494                             .alu_branch_res_o(  /* this ALU does not handle branching */)
495                         );
496                       end else begin
497                         assign alu2_data   = '0;
498                         assign alu2_result = '0;
499                       end
500                     
501                       // result MUX
502                       // This is really explicit so that synthesis tools can elide unused signals
503                       if (CVA6Cfg.SuperscalarEn) begin
504                         if (CVA6Cfg.FpPresent) begin
505                           assign fpu_valid_o    = fpu_valid || |alu2_valid_i;
506                           assign fpu_result_o   = fpu_valid ? fpu_result   : alu2_result;
507                           assign fpu_trans_id_o = fpu_valid ? fpu_trans_id : alu2_data.trans_id;
508                         end else begin
509                           assign fpu_valid_o    = |alu2_valid_i;
510                           assign fpu_result_o   = alu2_result;
511                           assign fpu_trans_id_o = alu2_data.trans_id;
512                         end
513                       end else begin
514                         if (CVA6Cfg.FpPresent) begin
515                           assign fpu_valid_o    = fpu_valid;
516                           assign fpu_result_o   = fpu_result;
517                           assign fpu_trans_id_o = fpu_trans_id;
518                         end else begin
519                           assign fpu_valid_o    = '0;
520                           assign fpu_result_o   = '0;
521                           assign fpu_trans_id_o = '0;
522                         end
523                       end
524                     
525                       // ----------------
526                       // Load-Store Unit
527                       // ----------------
528                       fu_data_t lsu_data;
529                       logic [31:0] lsu_tinst;
530                       always_comb begin
531        1/1              lsu_data  = lsu_valid_i[0] ? fu_data_i[0] : '0;
532        1/1              lsu_tinst = tinst_i[0];
533                     
534        1/1              if (CVA6Cfg.SuperscalarEn) begin
535        unreachable        if (lsu_valid_i[1]) begin
536        unreachable          lsu_data  = fu_data_i[1];
537        unreachable          lsu_tinst = tinst_i[1];
538                           end
                   ==>  MISSING_ELSE
539                         end
                        MISSING_ELSE
540                       end
541                     
542                       load_store_unit #(
543                           .CVA6Cfg          (CVA6Cfg),
544                           .load_req_t       (load_req_t),
545                           .load_rsp_t       (load_rsp_t),
546                           .obi_store_req_t  (obi_store_req_t),
547                           .obi_store_rsp_t  (obi_store_rsp_t),
548                           .obi_amo_req_t    (obi_amo_req_t),
549                           .obi_amo_rsp_t    (obi_amo_rsp_t),
550                           .obi_load_req_t   (obi_load_req_t),
551                           .obi_load_rsp_t   (obi_load_rsp_t),
552                           .obi_mmu_ptw_req_t(obi_mmu_ptw_req_t),
553                           .obi_mmu_ptw_rsp_t(obi_mmu_ptw_rsp_t),
554                           .exception_t      (exception_t),
555                           .fu_data_t        (fu_data_t),
556                           .fetch_areq_t     (fetch_areq_t),
557                           .fetch_arsp_t     (fetch_arsp_t),
558                           .lsu_ctrl_t       (lsu_ctrl_t)
559                       ) lsu_i (
560                           .clk_i,
561                           .rst_ni,
562                           .flush_i,
563                           .stall_st_pending_i,
564                           .no_st_pending_o,
565                           .fu_data_i             (lsu_data),
566                           .lsu_ready_o,
567                           .lsu_valid_i           (|lsu_valid_i),
568                           .load_trans_id_o,
569                           .load_result_o,
570                           .load_valid_o,
571                           .load_exception_o,
572                           .store_trans_id_o,
573                           .store_result_o,
574                           .store_valid_o,
575                           .store_exception_o,
576                           .commit_i              (lsu_commit_i),
577                           .commit_ready_o        (lsu_commit_ready_o),
578                           .commit_tran_id_i,
579                           .enable_translation_i,
580                           .enable_g_translation_i,
581                           .en_ld_st_translation_i,
582                           .en_ld_st_g_translation_i,
583                           .fetch_areq_i,
584                           .fetch_arsp_o,
585                           .priv_lvl_i,
586                           .v_i,
587                           .ld_st_priv_lvl_i,
588                           .ld_st_v_i,
589                           .csr_hs_ld_st_inst_o,
590                           .sum_i,
591                           .vs_sum_i,
592                           .mxr_i,
593                           .vmxr_i,
594                           .satp_ppn_i,
595                           .vsatp_ppn_i,
596                           .hgatp_ppn_i,
597                           .asid_i,
598                           .vs_asid_i,
599                           .asid_to_be_flushed_i  (asid_to_be_flushed),
600                           .vmid_i,
601                           .vmid_to_be_flushed_i  (vmid_to_be_flushed),
602                           .vaddr_to_be_flushed_i (vaddr_to_be_flushed),
603                           .gpaddr_to_be_flushed_i(gpaddr_to_be_flushed),
604                           .flush_tlb_i,
605                           .flush_tlb_vvma_i,
606                           .flush_tlb_gvma_i,
607                           .itlb_miss_o,
608                           .dtlb_miss_o,
609                           // DCACHE interfaces
610                           .obi_amo_req_o         (obi_amo_req_o),
611                           .obi_amo_rsp_i         (obi_amo_rsp_i),
612                           .obi_store_req_o       (obi_store_req_o),
613                           .obi_store_rsp_i       (obi_store_rsp_i),
614                           .obi_load_req_o        (obi_load_req_o),
615                           .obi_load_rsp_i        (obi_load_rsp_i),
616                           .load_req_o            (load_req_o),
617                           .load_rsp_i            (load_rsp_i),
618                           .obi_mmu_ptw_req_o     (obi_mmu_ptw_req_o),
619                           .obi_mmu_ptw_rsp_i     (obi_mmu_ptw_rsp_i),
620                           .dcache_wbuffer_empty_i,
621                           .dcache_wbuffer_not_ni_i,
622                           .amo_valid_commit_i,
623                           .tinst_i               (lsu_tinst),
624                           .pmpcfg_i,
625                           .pmpaddr_i,
626                           .rvfi_lsu_ctrl_o,
627                           .rvfi_mem_paddr_o
628                       );
629                     
630                       if (CVA6Cfg.CvxifEn) begin : gen_cvxif
631                         fu_data_t cvxif_data;
632                         always_comb begin
633        1/1                cvxif_data = x_valid_i[0] ? fu_data_i[0] : '0;
634        1/1                if (CVA6Cfg.SuperscalarEn) begin
635        unreachable          if (x_valid_i[1]) begin
636        unreachable            cvxif_data = fu_data_i[1];
637                             end
                   ==>  MISSING_ELSE
638                           end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : ex_stage

               Total   Covered  Percent
Conditions         18       18   100.00
Logical            18       18   100.00
Non-Logical         0        0
Event               0        0

 LINE       303
 EXPRESSION (one_cycle_select[0] ? fu_data_i[0] : '0)
             ---------1---------

-1- Status
 0  Covered
 1  Covered

 LINE       393
 EXPRESSION (csr_ready & mult_ready)
             ----1----   -----2----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       400
 EXPRESSION (mult_valid_i[0] ? fu_data_i[0] : '0)
             -------1-------

-1- Status
 0  Covered
 1  Covered

 LINE       531
 EXPRESSION (lsu_valid_i[0] ? fu_data_i[0] : '0)
             -------1------

-1- Status
 0  Covered
 1  Covered

 LINE       633
 EXPRESSION (x_valid_i[0] ? fu_data_i[0] : '0)
             ------1-----

-1- Status
 0  Covered
 1  Covered

 LINE       296
 EXPRESSION (alu_valid_i | branch_valid_i | csr_valid_i)
             -----1-----   -------2------   -----3-----

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Covered
 0   1   0  Covered
 1   0   0  Covered

 LINE       372
 EXPRESSION (((|one_cycle_select)) | mult_valid)
             ----------1----------   -----2----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.81  99.81  99.81 --     


Module : 

SCORE  LINE   COND   ASSERT NAME     
100.00 100.00 100.00 --     ex_stage 


Parent : 

SCORE  LINE   COND   ASSERT NAME                               
100.00 100.00 100.00 --     cva6_only_pipeline.i_cva6_pipeline 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                 
100.00 100.00 100.00 --     alu_i                
100.00 100.00 100.00 --     branch_unit_i        
100.00 100.00 100.00 --     csr_buffer_i         
100.00 100.00 100.00 --     gen_cvxif.cvxif_fu_i 
 99.83 100.00  99.66 --     i_mult               
 99.83  99.65 100.00 --     lsu_i                



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : instr_queue
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/frontend/instr_queue.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                     
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue 



-------------------------------------------------------------------------------
Line Coverage for Module : instr_queue

             Line No.   Total   Covered  Percent
TOTAL                       52       52   100.00
ALWAYS            321       28       28   100.00
ALWAYS            440        8        8   100.00
ALWAYS            486        3        3   100.00
ALWAYS            515       13       13   100.00

320                         always_comb begin
321        1/1                idx_ds_d  = idx_ds_q;
322                     
323        1/1                pop_instr = '0;
324                           // assemble fetch entry
325        1/1                for (int unsigned i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
326        1/1                  fetch_entry_o[i].instruction = '0;
327        1/1                  fetch_entry_o[i].address = pc_j[i];
328        1/1                  fetch_entry_o[i].ex.valid = 1'b0;
329        1/1                  fetch_entry_o[i].ex.cause = '0;
330                     
331        1/1                  fetch_entry_o[i].ex.tval = '0;
332        1/1                  fetch_entry_o[i].ex.tval2 = '0;
333        1/1                  fetch_entry_o[i].ex.gva = 1'b0;
334        1/1                  fetch_entry_o[i].ex.tinst = '0;
335        1/1                  fetch_entry_o[i].branch_predict.predict_address = address_out;
336        1/1                  fetch_entry_o[i].branch_predict.cf = ariane_pkg::NoCF;
337                           end
338                     
339                           // output mux select
340        1/1                for (int unsigned i = 0; i < CVA6Cfg.INSTR_PER_FETCH; i++) begin
341        1/1                  if (idx_ds[0][i]) begin
342        1/1                    if (CVA6Cfg.NrPMPEntries != 0 && instr_data_out[i].ex == ariane_pkg::FE_INSTR_ACCESS_FAULT) begin
343        unreachable              fetch_entry_o[0].ex.cause = riscv::INSTR_ACCESS_FAULT;
344        1/1                    end else if (CVA6Cfg.RVH && instr_data_out[i].ex == ariane_pkg::FE_INSTR_GUEST_PAGE_FAULT) begin
345        unreachable              fetch_entry_o[0].ex.cause = riscv::INSTR_GUEST_PAGE_FAULT;
346                               end else begin
347        1/1                      fetch_entry_o[0].ex.cause = riscv::INSTR_PAGE_FAULT;
348                               end
349        1/1                    fetch_entry_o[0].instruction = instr_data_out[i].instr;
350        1/1                    fetch_entry_o[0].ex.valid = ((CVA6Cfg.MmuPresent || CVA6Cfg.NrPMPEntries !=0) && instr_data_out[i].ex != ariane_pkg::FE_NONE);
351        1/1                    if (CVA6Cfg.TvalEn)
352        unreachable              fetch_entry_o[0].ex.tval = {
                        MISSING_ELSE
353                                   {(CVA6Cfg.XLEN - CVA6Cfg.VLEN) {1'b0}}, instr_data_out[i].ex_vaddr
354                                 };
355        1/1                    if (CVA6Cfg.RVH) begin
356        unreachable              fetch_entry_o[0].ex.tval2 = instr_data_out[i].ex_gpaddr;
357        unreachable              fetch_entry_o[0].ex.tinst = instr_data_out[i].ex_tinst;
358        unreachable              fetch_entry_o[0].ex.gva   = instr_data_out[i].ex_gva;
359                               end
                        MISSING_ELSE
360        1/1                    fetch_entry_o[0].branch_predict.cf = instr_data_out[i].cf;
361        1/1                    pop_instr[i] = fetch_entry_fire[0];
362                             end
                        MISSING_ELSE
363                     
364        1/1                  if (CVA6Cfg.SuperscalarEn) begin
365        unreachable            if (idx_ds[1][i]) begin
366        unreachable              if (instr_data_out[i].ex == ariane_pkg::FE_INSTR_ACCESS_FAULT) begin
367        unreachable                fetch_entry_o[NID].ex.cause = riscv::INSTR_ACCESS_FAULT;
368                                 end else begin
369        unreachable                fetch_entry_o[NID].ex.cause = riscv::INSTR_PAGE_FAULT;
370                                 end
371        unreachable              fetch_entry_o[NID].instruction = instr_data_out[i].instr;
372        unreachable              fetch_entry_o[NID].ex.valid = instr_data_out[i].ex != ariane_pkg::FE_NONE;
373        unreachable              fetch_entry_o[NID].ex.tval = {{64 - CVA6Cfg.VLEN{1'b0}}, instr_data_out[i].ex_vaddr};
374        unreachable              fetch_entry_o[NID].branch_predict.cf = instr_data_out[i].cf;
375                                 // Cannot output two CF the same cycle.
376        unreachable              pop_instr[i] = fetch_entry_fire[NID];
377                               end
                   ==>  MISSING_ELSE
378                             end
                        MISSING_ELSE
379                           end
380                           // rotate the pointer left
381        1/1                if (fetch_entry_fire[0]) begin
382        1/1                  if (CVA6Cfg.SuperscalarEn) begin
383        unreachable            idx_ds_d = fetch_entry_fire[NID] ? idx_ds[2] : idx_ds[1];
384                             end else begin
385        1/1                    idx_ds_d = idx_ds[1];
386                             end
387                           end
                        MISSING_ELSE
388                         end
389                       end else begin : gen_downstream_itf_without_c
390                         always_comb begin
391                           idx_ds_d = '0;
392                           idx_is_d = '0;
393                           fetch_entry_o[0].instruction = instr_data_out[0].instr;
394                           fetch_entry_o[0].address = pc_q;
395                     
396                           fetch_entry_o[0].ex.valid = instr_data_out[0].ex != ariane_pkg::FE_NONE;
397                           if (instr_data_out[0].ex == ariane_pkg::FE_INSTR_ACCESS_FAULT) begin
398                             fetch_entry_o[0].ex.cause = riscv::INSTR_ACCESS_FAULT;
399                           end else begin
400                             fetch_entry_o[0].ex.cause = riscv::INSTR_PAGE_FAULT;
401                           end
402                           if (CVA6Cfg.TvalEn)
403                             fetch_entry_o[0].ex.tval = {{64 - CVA6Cfg.VLEN{1'b0}}, instr_data_out[0].ex_vaddr};
404                           else fetch_entry_o[0].ex.tval = '0;
405                           if (CVA6Cfg.RVH) begin
406                             fetch_entry_o[0].ex.tval2 = instr_data_out[0].ex_gpaddr;
407                             fetch_entry_o[0].ex.tinst = instr_data_out[0].ex_tinst;
408                             fetch_entry_o[0].ex.gva   = instr_data_out[0].ex_gva;
409                           end else begin
410                             fetch_entry_o[0].ex.tval2 = '0;
411                             fetch_entry_o[0].ex.tinst = '0;
412                             fetch_entry_o[0].ex.gva   = 1'b0;
413                           end
414                     
415                           fetch_entry_o[0].branch_predict.predict_address = address_out;
416                           fetch_entry_o[0].branch_predict.cf = instr_data_out[0].cf;
417                     
418                           pop_instr[0] = fetch_entry_valid_o[0] & fetch_entry_ready_i[0];
419                         end
420                       end
421                     
422                       for (genvar i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
423                         assign fetch_entry_is_cf[i] = fetch_entry_o[i].branch_predict.cf != ariane_pkg::NoCF;
424                         assign fetch_entry_fire[i]  = fetch_entry_valid_o[i] & fetch_entry_ready_i[i];
425                       end
426                     
427                       assign pop_address = |(fetch_entry_is_cf & fetch_entry_fire);
428                     
429                       // ----------------------
430                       // Calculate (Next) PC
431                       // ----------------------
432                       assign pc_j[0] = pc_q;
433                       for (genvar i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
434                         assign pc_j[i+1] = fetch_entry_is_cf[i] ? address_out : (
435                           pc_j[i] + ((fetch_entry_o[i].instruction[1:0] != 2'b11) ? 'd2 : 'd4)
436                         );
437                       end
438                     
439                       always_comb begin
440        1/1              pc_d = pc_q;
441        1/1              reset_address_d = flush_i ? 1'b1 : reset_address_q;
442                     
443        1/1              if (fetch_entry_fire[0]) begin
444        1/1                pc_d = pc_j[1];
445        1/1                if (CVA6Cfg.SuperscalarEn) begin
446        unreachable          if (fetch_entry_fire[NID]) begin
447        unreachable            pc_d = pc_j[2];
448                             end
                   ==>  MISSING_ELSE
449                           end
                        MISSING_ELSE
450                         end
                        MISSING_ELSE
451                     
452                         // we previously flushed so we need to reset the address
453        1/1              if (valid_i[0] && reset_address_q) begin
454                           // this is the base of the first instruction
455        1/1                pc_d = addr_i[0];
456        1/1                reset_address_d = 1'b0;
457                         end
                        MISSING_ELSE
458                       end
459                     
460                       // FIFOs
461                       for (genvar i = 0; i < CVA6Cfg.INSTR_PER_FETCH; i++) begin : gen_instr_fifo
462                         // Make sure we don't save any instructions if we couldn't save the address
463                         assign push_instr_fifo[i] = push_instr[i] & ~address_overflow;
464                         cva6_fifo_v3 #(
465                             .FPGA_ALTERA(CVA6Cfg.FpgaAlteraEn),
466                             .DEPTH(ariane_pkg::FETCH_FIFO_DEPTH),
467                             .dtype(instr_data_t),
468                             .FPGA_EN(CVA6Cfg.FpgaEn)
469                         ) i_fifo_instr_data (
470                             .clk_i     (clk_i),
471                             .rst_ni    (rst_ni),
472                             .flush_i   (flush_i),
473                             .testmode_i(1'b0),
474                             .full_o    (instr_queue_full[i]),
475                             .empty_o   (instr_queue_empty[i]),
476                             .usage_o   (),
477                             .data_i    (instr_data_in[i]),
478                             .push_i    (push_instr_fifo[i]),
479                             .data_o    (instr_data_out[i]),
480                             .pop_i     (pop_instr[i])
481                         );
482                       end
483                       // or reduce and check whether we are retiring a taken branch (might be that the corresponding)
484                       // fifo is full.
485                       always_comb begin
486        1/1              push_address = 1'b0;
487                         // check if we are pushing a ctrl flow change, if so save the address
488        1/1              for (int i = 0; i < CVA6Cfg.INSTR_PER_FETCH; i++) begin
489        1/1                push_address |= push_instr[i] & (instr_data_in[i].cf != ariane_pkg::NoCF);
490                         end
491                       end
492                     
493                       cva6_fifo_v3 #(
494                           .FPGA_ALTERA(CVA6Cfg.FpgaAlteraEn),
495                           .DEPTH      (ariane_pkg::FETCH_ADDR_FIFO_DEPTH),
496                           .DATA_WIDTH (CVA6Cfg.VLEN),
497                           .FPGA_EN    (CVA6Cfg.FpgaEn)
498                       ) i_fifo_address (
499                           .clk_i     (clk_i),
500                           .rst_ni    (rst_ni),
501                           .flush_i   (flush_i),
502                           .testmode_i(1'b0),
503                           .full_o    (full_address),
504                           .empty_o   (),
505                           .usage_o   (),
506                           .data_i    (predict_address_i),
507                           .push_i    (push_address & ~full_address),
508                           .data_o    (address_out),
509                           .pop_i     (pop_address)
510                       );
511                     
512                     
513                       if (CVA6Cfg.RVC) begin : gen_pc_q_with_c
514                         always_ff @(posedge clk_i or negedge rst_ni) begin
515        1/1                if (!rst_ni) begin
516        1/1                  idx_ds_q        <= 'b1;
517        1/1                  idx_is_q        <= '0;
518        1/1                  pc_q            <= '0;
519        1/1                  reset_address_q <= 1'b1;
520                           end else begin
521        1/1                  pc_q            <= pc_d;
522        1/1                  reset_address_q <= reset_address_d;
523        1/1                  if (flush_i) begin
524                               // one-hot encoded
525        1/1                    idx_ds_q        <= 'b1;
526                               // binary encoded
527        1/1                    idx_is_q        <= '0;
528        1/1                    reset_address_q <= 1'b1;
529                             end else begin
530        1/1                    idx_ds_q <= idx_ds_d;
531        1/1                    idx_is_q <= idx_is_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : instr_queue

               Total   Covered  Percent
Conditions         45       45   100.00
Logical            45       45   100.00
Non-Logical         0        0
Event               0        0

 LINE       441
 EXPRESSION (flush_i ? 1'b1 : reset_address_q)
             ---1---

-1- Status
 0  Covered
 1  Covered

 LINE       453
 EXPRESSION (valid_i[0] && reset_address_q)
             -----1----    -------2-------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       489
 EXPRESSION (push_instr[i] & (instr_data_in[i].cf != NoCF))
             ------1------   --------------2--------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       489
 SUB-EXPRESSION (instr_data_in[i].cf != NoCF)
                --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       366
 EXPRESSION (instr_data_out[i].ex == FE_INSTR_ACCESS_FAULT)
            -----------------------1-----------------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       372
 EXPRESSION (instr_data_out[i].ex != FE_NONE)
            ----------------1----------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       383
 EXPRESSION (fetch_entry_fire[NID] ? idx_ds[2] : idx_ds[1])
             ----------1----------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       498
 EXPRESSION (push_address & ((~full_address)))
             ------1-----   --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       151
 EXPRESSION (((~(|instr_queue_full))) & ((~full_address)))
             ------------1-----------   --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       285
 EXPRESSION (full_address & push_address)
             ------1-----   ------2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       286
 EXPRESSION (instr_overflow | address_overflow)
             -------1------   --------2-------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       156
 EXPRESSION (cf_type_i[0] != NoCF)
            -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       156
 EXPRESSION (cf_type_i[1] != NoCF)
            -----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       293
 EXPRESSION (address_overflow ? addr_i[0] : addr_i[shamt])
             --------1-------

-1- Status
 0  Covered
 1  Covered

 LINE       423
 EXPRESSION (fetch_entry_o[0].branch_predict.cf != NoCF)
            ----------------------1---------------------

-1- Status
 0  Covered
 1  Covered

 LINE       424
 EXPRESSION (fetch_entry_valid_o[0] & fetch_entry_ready_i[0])
             -----------1----------   -----------2----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       434
 EXPRESSION (fetch_entry_is_cf[0] ? address_out : (pc_j[0] + ((fetch_entry_o[0].instruction[1:0] != 2'b11) ? 'd2 : 'd4)))
             ----------1---------

-1- Status
 0  Covered
 1  Covered

 LINE       434
 SUB-EXPRESSION ((fetch_entry_o[0].instruction[1:0] != 2'b11) ? 'd2 : 'd4)
                 ----------------------1---------------------

-1- Status
 0  Covered
 1  Covered

 LINE       434
 SUB-EXPRESSION (fetch_entry_o[0].instruction[1:0] != 2'b11)
                ----------------------1---------------------

-1- Status
 0  Covered
 1  Covered

 LINE       463
 EXPRESSION (push_instr[0] & ((~address_overflow)))
             ------1------   ----------2----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       463
 EXPRESSION (push_instr[1] & ((~address_overflow)))
             ------1------   ----------2----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME        
100.00 100.00 100.00 --     instr_queue 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
 99.24 100.00  98.47 --     i_frontend 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                                                   
100.00 100.00 100.00 --     gen_instr_fifo[0].i_fifo_instr_data                    
100.00 100.00 100.00 --     gen_multiple_instr_per_fetch_with_C.i_lzc_branch_index 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : bht
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/frontend/bht.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                     
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.bht_gen.i_bht 



-------------------------------------------------------------------------------
Line Coverage for Module : bht

             Line No.   Total   Covered  Percent
TOTAL                       19       19   100.00
ALWAYS             82       13       13   100.00
ALWAYS            106        6        6   100.00

81                          always_comb begin : update_bht
82         1/1                bht_d = bht_q;
83         1/1                saturation_counter = bht_q[update_pc][update_row_index].saturation_counter;
84                      
85         1/1                if ((bht_update_i.valid && CVA6Cfg.DebugEn && !debug_mode_i) || (bht_update_i.valid && !CVA6Cfg.DebugEn)) begin
86         1/1                  bht_d[update_pc][update_row_index].valid = 1'b1;
87                      
88         1/1                  if (saturation_counter == 2'b11) begin
89                                // we can safely decrease it
90         1/1                    if (!bht_update_i.taken)
91         1/1                      bht_d[update_pc][update_row_index].saturation_counter = saturation_counter - 1;
                        MISSING_ELSE
92                                // then check if it saturated in the negative regime e.g.: branch not taken
93         1/1                  end else if (saturation_counter == 2'b00) begin
94                                // we can safely increase it
95         1/1                    if (bht_update_i.taken)
96         1/1                      bht_d[update_pc][update_row_index].saturation_counter = saturation_counter + 1;
                        MISSING_ELSE
97                              end else begin  // otherwise we are not in any boundaries and can decrease or increase it
98         1/1                    if (bht_update_i.taken)
99         1/1                      bht_d[update_pc][update_row_index].saturation_counter = saturation_counter + 1;
100        1/1                    else bht_d[update_pc][update_row_index].saturation_counter = saturation_counter - 1;
101                             end
102                           end
                        MISSING_ELSE
103                         end
104                     
105                         always_ff @(posedge clk_i or negedge rst_ni) begin
106        1/1                if (!rst_ni) begin
107        1/1                  for (int unsigned i = 0; i < NR_ROWS; i++) begin
108        1/1                    for (int j = 0; j < CVA6Cfg.INSTR_PER_FETCH; j++) begin
109        1/1                      bht_q[i][j] <= '0;
110                               end
111                             end
112                           end else begin
113                             // evict all entries
114        1/1                  if (flush_bp_i) begin
115        unreachable            for (int i = 0; i < NR_ROWS; i++) begin
116        unreachable              for (int j = 0; j < CVA6Cfg.INSTR_PER_FETCH; j++) begin
117        unreachable                bht_q[i][j].valid <= 1'b0;
118        unreachable                bht_q[i][j].saturation_counter <= 2'b10;
119                                 end
120                               end
121                             end else begin
122        1/1                    bht_q <= bht_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : bht

               Total   Covered  Percent
Conditions         12       12   100.00
Logical            12       12   100.00
Non-Logical         0        0
Event               0        0

 LINE       85
 EXPRESSION ((((bht_update_i.valid && 1'b0) && (!debug_mode_i))) || (bht_update_i.valid && ((!1'b0))))
             -------------------------1-------------------------    ----------------2----------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Unreachable

 LINE       85
 SUB-EXPRESSION (bht_update_i.valid && ((!1'b0)))
                 ---------1--------    ----2----

-1- -2- Status
 0   -  Covered
 1   -  Covered

 LINE       88
 EXPRESSION (gen_asic_bht.saturation_counter == 2'b11)
            ---------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       93
 EXPRESSION (gen_asic_bht.saturation_counter == 2'b0)
            --------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       78
 EXPRESSION (bht_q[index][0].saturation_counter[1] == 1'b1)
            -----------------------1-----------------------

-1- Status
 0  Covered
 1  Covered

 LINE       78
 EXPRESSION (bht_q[index][1].saturation_counter[1] == 1'b1)
            -----------------------1-----------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.bht_gen.i_bht
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME 
100.00 100.00 100.00 --     bht  


Parent : 

SCORE  LINE   COND   ASSERT NAME       
 99.24 100.00  98.47 --     i_frontend 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : cvxif_issue_register_commit_if_driver
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/cvxif_issue_register_commit_if_driver.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                                                        
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.i_cvxif_issue_register_commit_if_driver 



-------------------------------------------------------------------------------
Line Coverage for Module : cvxif_issue_register_commit_if_driver

             Line No.   Total   Covered  Percent
TOTAL                        6        6   100.00
ALWAYS             48        6        6   100.00

47                        always_comb begin
48         1/1              issue_valid_o       = valid_i && ~flush_i;
49         1/1              issue_req_o.instr   = x_off_instr_i;
50         1/1              issue_req_o.hartid  = hart_id_i;
51         1/1              issue_req_o.id      = x_trans_id_i;
52         1/1              register_o.rs       = register_i;
53         1/1              register_o.rs_valid = rs_valid_i;

-------------------------------------------------------------------------------
Cond Coverage for Module : cvxif_issue_register_commit_if_driver

               Total   Covered  Percent
Conditions          6        6   100.00
Logical             6        6   100.00
Non-Logical         0        0
Event               0        0

 LINE       48
 EXPRESSION (valid_i && ((~flush_i)))
             ---1---    ------2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       59
 EXPRESSION (issue_valid_o && issue_ready_i)
             ------1------    ------2------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i.i_issue_read_operands.i_cvxif_issue_register_commit_if_driver
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME                                  
100.00 100.00 100.00 --     cvxif_issue_register_commit_if_driver 


Parent : 

SCORE  LINE   COND   ASSERT NAME                  
100.00 100.00 100.00 --     i_issue_read_operands 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : uvmt_cv32a60x_interrupt_assert
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 --     --     100.00 

Source File(s) : 

cva6/verif/tb/uvmt/uvmt_cv32a60x_interrupt_assert.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                        
100.00 --     --     100.00 uvmt_cva6_tb.cva6_dut_wrap.interrupt_assert 



-------------------------------------------------------------------------------
Assert Coverage for Module : uvmt_cv32a60x_interrupt_assert
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       0     0                 0                         
Cover properties 3     3         100.00  3                 100.00  
Cover sequences  0     0                 0                         
Total            3     3         100.00  3                 100.00  



-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                Attempts Matches Incomplete 
c_irq_m_ext_taken   51202068 129782  0          
c_irq_m_timer_taken 51202068 73800   0          
c_irq_priority      51202068 85719   0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.interrupt_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 --     --     100.00 


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 --     --     100.00 


Module : 

SCORE  LINE   COND   ASSERT NAME                           
100.00 --     --     100.00 uvmt_cv32a60x_interrupt_assert 


Parent : 

SCORE  LINE   COND   ASSERT NAME          
--     --     --     --     cva6_dut_wrap 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : cva6_fifo_v3
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/cva6_fifo_v3.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                                         
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue.gen_instr_fifo[0].i_fifo_instr_data 



-------------------------------------------------------------------------------
Line Coverage for Module : cva6_fifo_v3

             Line No.   Total   Covered  Percent
TOTAL                       48       48   100.00
ALWAYS             79       27       27   100.00
ALWAYS            157       17       17   100.00
ALWAYS            210        4        4   100.00
INITIAL           220        0        0

78                          // default assignment
79         1/1              read_pointer_n  = read_pointer_q;
80         1/1              write_pointer_n = write_pointer_q;
81         1/1              status_cnt_n    = status_cnt_q;
82         1/1(1 unreachable)      if (FPGA_EN && FPGA_ALTERA) data_ft_n = data_ft_q;
                        MISSING_ELSE
83         1/1(1 unreachable)      if (FPGA_EN && FPGA_ALTERA) first_word_n = first_word_q;
                        MISSING_ELSE
84         1/1              if (FPGA_EN) begin
85         unreachable        fifo_ram_we            = '0;
86         unreachable        fifo_ram_write_address = '0;
87         unreachable        fifo_ram_wdata         = '0;
88         unreachable        if (DEPTH == 0) begin
89         unreachable          data_o = data_i;
90                            end else begin
91         unreachable          if (FPGA_ALTERA) data_o = first_word_q ? data_ft_q : fifo_ram_rdata;
92         unreachable          else data_o = fifo_ram_rdata;
93                            end
94                          end else begin
95         1/1                data_o     = (DEPTH == 0) ? data_i : mem_q[read_pointer_q];
96         1/1                mem_n      = mem_q;
97         1/1                gate_clock = 1'b1;
98                          end
99                      
100                         // push a new element to the queue
101        1/1              if (push_i && ~full_o) begin
102        1/1                if (FPGA_EN) begin
103        unreachable          fifo_ram_we = 1'b1;
104        unreachable          fifo_ram_write_address = write_pointer_q;
105        unreachable          fifo_ram_wdata = data_i;
106        unreachable          if (FPGA_ALTERA) first_word_n = first_word_q && pop_i;
                   ==>  MISSING_ELSE
107                           end else begin
108                             // push the data onto the queue
109        1/1                  mem_n[write_pointer_q] = data_i;
110                             // un-gate the clock, we want to write something
111        1/1                  gate_clock = 1'b0;
112                           end
113                     
114                           // increment the write counter
115        1/1(1 unreachable)        if (write_pointer_q == FifoDepth[ADDR_DEPTH-1:0] - 1) write_pointer_n = '0;
116        1/1                else write_pointer_n = write_pointer_q + 1;
117                           // increment the overall counter
118        1/1                status_cnt_n = status_cnt_q + 1;
119                         end
                        MISSING_ELSE
120                     
121        1/1              if (pop_i && ~empty_o) begin
122        1/1                data_ft_n = data_i;
123        1/1(1 unreachable)        if (FPGA_EN && FPGA_ALTERA) first_word_n = first_word_q && push_i;
                        MISSING_ELSE
124                           // read from the queue is a default assignment
125                           // but increment the read pointer...
126        1/1(1 unreachable)        if (read_pointer_n == FifoDepth[ADDR_DEPTH-1:0] - 1) read_pointer_n = '0;
127        1/1                else read_pointer_n = read_pointer_q + 1;
128                           // ... and decrement the overall count
129        1/1                status_cnt_n = status_cnt_q - 1;
130                         end
                        MISSING_ELSE
131                     
132                         // keep the count pointer stable if we push and pop at the same time
133        2/2              if (push_i && pop_i && ~full_o && ~empty_o) status_cnt_n = status_cnt_q;
                        MISSING_ELSE
134                     
135                         // FIFO is in pass through mode -> do not change the pointers
136        1/1              if ((FALL_THROUGH || (FPGA_EN && FPGA_ALTERA)) && (status_cnt_q == 0) && push_i) begin
137        unreachable        if (FALL_THROUGH) data_o = data_i;
                   ==>  MISSING_ELSE
138        unreachable        if (FPGA_EN && FPGA_ALTERA) begin
139        unreachable          data_ft_n = data_i;
140        unreachable          first_word_n = '1;
141                           end
                   ==>  MISSING_ELSE
142        unreachable        if (pop_i) begin
143        unreachable          first_word_n = '0;
144        unreachable          status_cnt_n = status_cnt_q;
145        unreachable          read_pointer_n = read_pointer_q;
146        unreachable          write_pointer_n = write_pointer_q;
147                           end
                   ==>  MISSING_ELSE
148                         end
                        MISSING_ELSE
149                     
150        1/1(1 unreachable)      if (FPGA_EN) fifo_ram_read_address = (FPGA_ALTERA == 1) ? read_pointer_n : read_pointer_q;
151        1/1              else fifo_ram_read_address = '0;
152                     
153                       end
154                     
155                       // sequential process
156                       always_ff @(posedge clk_i or negedge rst_ni) begin
157        1/1              if (~rst_ni) begin
158        1/1                read_pointer_q  <= '0;
159        1/1                write_pointer_q <= '0;
160        1/1                status_cnt_q    <= '0;
161        1/1(1 unreachable)        if (FPGA_ALTERA) first_word_q <= '0;
                        MISSING_ELSE
162        1/1(1 unreachable)        if (FPGA_ALTERA) data_ft_q <= '0;
                        MISSING_ELSE
163                         end else begin
164        1/1                if (flush_i) begin
165        1/1                  read_pointer_q  <= '0;
166        1/1                  write_pointer_q <= '0;
167        1/1                  status_cnt_q    <= '0;
168        1/1(1 unreachable)          if (FPGA_ALTERA) first_word_q <= '0;
                        MISSING_ELSE
169        1/1(1 unreachable)          if (FPGA_ALTERA) data_ft_q <= '0;
                        MISSING_ELSE
170                           end else begin
171        1/1                  read_pointer_q  <= read_pointer_n;
172        1/1                  write_pointer_q <= write_pointer_n;
173        1/1                  status_cnt_q    <= status_cnt_n;
174        1/1(1 unreachable)          if (FPGA_ALTERA) data_ft_q <= data_ft_n;
                        MISSING_ELSE
175        1/1(1 unreachable)          if (FPGA_ALTERA) first_word_q <= first_word_n;
                        MISSING_ELSE
176                           end
177                         end
178                       end
179                     
180                       if (FPGA_EN) begin : gen_fpga_queue
181                         if (FPGA_ALTERA) begin
182                           SyncDpRam_ind_r_w #(
183                               .ADDR_WIDTH(ADDR_DEPTH),
184                               .DATA_DEPTH(DEPTH),
185                               .DATA_WIDTH($bits(dtype))
186                           ) fifo_ram (
187                               .Clk_CI   (clk_i),
188                               .WrEn_SI  (fifo_ram_we),
189                               .RdAddr_DI(fifo_ram_read_address),
190                               .WrAddr_DI(fifo_ram_write_address),
191                               .WrData_DI(fifo_ram_wdata),
192                               .RdData_DO(fifo_ram_rdata)
193                           );
194                         end else begin
195                           AsyncDpRam #(
196                               .ADDR_WIDTH(ADDR_DEPTH),
197                               .DATA_DEPTH(DEPTH),
198                               .DATA_WIDTH($bits(dtype))
199                           ) fifo_ram (
200                               .Clk_CI   (clk_i),
201                               .WrEn_SI  (fifo_ram_we),
202                               .RdAddr_DI(fifo_ram_read_address),
203                               .WrAddr_DI(fifo_ram_write_address),
204                               .WrData_DI(fifo_ram_wdata),
205                               .RdData_DO(fifo_ram_rdata)
206                           );
207                         end
208                       end else begin : gen_asic_queue
209                         always_ff @(posedge clk_i or negedge rst_ni) begin
210        1/1                if (~rst_ni) begin
211        1/1                  mem_q <= '0;
212        1/1                end else if (!gate_clock) begin
213        1/1                  mem_q <= mem_n;
214                           end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : cva6_fifo_v3

               Total   Covered  Percent
Conditions         19       19   100.00
Logical            19       19   100.00
Non-Logical         0        0
Event               0        0

 LINE       91
 EXPRESSION (first_word_q ? data_ft_q : fifo_ram_rdata)
             ------1-----

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       101
 EXPRESSION (push_i && ((~full_o)))
             ---1--    -----2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       106
 EXPRESSION (first_word_q && pop_i)
             ------1-----    --2--

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       115
 EXPRESSION (write_pointer_q == (FifoDepth[(ADDR_DEPTH - 1):0] - 1))
            ----------------------------1---------------------------

-1- Status
 0  Covered
 1  Unreachable

 LINE       121
 EXPRESSION (pop_i && ((~empty_o)))
             --1--    ------2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       123
 EXPRESSION (first_word_q && push_i)
             ------1-----    ---2--

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       126
 EXPRESSION (read_pointer_n == (FifoDepth[(ADDR_DEPTH - 1):0] - 1))
            ---------------------------1---------------------------

-1- Status
 0  Covered
 1  Unreachable

 LINE       133
 EXPRESSION (push_i && pop_i && ((~full_o)) && ((~empty_o)))
             ---1--    --2--    -----3-----    ------4-----

-1- -2- -3- -4- Status
 0   1   1   1  Covered
 1   0   1   1  Covered
 1   1   0   1  Covered
 1   1   1   0  Covered
 1   1   1   1  Covered

 LINE       71
 EXPRESSION (status_cnt_q == FifoDepth[ADDR_DEPTH:0])
            --------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       72
 EXPRESSION ((status_cnt_q == 3'b0) & ((~(FALL_THROUGH & push_i))))
             -----------1----------   --------------2-------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       72
 SUB-EXPRESSION (status_cnt_q == 3'b0)
                -----------1----------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue.gen_instr_fifo[0].i_fifo_instr_data
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME         
100.00 100.00 100.00 --     cva6_fifo_v3 


Parent : 

SCORE  LINE   COND   ASSERT NAME          
100.00 100.00 100.00 --     i_instr_queue 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue.gen_instr_fifo[0].i_fifo_instr_data

             Line No.   Total   Covered  Percent
TOTAL                       48       48   100.00
ALWAYS             79       27       27   100.00
ALWAYS            157       17       17   100.00
ALWAYS            210        4        4   100.00
INITIAL           220        0        0

78                          // default assignment
79         1/1              read_pointer_n  = read_pointer_q;
80         1/1              write_pointer_n = write_pointer_q;
81         1/1              status_cnt_n    = status_cnt_q;
82         1/1(1 unreachable)      if (FPGA_EN && FPGA_ALTERA) data_ft_n = data_ft_q;
                        MISSING_ELSE
83         1/1(1 unreachable)      if (FPGA_EN && FPGA_ALTERA) first_word_n = first_word_q;
                        MISSING_ELSE
84         1/1              if (FPGA_EN) begin
85         unreachable        fifo_ram_we            = '0;
86         unreachable        fifo_ram_write_address = '0;
87         unreachable        fifo_ram_wdata         = '0;
88         unreachable        if (DEPTH == 0) begin
89         unreachable          data_o = data_i;
90                            end else begin
91         unreachable          if (FPGA_ALTERA) data_o = first_word_q ? data_ft_q : fifo_ram_rdata;
92         unreachable          else data_o = fifo_ram_rdata;
93                            end
94                          end else begin
95         1/1                data_o     = (DEPTH == 0) ? data_i : mem_q[read_pointer_q];
96         1/1                mem_n      = mem_q;
97         1/1                gate_clock = 1'b1;
98                          end
99                      
100                         // push a new element to the queue
101        1/1              if (push_i && ~full_o) begin
102        1/1                if (FPGA_EN) begin
103        unreachable          fifo_ram_we = 1'b1;
104        unreachable          fifo_ram_write_address = write_pointer_q;
105        unreachable          fifo_ram_wdata = data_i;
106        unreachable          if (FPGA_ALTERA) first_word_n = first_word_q && pop_i;
                   ==>  MISSING_ELSE
107                           end else begin
108                             // push the data onto the queue
109        1/1                  mem_n[write_pointer_q] = data_i;
110                             // un-gate the clock, we want to write something
111        1/1                  gate_clock = 1'b0;
112                           end
113                     
114                           // increment the write counter
115        1/1(1 unreachable)        if (write_pointer_q == FifoDepth[ADDR_DEPTH-1:0] - 1) write_pointer_n = '0;
116        1/1                else write_pointer_n = write_pointer_q + 1;
117                           // increment the overall counter
118        1/1                status_cnt_n = status_cnt_q + 1;
119                         end
                        MISSING_ELSE
120                     
121        1/1              if (pop_i && ~empty_o) begin
122        1/1                data_ft_n = data_i;
123        1/1(1 unreachable)        if (FPGA_EN && FPGA_ALTERA) first_word_n = first_word_q && push_i;
                        MISSING_ELSE
124                           // read from the queue is a default assignment
125                           // but increment the read pointer...
126        1/1(1 unreachable)        if (read_pointer_n == FifoDepth[ADDR_DEPTH-1:0] - 1) read_pointer_n = '0;
127        1/1                else read_pointer_n = read_pointer_q + 1;
128                           // ... and decrement the overall count
129        1/1                status_cnt_n = status_cnt_q - 1;
130                         end
                        MISSING_ELSE
131                     
132                         // keep the count pointer stable if we push and pop at the same time
133        2/2              if (push_i && pop_i && ~full_o && ~empty_o) status_cnt_n = status_cnt_q;
                        MISSING_ELSE
134                     
135                         // FIFO is in pass through mode -> do not change the pointers
136        1/1              if ((FALL_THROUGH || (FPGA_EN && FPGA_ALTERA)) && (status_cnt_q == 0) && push_i) begin
137        unreachable        if (FALL_THROUGH) data_o = data_i;
                   ==>  MISSING_ELSE
138        unreachable        if (FPGA_EN && FPGA_ALTERA) begin
139        unreachable          data_ft_n = data_i;
140        unreachable          first_word_n = '1;
141                           end
                   ==>  MISSING_ELSE
142        unreachable        if (pop_i) begin
143        unreachable          first_word_n = '0;
144        unreachable          status_cnt_n = status_cnt_q;
145        unreachable          read_pointer_n = read_pointer_q;
146        unreachable          write_pointer_n = write_pointer_q;
147                           end
                   ==>  MISSING_ELSE
148                         end
                        MISSING_ELSE
149                     
150        1/1(1 unreachable)      if (FPGA_EN) fifo_ram_read_address = (FPGA_ALTERA == 1) ? read_pointer_n : read_pointer_q;
151        1/1              else fifo_ram_read_address = '0;
152                     
153                       end
154                     
155                       // sequential process
156                       always_ff @(posedge clk_i or negedge rst_ni) begin
157        1/1              if (~rst_ni) begin
158        1/1                read_pointer_q  <= '0;
159        1/1                write_pointer_q <= '0;
160        1/1                status_cnt_q    <= '0;
161        1/1(1 unreachable)        if (FPGA_ALTERA) first_word_q <= '0;
                        MISSING_ELSE
162        1/1(1 unreachable)        if (FPGA_ALTERA) data_ft_q <= '0;
                        MISSING_ELSE
163                         end else begin
164        1/1                if (flush_i) begin
165        1/1                  read_pointer_q  <= '0;
166        1/1                  write_pointer_q <= '0;
167        1/1                  status_cnt_q    <= '0;
168        1/1(1 unreachable)          if (FPGA_ALTERA) first_word_q <= '0;
                        MISSING_ELSE
169        1/1(1 unreachable)          if (FPGA_ALTERA) data_ft_q <= '0;
                        MISSING_ELSE
170                           end else begin
171        1/1                  read_pointer_q  <= read_pointer_n;
172        1/1                  write_pointer_q <= write_pointer_n;
173        1/1                  status_cnt_q    <= status_cnt_n;
174        1/1(1 unreachable)          if (FPGA_ALTERA) data_ft_q <= data_ft_n;
                        MISSING_ELSE
175        1/1(1 unreachable)          if (FPGA_ALTERA) first_word_q <= first_word_n;
                        MISSING_ELSE
176                           end
177                         end
178                       end
179                     
180                       if (FPGA_EN) begin : gen_fpga_queue
181                         if (FPGA_ALTERA) begin
182                           SyncDpRam_ind_r_w #(
183                               .ADDR_WIDTH(ADDR_DEPTH),
184                               .DATA_DEPTH(DEPTH),
185                               .DATA_WIDTH($bits(dtype))
186                           ) fifo_ram (
187                               .Clk_CI   (clk_i),
188                               .WrEn_SI  (fifo_ram_we),
189                               .RdAddr_DI(fifo_ram_read_address),
190                               .WrAddr_DI(fifo_ram_write_address),
191                               .WrData_DI(fifo_ram_wdata),
192                               .RdData_DO(fifo_ram_rdata)
193                           );
194                         end else begin
195                           AsyncDpRam #(
196                               .ADDR_WIDTH(ADDR_DEPTH),
197                               .DATA_DEPTH(DEPTH),
198                               .DATA_WIDTH($bits(dtype))
199                           ) fifo_ram (
200                               .Clk_CI   (clk_i),
201                               .WrEn_SI  (fifo_ram_we),
202                               .RdAddr_DI(fifo_ram_read_address),
203                               .WrAddr_DI(fifo_ram_write_address),
204                               .WrData_DI(fifo_ram_wdata),
205                               .RdData_DO(fifo_ram_rdata)
206                           );
207                         end
208                       end else begin : gen_asic_queue
209                         always_ff @(posedge clk_i or negedge rst_ni) begin
210        1/1                if (~rst_ni) begin
211        1/1                  mem_q <= '0;
212        1/1                end else if (!gate_clock) begin
213        1/1                  mem_q <= mem_n;
214                           end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_queue.gen_instr_fifo[0].i_fifo_instr_data

               Total   Covered  Percent
Conditions         19       19   100.00
Logical            19       19   100.00
Non-Logical         0        0
Event               0        0

 LINE       91
 EXPRESSION (first_word_q ? data_ft_q : fifo_ram_rdata)
             ------1-----

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       101
 EXPRESSION (push_i && ((~full_o)))
             ---1--    -----2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       106
 EXPRESSION (first_word_q && pop_i)
             ------1-----    --2--

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       115
 EXPRESSION (write_pointer_q == (FifoDepth[(ADDR_DEPTH - 1):0] - 1))
            ----------------------------1---------------------------

-1- Status
 0  Covered
 1  Unreachable

 LINE       121
 EXPRESSION (pop_i && ((~empty_o)))
             --1--    ------2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       123
 EXPRESSION (first_word_q && push_i)
             ------1-----    ---2--

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       126
 EXPRESSION (read_pointer_n == (FifoDepth[(ADDR_DEPTH - 1):0] - 1))
            ---------------------------1---------------------------

-1- Status
 0  Covered
 1  Unreachable

 LINE       133
 EXPRESSION (push_i && pop_i && ((~full_o)) && ((~empty_o)))
             ---1--    --2--    -----3-----    ------4-----

-1- -2- -3- -4- Status
 0   1   1   1  Covered
 1   0   1   1  Covered
 1   1   0   1  Covered
 1   1   1   0  Covered
 1   1   1   1  Covered

 LINE       71
 EXPRESSION (status_cnt_q == FifoDepth[ADDR_DEPTH:0])
            --------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       72
 EXPRESSION ((status_cnt_q == 3'b0) & ((~(FALL_THROUGH & push_i))))
             -----------1----------   --------------2-------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       72
 SUB-EXPRESSION (status_cnt_q == 3'b0)
                -----------1----------

-1- Status
 0  Covered
 1  Covered

===============================================================================
Module : mult
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/mult.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                              
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult 



-------------------------------------------------------------------------------
Line Coverage for Module : mult

             Line No.   Total   Covered  Percent
TOTAL                       11       11   100.00
ALWAYS             93        8        8   100.00
ALWAYS            152        3        3   100.00

92                          // silence the inputs
93         1/1              operand_a = '0;
94         1/1              operand_b = '0;
95                          // control signals
96         1/1              word_op_d = word_op_q;
97                      
98                          // we've go a new division operation
99         1/1              if (mult_valid_i && fu_data_i.operation inside {DIV, DIVU, DIVW, DIVUW, REM, REMU, REMW, REMUW}) begin
100                           // is this a word operation?
101        1/1                if (CVA6Cfg.IS_XLEN64 && (fu_data_i.operation == DIVW || fu_data_i.operation == DIVUW || fu_data_i.operation == REMW || fu_data_i.operation == REMUW)) begin
102                             // yes so check if we should sign extend this is only done for a signed operation
103        unreachable          if (div_signed) begin
104        unreachable            operand_a = sext32to64(fu_data_i.operand_a[31:0]);
105        unreachable            operand_b = sext32to64(fu_data_i.operand_b[31:0]);
106                             end else begin
107        unreachable            operand_a = fu_data_i.operand_a[31:0];
108        unreachable            operand_b = fu_data_i.operand_b[31:0];
109                             end
110                     
111                             // save whether we want sign extend the result or not, this is done for all word operations
112        unreachable          word_op_d = 1'b1;
113                           end else begin
114                             // regular op
115        1/1                  operand_a = fu_data_i.operand_a;
116        1/1                  operand_b = fu_data_i.operand_b;
117        1/1                  word_op_d = 1'b0;
118                           end
119                         end
                        MISSING_ELSE
120                       end
121                     
122                       // ---------------------
123                       // Serial Divider
124                       // ---------------------
125                       serdiv #(
126                           .CVA6Cfg(CVA6Cfg),
127                           .WIDTH  (CVA6Cfg.XLEN)
128                       ) i_div (
129                           .clk_i    (clk_i),
130                           .rst_ni   (rst_ni),
131                           .id_i     (fu_data_i.trans_id),
132                           .op_a_i   (operand_a),
133                           .op_b_i   (operand_b),
134                           .opcode_i ({rem, div_signed}),   // 00: udiv, 10: urem, 01: div, 11: rem
135                           .in_vld_i (div_valid_op),
136                           .in_rdy_o (mult_ready_o),
137                           .flush_i  (flush_i),
138                           .out_vld_o(div_valid),
139                           .out_rdy_i(div_ready_i),
140                           .id_o     (div_trans_id),
141                           .res_o    (result)
142                       );
143                     
144                       // Result multiplexer
145                       // if it was a signed word operation the bit will be set and the result will be sign extended accordingly
146                       assign div_result = (CVA6Cfg.IS_XLEN64 && word_op_q) ? sext32to64(result) : result;
147                     
148                       // ---------------------
149                       // Registers
150                       // ---------------------
151                       always_ff @(posedge clk_i or negedge rst_ni) begin
152        1/1              if (~rst_ni) begin
153        1/1                word_op_q <= '0;
154                         end else begin
155        1/1                word_op_q <= word_op_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : mult

               Total   Covered  Percent
Conditions         20       20   100.00
Logical            20       20   100.00
Non-Logical         0        0
Event               0        0

 LINE       99
 EXPRESSION (mult_valid_i && (fu_data_i.operation inside {DIV, DIVU, DIVW, DIVUW, REM, REMU, REMW, REMUW}))
             ------1-----    --------------------------------------2--------------------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       40
 EXPRESSION (((~flush_i)) && mult_valid_i && (fu_data_i.operation inside {MUL, MULH, MULHU, MULHSU, MULW, CLMUL, CLMULH, CLMULR}))
             ------1-----    ------2-----    ------------------------------------------3-----------------------------------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       42
 EXPRESSION (((~flush_i)) && mult_valid_i && (fu_data_i.operation inside {DIV, DIVU, DIVW, DIVUW, REM, REMU, REMW, REMUW}))
             ------1-----    ------2-----    --------------------------------------3--------------------------------------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       49
 EXPRESSION (mul_valid ? 1'b0 : 1'b1)
             ----1----

-1- Status
 0  Covered
 1  Covered

 LINE       50
 EXPRESSION (mul_valid ? mul_trans_id : div_trans_id)
             ----1----

-1- Status
 0  Covered
 1  Covered

 LINE       51
 EXPRESSION (mul_valid ? mul_result : div_result)
             ----1----

-1- Status
 0  Covered
 1  Covered

 LINE       52
 EXPRESSION (div_valid | mul_valid)
             ----1----   ----2----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.83 100.00  99.66 --     


Module : 

SCORE  LINE   COND   ASSERT NAME 
100.00 100.00 100.00 --     mult 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     ex_stage_i 


Subtrees :

SCORE  LINE   COND   ASSERT NAME         
 99.82 100.00  99.64 --     i_div        
100.00 100.00 100.00 --     i_multiplier 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : load_unit
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/load_unit.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                         
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i.i_load_unit 



-------------------------------------------------------------------------------
Line Coverage for Module : load_unit

             Line No.   Total   Covered  Percent
TOTAL                       82       82   100.00
ALWAYS            158       10       10   100.00
ALWAYS            182       12       12   100.00
ALWAYS            274       27       27   100.00
ALWAYS            345       11       11   100.00
ALWAYS            374       16       16   100.00
ALWAYS            453        6        6   100.00

157                       always_comb begin : ldbuf_comb
158        1/1              ldbuf_flushed_d = ldbuf_flushed_q;
159        1/1              ldbuf_valid_d   = ldbuf_valid_q;
160                     
161                         //  In case of flush, raise the flushed flag in all slots.
162        1/1              if (flush_i) begin
163        1/1                ldbuf_flushed_d = '1;
164                         end
                        MISSING_ELSE
165                         //  Free read entry (in the case of fall-through mode, free the entry
166                         //  only if there is no pending load)
167        1/1              if (ldbuf_r && (!LDBUF_FALLTHROUGH || !ldbuf_w)) begin
168        1/1                ldbuf_valid_d[ldbuf_rindex] = 1'b0;
169                         end
                        MISSING_ELSE
170                         // Free on exception
171        1/1              if (CVA6Cfg.MmuPresent && (ldbuf_w_q && ex_i.valid)) begin
172        unreachable        ldbuf_valid_d[ldbuf_windex_q] = 1'b0;
173                         end
                        MISSING_ELSE
174                         //  Track a new outstanding operation in the load buffer
175        1/1              if (ldbuf_w) begin
176        1/1                ldbuf_flushed_d[ldbuf_windex] = 1'b0;
177        1/1                ldbuf_valid_d[ldbuf_windex]   = 1'b1;
178                         end
                        MISSING_ELSE
179                       end
180                     
181                       always_ff @(posedge clk_i or negedge rst_ni) begin : ldbuf_ff
182        1/1              if (!rst_ni) begin
183        1/1                ldbuf_flushed_q <= '0;
184        1/1                ldbuf_valid_q   <= '0;
185        1/1                ldbuf_last_id_q <= '0;
186        1/1                ldbuf_q         <= '0;
187                         end else begin
188        1/1                ldbuf_flushed_q <= ldbuf_flushed_d;
189        1/1                ldbuf_valid_q   <= ldbuf_valid_d;
190        1/1                if (ldbuf_w) begin
191        1/1                  ldbuf_last_id_q                      <= ldbuf_windex;
192        1/1                  ldbuf_q[ldbuf_windex].trans_id       <= lsu_ctrl_i.trans_id;
193        1/1                  ldbuf_q[ldbuf_windex].address_offset <= lsu_ctrl_i.vaddr[CVA6Cfg.XLEN_ALIGN_BYTES-1:0];
194        1/1                  ldbuf_q[ldbuf_windex].operation      <= lsu_ctrl_i.operation;
195                           end
                        MISSING_ELSE
196                         end
197                       end
198                     
199                       // page offset is defined as the lower 12 bits, feed through for address checker
200                       assign page_offset_o = lsu_ctrl_i.vaddr[11:0];
201                       // feed-through the virtual address for VA translation
202                       assign vaddr_o = lsu_ctrl_i.vaddr;
203                       assign hs_ld_st_inst_o = CVA6Cfg.RVH ? lsu_ctrl_i.hs_ld_st_inst : 1'b0;
204                       assign hlvx_inst_o = CVA6Cfg.RVH ? lsu_ctrl_i.hlvx_inst : 1'b0;
205                       // feed-through the transformed instruction for mmu
206                       assign tinst_o = CVA6Cfg.RVH ? lsu_ctrl_i.tinst : '0;
207                     
208                       // output address
209                       // we can now output the lower 12 bit as the index to the cache
210                       assign load_req_o.address_index = lsu_ctrl_i.vaddr[CVA6Cfg.DCACHE_INDEX_WIDTH-1:0];
211                       assign load_req_o.be = lsu_ctrl_i.be;
212                     
213                       // request id = index of the load buffer's entry
214                       assign load_req_o.aid = ldbuf_windex;
215                       // directly forward exception fields (valid bit is set below)
216                       assign ex_o.cause = ex_i.cause;
217                       assign ex_o.tval = ex_i.tval;
218                       assign ex_o.tval2 = CVA6Cfg.RVH ? ex_i.tval2 : '0;
219                       assign ex_o.tinst = CVA6Cfg.RVH ? ex_i.tinst : '0;
220                       assign ex_o.gva = CVA6Cfg.RVH ? ex_i.gva : 1'b0;
221                     
222                       logic [CVA6Cfg.PLEN-1:0] paddr;
223                     
224                       assign paddr = CVA6Cfg.MmuPresent ? paddr_i : lsu_ctrl_i.vaddr; //paddr_i is delayed in s1, but no s1 in mode no MMU
225                     
226                       // CHECK PMA regions
227                     
228                       logic paddr_is_cacheable, paddr_is_cacheable_q;  // asserted if physical address is non-cacheable
229                       assign paddr_is_cacheable = config_pkg::is_inside_cacheable_regions(
230                           CVA6Cfg, {{52 - CVA6Cfg.PPNW{1'b0}}, dtlb_ppn_i, 12'd0}
231                       );
232                     
233                       logic paddr_nonidempotent;
234                       assign paddr_nonidempotent = config_pkg::is_inside_nonidempotent_regions(
235                           CVA6Cfg, {{52 - CVA6Cfg.PPNW{1'b0}}, dtlb_ppn_i, 12'd0}
236                       );
237                     
238                       // Check that NI operations follow the necessary conditions
239                       logic not_commit_time;
240                       logic inflight_stores;
241                       logic stall_ni;
242                       assign not_commit_time = commit_tran_id_i != lsu_ctrl_i.trans_id;
243                       assign inflight_stores = (!dcache_wbuffer_not_ni_i || !store_buffer_empty_i);
244                     
245                       typedef enum logic [1:0] {
246                         TRANSPARENT,
247                         REGISTRED
248                       } obi_a_state_e;
249                       obi_a_state_e obi_a_state_d, obi_a_state_q;
250                     
251                       // ---------------
252                       // Load Control
253                       // ---------------
254                       logic ex_s0, ex_s1, kill_s1;
255                     
256                       logic stall_obi, stall_translation;
257                       logic data_req, data_rvalid;
258                     
259                       assign load_req_o.kill_req = kill_req_q || kill_s1;
260                     
261                       assign stall_ni = (inflight_stores || not_commit_time) && (paddr_nonidempotent && CVA6Cfg.NonIdemPotenceEn);
262                       assign stall_obi = (obi_a_state_q == REGISTRED);  //&& !obi_load_rsp_i.gnt;
263                       assign stall_translation = CVA6Cfg.MmuPresent ? translation_req_o && !dtlb_hit_i : 1'b0;
264                     
265                       assign ex_s0 = CVA6Cfg.MmuPresent && stall_translation && ex_i.valid;
266                       assign ex_s1 = ((CVA6Cfg.MmuPresent ? ldbuf_w_q : valid_i) && ex_i.valid);
267                       assign kill_s1 = CVA6Cfg.MmuPresent ? ex_s1 : 1'b0;
268                     
269                       assign data_rvalid = obi_load_rsp_i.rvalid && !ldbuf_flushed_q[ldbuf_rindex];
270                       assign data_req = (CVA6Cfg.MmuPresent ? ldbuf_w_q && !ex_s1 : ldbuf_w);
271                     
272                       always_comb begin : p_fsm_common
273                         // default assignment
274        1/1              load_req_o.req = '0;
275        1/1              kill_req_d = 1'b0;
276        1/1              ldbuf_w = 1'b0;
277        1/1              translation_req_o = 1'b0;
278                         //response
279        1/1              trans_id_o = lsu_ctrl_i.trans_id;
280        1/1              valid_o    = 1'b0;
281        1/1              ex_o.valid = 1'b0;
282        1/1              pop_ld_o = 1'b0; // release lsu_bypass fifo
283                     
284                         // REQUEST
285        1/1              if (valid_i) begin
286        1/1                translation_req_o = 1'b1;
287        1/1                if (!page_offset_matches_i) begin
288        1/1                  load_req_o.req = 1'b1;
289        1/1                  if (!CVA6Cfg.MmuPresent || load_rsp_i.gnt) begin
290        1/1                    if (stall_translation || stall_ni || stall_obi || ldbuf_full || flush_i) begin
291        1/1                      kill_req_d = 1'b1;  // MmuPresent only: next cycle is s2 but we need to kill because not ready to send tag
292                               end else begin
293        1/1                      ldbuf_w  = CVA6Cfg.MmuPresent ? 1'b1 : !ex_s1;  // record request into outstanding load fifo and trigger OBI request
294        1/1                      pop_ld_o = !ex_s1;  // release lsu_bypass fifo
295                               end
296                             end
                   ==>  MISSING_ELSE
297                           end
                        MISSING_ELSE
298                         end
                        MISSING_ELSE
299                         // RETIRE LOAD
300                         // we got an rvalid and it's corresponding request was not flushed
301        1/1              if (data_rvalid) begin
302        1/1                trans_id_o = ldbuf_q[ldbuf_rindex].trans_id;
303        1/1                valid_o    = 1'b1;
304        1/1                ex_o.valid = 1'b0;
305                           // RETIRE EXCEPTION (low priority)
306        1/1              end else if (ex_s1) begin
307        1/1                trans_id_o = CVA6Cfg.MmuPresent ? ldbuf_q[ldbuf_windex_q].trans_id : lsu_ctrl_i.trans_id;
308        1/1                valid_o    = 1'b1;
309        1/1                ex_o.valid = 1'b1;
310        1/1                pop_ld_o = 1'b1; // release lsu_bypass fifo
311                           // RETIRE EXCEPTION (low priority)
312        1/1              end else if (CVA6Cfg.MmuPresent && ex_s0) begin
313        unreachable        trans_id_o = lsu_ctrl_i.trans_id;
314        unreachable        valid_o    = 1'b1;
315        unreachable        ex_o.valid = 1'b1;
316        unreachable        pop_ld_o = 1'b1; // release lsu_bypass fifo
317                         end
                        MISSING_ELSE
318                     
319                       end
320                     
321                     
322                       //default obi state registred
323                       assign obi_load_req_o.reqpar = !obi_load_req_o.req;
324                       assign obi_load_req_o.a.addr = obi_a_state_q == TRANSPARENT ? paddr : paddr_q;
325                       assign obi_load_req_o.a.we = '0;
326                       assign obi_load_req_o.a.be = (!CVA6Cfg.MmuPresent && (obi_a_state_q == TRANSPARENT)) ? lsu_ctrl_i.be : be_q;
327                       assign obi_load_req_o.a.wdata = '0;
328                       assign obi_load_req_o.a.aid = (!CVA6Cfg.MmuPresent && (obi_a_state_q == TRANSPARENT)) ? ldbuf_windex : ldbuf_windex_q;
329                       assign obi_load_req_o.a.a_optional.auser = '0;
330                       assign obi_load_req_o.a.a_optional.wuser = '0;
331                       assign obi_load_req_o.a.a_optional.atop = '0;
332                       assign obi_load_req_o.a.a_optional.memtype[0] = '0;
333                       assign obi_load_req_o.a.a_optional.memtype[1]= (!CVA6Cfg.MmuPresent && (obi_a_state_q == TRANSPARENT)) ? paddr_is_cacheable : paddr_is_cacheable_q;
334                       assign obi_load_req_o.a.a_optional.mid = '0;
335                       assign obi_load_req_o.a.a_optional.prot[2:1] = 2'b11;
336                       assign obi_load_req_o.a.a_optional.prot[0] = 1'b1;  //data
337                       assign obi_load_req_o.a.a_optional.dbg = '0;
338                       assign obi_load_req_o.a.a_optional.achk = '0;
339                     
340                       assign obi_load_req_o.rready = '1;  //always ready
341                       assign obi_load_req_o.rreadypar = '0;
342                     
343                       always_comb begin : p_fsm_obi_a
344                         // default assignment
345        1/1              obi_a_state_d = obi_a_state_q;
346        1/1              obi_load_req_o.req    = 1'b0;
347                     
348        1/1              unique case (obi_a_state_q)
349                           TRANSPARENT: begin
350        1/1                  if (data_req) begin
351        1/1                    obi_load_req_o.req = 1'b1;
352        1/1                    if (!obi_load_rsp_i.gnt) begin
353        1/1                      obi_a_state_d = REGISTRED;
354                               end
                        MISSING_ELSE
355                             end
                        MISSING_ELSE
356                           end
357                     
358                           REGISTRED: begin
359        1/1                  obi_load_req_o.req = 1'b1;
360        1/1                  if (obi_load_rsp_i.gnt) begin
361        1/1                    obi_a_state_d = TRANSPARENT;
362                             end
                        MISSING_ELSE
363                           end
364                     
365                           default: begin
366                             // we should never get here
367        1/1                  obi_a_state_d = TRANSPARENT;
368                           end
369                         endcase
370                       end
371                     
372                       // latch physical address for the tag cycle (one cycle after applying the index)
373                       always_ff @(posedge clk_i or negedge rst_ni) begin
374        1/1              if (~rst_ni) begin
375        1/1                obi_a_state_q <= TRANSPARENT;
376        1/1                paddr_q <= '0;
377        1/1                be_q <= '0;
378        1/1                paddr_is_cacheable_q <= '0;
379        1/1                kill_req_q <= '0;
380        1/1                ldbuf_windex_q <= '0;
381        1/1                ldbuf_w_q <= '0;
382                         end else begin
383        1/1                if (obi_a_state_q == TRANSPARENT) begin
384        1/1                  paddr_q <= paddr;
385        1/1                  be_q <= lsu_ctrl_i.be;
386        1/1                  paddr_is_cacheable_q <= paddr_is_cacheable;
387                           end
                        MISSING_ELSE
388        1/1                obi_a_state_q <= obi_a_state_d;
389        1/1                kill_req_q <= kill_req_d;
390                           //if (!ex_s1) begin
391        1/1                ldbuf_windex_q <= ldbuf_windex;
392        1/1                ldbuf_w_q <= ldbuf_w;
393                           //end
394                         end
395                       end
396                     
397                     
398                       // ---------------
399                       // Retire Load
400                       // ---------------
401                       assign ldbuf_rindex = (CVA6Cfg.NrLoadBufEntries > 1) ? ldbuf_id_t'(obi_load_rsp_i.r.rid) : 1'b0;
402                       assign ldbuf_rdata = ldbuf_q[ldbuf_rindex];
403                     
404                       //  read the pending load buffer
405                       assign ldbuf_r    = obi_load_rsp_i.rvalid;
406                     
407                       // ---------------
408                       // Sign Extend
409                       // ---------------
410                       logic [CVA6Cfg.XLEN-1:0] shifted_data;
411                     
412                       // realign as needed
413                       assign shifted_data = obi_load_rsp_i.r.rdata >> {ldbuf_rdata.address_offset, 3'b000};
414                     
415                       /*  // result mux (leaner code, but more logic stages.
416                         // can be used instead of the code below (in between //result mux fast) if timing is not so critical)
417                         always_comb begin
418                             unique case (ldbuf_rdata.operation)
419                                 LWU:        result_o = shifted_data[31:0];
420                                 LHU:        result_o = shifted_data[15:0];
421                                 LBU:        result_o = shifted_data[7:0];
422                                 LW:         result_o = 64'(signed'(shifted_data[31:0]));
423                                 LH:         result_o = 64'(signed'(shifted_data[15:0]));
424                                 LB:         result_o = 64'(signed'(shifted_data[ 7:0]));
425                                 default:    result_o = shifted_data;
426                             endcase
427                         end  */
428                     
429                       // result mux fast
430                       logic [        (CVA6Cfg.XLEN/8)-1:0] rdata_sign_bits;
431                       logic [CVA6Cfg.XLEN_ALIGN_BYTES-1:0] rdata_offset;
432                       logic rdata_sign_bit, rdata_is_signed, rdata_is_fp_signed;
433                     
434                     
435                       // prepare these signals for faster selection in the next cycle
436                       assign rdata_is_signed    =   ldbuf_rdata.operation inside {ariane_pkg::LW,  ariane_pkg::LH,  ariane_pkg::LB, ariane_pkg::HLV_W, ariane_pkg::HLV_H, ariane_pkg::HLV_B};
437                       assign rdata_is_fp_signed =   ldbuf_rdata.operation inside {ariane_pkg::FLW, ariane_pkg::FLH, ariane_pkg::FLB};
438                       assign rdata_offset       = ((ldbuf_rdata.operation inside {ariane_pkg::LW,  ariane_pkg::FLW, ariane_pkg::HLV_W}) & CVA6Cfg.IS_XLEN64) ? ldbuf_rdata.address_offset + 3 :
439                                                     ( ldbuf_rdata.operation inside {ariane_pkg::LH,  ariane_pkg::FLH, ariane_pkg::HLV_H})                     ? ldbuf_rdata.address_offset + 1 :
440                                                                                                                                              ldbuf_rdata.address_offset;
441                     
442                       for (genvar i = 0; i < (CVA6Cfg.XLEN / 8); i++) begin : gen_sign_bits
443                         assign rdata_sign_bits[i] = obi_load_rsp_i.r.rdata[(i+1)*8-1];
444                       end
445                     
446                     
447                       // select correct sign bit in parallel to result shifter above
448                       // pull to 0 if unsigned
449                       assign rdata_sign_bit = rdata_is_signed & rdata_sign_bits[rdata_offset] | (CVA6Cfg.FpPresent && rdata_is_fp_signed);
450                     
451                       // result mux
452                       always_comb begin
453        1/1              unique case (ldbuf_rdata.operation)
454                           ariane_pkg::LW, ariane_pkg::LWU, ariane_pkg::HLV_W, ariane_pkg::HLV_WU, ariane_pkg::HLVX_WU:
455        1/1                result_o = {{CVA6Cfg.XLEN - 32{rdata_sign_bit}}, shifted_data[31:0]};
456                           ariane_pkg::LH, ariane_pkg::LHU, ariane_pkg::HLV_H, ariane_pkg::HLV_HU, ariane_pkg::HLVX_HU:
457        1/1                result_o = {{CVA6Cfg.XLEN - 32 + 16{rdata_sign_bit}}, shifted_data[15:0]};
458                           ariane_pkg::LB, ariane_pkg::LBU, ariane_pkg::HLV_B, ariane_pkg::HLV_BU:
459        1/1                result_o = {{CVA6Cfg.XLEN - 32 + 24{rdata_sign_bit}}, shifted_data[7:0]};
460                           default: begin
461                             // FLW, FLH and FLB have been defined here in default case to improve Code Coverage
462        1/1                  if (CVA6Cfg.FpPresent) begin
463        unreachable            unique case (ldbuf_rdata.operation)
464                                 ariane_pkg::FLW: begin
465        unreachable                result_o = {{CVA6Cfg.XLEN - 32{rdata_sign_bit}}, shifted_data[31:0]};
466                                 end
467                                 ariane_pkg::FLH: begin
468        unreachable                result_o = {{CVA6Cfg.XLEN - 32 + 16{rdata_sign_bit}}, shifted_data[15:0]};
469                                 end
470                                 ariane_pkg::FLB: begin
471        unreachable                result_o = {{CVA6Cfg.XLEN - 32 + 24{rdata_sign_bit}}, shifted_data[7:0]};
472                                 end
473                                 default: begin
474        unreachable                result_o = shifted_data[CVA6Cfg.XLEN-1:0];
475                                 end
476                               endcase
477                             end else begin
478        1/1                    result_o = shifted_data[CVA6Cfg.XLEN-1:0];

-------------------------------------------------------------------------------
Cond Coverage for Module : load_unit

               Total   Covered  Percent
Conditions         65       65   100.00
Logical            65       65   100.00
Non-Logical         0        0
Event               0        0

 LINE       167
 EXPRESSION (ldbuf_r && (((!LDBUF_FALLTHROUGH)) || ((!ldbuf_w))))
             ---1---    --------------------2-------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       167
 SUB-EXPRESSION (((!LDBUF_FALLTHROUGH)) || ((!ldbuf_w)))
                 -----------1----------    ------2-----

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       290
 EXPRESSION (stall_translation || stall_ni || stall_obi || ldbuf_full || flush_i)
             --------1--------    ----2---    ----3----    -----4----    ---5---

-1- -2- -3- -4- -5- Status
 0   0   0   0   0  Covered
 0   0   0   0   1  Covered
 0   0   0   1   0  Covered
 0   0   1   0   0  Covered
 0   1   0   0   0  Unreachable
 1   0   0   0   0  Unreachable

 LINE       383
 EXPRESSION (obi_a_state_q == TRANSPARENT)
            ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       134
 EXPRESSION (((&ldbuf_valid_q)) && ( ! (LDBUF_FALLTHROUGH && ldbuf_r) ))
             ---------1--------    ------------------2-----------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       134
 SUB-EXPRESSION ( ! (LDBUF_FALLTHROUGH && ldbuf_r) )
                    ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       134
 SUB-EXPRESSION (LDBUF_FALLTHROUGH && ldbuf_r)
                 --------1--------    ---2---

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       155
 EXPRESSION ((LDBUF_FALLTHROUGH && ldbuf_r) ? ldbuf_rindex : ldbuf_free_index)
             ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       155
 SUB-EXPRESSION (LDBUF_FALLTHROUGH && ldbuf_r)
                 --------1--------    ---2---

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       242
 EXPRESSION (commit_tran_id_i != lsu_ctrl_i.trans_id)
            --------------------1--------------------

-1- Status
 0  Covered
 1  Covered

 LINE       243
 EXPRESSION (((!dcache_wbuffer_not_ni_i)) || ((!store_buffer_empty_i)))
             --------------1-------------    ------------2------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Unreachable

 LINE       259
 EXPRESSION (kill_req_q || kill_s1)
             -----1----    ---2---

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       262
 EXPRESSION (obi_a_state_q == REGISTRED)
            --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       266
 EXPRESSION (((1'b0 ? ldbuf_w_q : valid_i)) && ex_i.valid)
             ---------------1--------------    -----2----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       269
 EXPRESSION (obi_load_rsp_i.rvalid && ((!ldbuf_flushed_q[ldbuf_rindex])))
             ----------1----------    -----------------2----------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       324
 EXPRESSION ((obi_a_state_q == TRANSPARENT) ? paddr : paddr_q)
             ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       324
 SUB-EXPRESSION (obi_a_state_q == TRANSPARENT)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       326
 EXPRESSION ((((!1'b0)) && (obi_a_state_q == TRANSPARENT)) ? lsu_ctrl_i.be : be_q)
             ----------------------1----------------------

-1- Status
 0  Covered
 1  Covered

 LINE       326
 SUB-EXPRESSION (((!1'b0)) && (obi_a_state_q == TRANSPARENT))
                 ----1----    ---------------2--------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       326
 SUB-EXPRESSION (obi_a_state_q == TRANSPARENT)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       328
 EXPRESSION ((((!1'b0)) && (obi_a_state_q == TRANSPARENT)) ? ldbuf_windex : ldbuf_windex_q)
             ----------------------1----------------------

-1- Status
 0  Covered
 1  Covered

 LINE       328
 SUB-EXPRESSION (((!1'b0)) && (obi_a_state_q == TRANSPARENT))
                 ----1----    ---------------2--------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       328
 SUB-EXPRESSION (obi_a_state_q == TRANSPARENT)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       333
 EXPRESSION ((((!1'b0)) && (obi_a_state_q == TRANSPARENT)) ? paddr_is_cacheable : paddr_is_cacheable_q)
             ----------------------1----------------------

-1- Status
 0  Covered
 1  Covered

 LINE       333
 SUB-EXPRESSION (((!1'b0)) && (obi_a_state_q == TRANSPARENT))
                 ----1----    ---------------2--------------

-1- -2- Status
 -   0  Covered
 -   1  Covered

 LINE       333
 SUB-EXPRESSION (obi_a_state_q == TRANSPARENT)
                ---------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       438
 SUB-EXPRESSION ((ldbuf_rdata.operation inside {LH, FLH, HLV_H}) ? ((ldbuf_rdata.address_offset + 1)) : ldbuf_rdata.address_offset)
                 -----------------------1-----------------------

-1- Status
 0  Covered
 1  Covered

 LINE       449
 EXPRESSION ((rdata_is_signed & rdata_sign_bits[rdata_offset]) | ((1'b0 && rdata_is_fp_signed)))
             ------------------------1------------------------   ---------------2--------------

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       449
 SUB-EXPRESSION (rdata_is_signed & rdata_sign_bits[rdata_offset])
                 -------1-------   --------------2--------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i.i_load_unit
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME      
100.00 100.00 100.00 --     load_unit 


Parent : 

SCORE  LINE   COND   ASSERT NAME  
 98.75  97.50 100.00 --     lsu_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : commit_stage
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/commit_stage.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                           
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.commit_stage_i 



-------------------------------------------------------------------------------
Line Coverage for Module : commit_stage

             Line No.   Total   Covered  Percent
TOTAL                       70       70   100.00
ALWAYS            115        3        3   100.00
ALWAYS            140       52       52   100.00
ALWAYS            373       15       15   100.00

114                       always_comb begin : dirty_fp_state
115        1/1              dirty_fp_state_o = 1'b0;
116        1/1              for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin
117        1/1                dirty_fp_state_o |= commit_ack_o[i] & (commit_instr_i[i].fu inside {FPU, FPU_VEC} || (CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(
118                               commit_instr_i[i].op
119                               // Check if we issued a vector floating-point instruction to the accellerator
120                           ))) | commit_instr_i[i].fu == ACCEL && commit_instr_i[i].vfp;
121                         end
122                       end
123                     
124                       assign commit_tran_id_o = commit_instr_i[0].trans_id;
125                     
126                       logic instr_0_is_amo;
127                       logic [CVA6Cfg.NrCommitPorts-1:0] commit_macro_ack;
128                       assign instr_0_is_amo = is_amo(commit_instr_i[0].op);
129                     
130                       logic amo_resp_ack;
131                       assign amo_resp_ack = obi_amo_rsp_i.rvalid;  // && amo_obi_req_o.rready;
132                     
133                     
134                       // -------------------
135                       // Commit Instruction
136                       // -------------------
137                       // write register file or commit instruction in LSU or CSR Buffer
138                       always_comb begin : commit
139                         // default assignments
140        1/1              commit_ack_o[0] = 1'b0;
141        1/1              commit_macro_ack[0] = 1'b0;
142                     
143        1/1              amo_valid_commit_o = 1'b0;
144                     
145        1/1              we_gpr_o[0] = 1'b0;
146        1/1              we_fpr_o = '{default: 1'b0};
147        1/1              commit_lsu_o = 1'b0;
148        1/1              commit_csr_o = 1'b0;
149                         // amos will commit on port 0
150        1/1              wdata_o[0] = (CVA6Cfg.RVA && amo_resp_ack) ? obi_amo_rsp_i.r.rdata : commit_instr_i[0].result;
151        1/1              csr_op_o = ADD;  // this corresponds to a CSR NOP
152        1/1              csr_wdata_o = {CVA6Cfg.XLEN{1'b0}};
153        1/1              fence_i_o = 1'b0;
154        1/1              fence_o = 1'b0;
155        1/1              sfence_vma_o = 1'b0;
156        1/1              hfence_vvma_o = 1'b0;
157        1/1              hfence_gvma_o = 1'b0;
158        1/1              csr_write_fflags_o = 1'b0;
159        1/1              flush_commit_o = 1'b0;
160                     
161                         // we do not commit the instruction yet if we requested a halt
162        1/1              if (commit_instr_i[0].valid && !halt_i) begin
163                           // we will not commit the instruction if we took an exception
164        1/1                if (commit_instr_i[0].ex.valid) begin
165                             // However we can drop it (with its exception)
166        1/1                  if (CVA6Cfg.SpeculativeSb && commit_drop_i[0]) begin
167        unreachable            commit_ack_o[0] = 1'b1;
168                             end
                        MISSING_ELSE
169                           end else begin
170        1/1                  commit_ack_o[0] = 1'b1;
171                     
172        1/1                  if (CVA6Cfg.RVZCMP && commit_instr_i[0].is_macro_instr && commit_instr_i[0].is_last_macro_instr)
173        unreachable            commit_macro_ack[0] = 1'b1;
174        1/1                  else commit_macro_ack[0] = 1'b0;
175                     
176        1/1                  if (!commit_drop_i[0]) begin
177                               // we can definitely write the register file
178                               // if the instruction is not committing anything the destination
179        1/1                    if (CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(commit_instr_i[0].op)) begin
180        unreachable              we_fpr_o[0] = 1'b1;
181                               end else begin
182        1/1                      we_gpr_o[0] = 1'b1;
183                               end
184                             end
                   ==>  MISSING_ELSE
185                     
186                             // check whether the instruction we retire was a store
187        1/1                  if (commit_instr_i[0].fu == STORE && !(CVA6Cfg.RVA && instr_0_is_amo)) begin
188                               // check if the LSU is ready to accept another commit entry (e.g.: a non-speculative store)
189        1/1                    if (commit_lsu_ready_i) begin
190        1/1                      commit_lsu_o = 1'b1;
191                                 // stall in case the store buffer is not able to accept anymore instructions
192                               end else begin
193        1/1                      commit_ack_o[0] = 1'b0;
194                               end
195                             end
                        MISSING_ELSE
196                             // ---------
197                             // FPU Flags
198                             // ---------
199        1/1                  if (CVA6Cfg.FpPresent) begin
200        unreachable            if (commit_instr_i[0].fu inside {FPU, FPU_VEC}) begin
201        unreachable              if (!commit_drop_i[0]) begin
202                                   // write the CSR with potential exception flags from retiring floating point instruction
203        unreachable                csr_wdata_o = {{CVA6Cfg.XLEN - 5{1'b0}}, commit_instr_i[0].ex.cause[4:0]};
204        unreachable                csr_write_fflags_o = 1'b1;
205                                 end
                   ==>  MISSING_ELSE
206                               end
                   ==>  MISSING_ELSE
207                             end
                        MISSING_ELSE
208                             // ---------
209                             // CSR Logic
210                             // ---------
211                             // check whether the instruction we retire was a CSR instruction and it did not
212                             // throw an exception
213        1/1                  if (commit_instr_i[0].fu == CSR) begin
214                               // write the CSR file
215        1/1                    csr_op_o    = commit_instr_i[0].op;
216        1/1                    csr_wdata_o = commit_instr_i[0].result;
217        1/1                    if (!commit_drop_i[0]) begin
218        1/1                      if (!csr_exception_i.valid) begin
219        1/1                        commit_csr_o = 1'b1;
220        1/1                        wdata_o[0]   = csr_rdata_i;
221                                 end else begin
222        1/1                        commit_ack_o[0] = 1'b0;
223        1/1                        we_gpr_o[0] = 1'b0;
224                                 end
225                               end
                   ==>  MISSING_ELSE
226                             end
                        MISSING_ELSE
227                             // ------------------
228                             // SFENCE.VMA Logic
229                             // ------------------
230                             // sfence.vma is idempotent so we can safely re-execute it after returning
231                             // from interrupt service routine
232                             // check if this instruction was a SFENCE_VMA
233        1/1                  if (CVA6Cfg.RVS && commit_instr_i[0].op == SFENCE_VMA) begin
234        unreachable            if (!commit_drop_i[0]) begin
235                                 // no store pending so we can flush the TLBs and pipeline
236        unreachable              sfence_vma_o = no_st_pending_i;
237                                 // wait for the store buffer to drain until flushing the pipeline
238        unreachable              commit_ack_o[0] = no_st_pending_i;
239                               end
                   ==>  MISSING_ELSE
240                             end
                        MISSING_ELSE
241                             // ------------------
242                             // HFENCE.VVMA Logic
243                             // ------------------
244                             // hfence.vvma is idempotent so we can safely re-execute it after returning
245                             // from interrupt service routine
246                             // check if this instruction was a HFENCE_VVMA
247        1/1                  if (CVA6Cfg.RVH && commit_instr_i[0].op == HFENCE_VVMA) begin
248        unreachable            if (!commit_drop_i[0]) begin
249                                 // no store pending so we can flush the TLBs and pipeline
250        unreachable              hfence_vvma_o   = no_st_pending_i;
251                                 // wait for the store buffer to drain until flushing the pipeline
252        unreachable              commit_ack_o[0] = no_st_pending_i;
253                               end
                   ==>  MISSING_ELSE
254                             end
                        MISSING_ELSE
255                             // ------------------
256                             // HFENCE.GVMA Logic
257                             // ------------------
258                             // hfence.gvma is idempotent so we can safely re-execute it after returning
259                             // from interrupt service routine
260                             // check if this instruction was a HFENCE_GVMA
261        1/1                  if (CVA6Cfg.RVH && commit_instr_i[0].op == HFENCE_GVMA) begin
262        unreachable            if (!commit_drop_i[0]) begin
263                                 // no store pending so we can flush the TLBs and pipeline
264        unreachable              hfence_gvma_o   = no_st_pending_i;
265                                 // wait for the store buffer to drain until flushing the pipeline
266        unreachable              commit_ack_o[0] = no_st_pending_i;
267                               end
                   ==>  MISSING_ELSE
268                             end
                        MISSING_ELSE
269                             // ------------------
270                             // FENCE.I Logic
271                             // ------------------
272                             // fence.i is idempotent so we can safely re-execute it after returning
273                             // from interrupt service routine
274                             // Fence synchronizes data and instruction streams. That means that we need to flush the private icache
275                             // and the private dcache. This is the most expensive instruction.
276        1/1                  if ((commit_instr_i[0].op == FENCE_I && CVA6Cfg.RVZifencei) || (flush_dcache_i && CVA6Cfg.DCacheType == config_pkg::WB && commit_instr_i[0].fu != STORE)) begin /* FIXME */ //confirm that it's only config_pkg::WB and not others caches configurations
277        unreachable            if (!commit_drop_i[0]) begin
278        unreachable              commit_ack_o[0] = no_st_pending_i;
279                                 // tell the controller to flush the I$
280        unreachable              fence_i_o = no_st_pending_i;
281                               end
                   ==>  MISSING_ELSE
282                             end
                        MISSING_ELSE
283                             // ------------------
284                             // FENCE Logic
285                             // ------------------
286                             // fence is idempotent so we can safely re-execute it after returning
287                             // from interrupt service routine
288        1/1                  if (commit_instr_i[0].op == FENCE) begin
289        1/1                    if (!commit_drop_i[0]) begin
290        1/1                      commit_ack_o[0] = no_st_pending_i;
291                                 // tell the controller to flush the D$
292        1/1                      fence_o = no_st_pending_i;
293                               end
                   ==>  MISSING_ELSE
294                             end
                        MISSING_ELSE
295                             // ------------------
296                             // AMO
297                             // ------------------
298        1/1                  if (CVA6Cfg.RVA && instr_0_is_amo) begin
299                               // AMO finished
300        unreachable            commit_ack_o[0] = amo_resp_ack;
301                               // flush the pipeline
302        unreachable            flush_commit_o = amo_resp_ack;
303        unreachable            amo_valid_commit_o = 1'b1;
304        unreachable            we_gpr_o[0] = amo_resp_ack;
305                             end
                        MISSING_ELSE
306                           end
307                         end
                        MISSING_ELSE
308                     
309        1/1              if (CVA6Cfg.NrCommitPorts > 1) begin
310        unreachable        commit_macro_ack[1] = 1'b0;
311        unreachable        commit_ack_o[1]     = 1'b0;
312        unreachable        we_gpr_o[1]         = 1'b0;
313        unreachable        wdata_o[1]          = commit_instr_i[1].result;
314                     
315                           // -----------------
316                           // Commit Port 2
317                           // -----------------
318                           // check if the second instruction can be committed as well and the first wasn't a CSR instruction
319                           // also if we are in single step mode don't retire the second instruction
320        unreachable        if (commit_ack_o[0] && commit_instr_i[1].valid
321                                                     && !halt_i
322                                                     && !(commit_instr_i[0].fu inside {CSR})
323                                                     && !flush_dcache_i
324                                                     && !(CVA6Cfg.RVA && instr_0_is_amo)
325                                                     && !single_step_i) begin
326                             // only if the first instruction didn't throw an exception and this instruction won't throw an exception
327                             // and the functional unit is of type ALU, LOAD, CTRL_FLOW, MULT, FPU or FPU_VEC
328        unreachable          if (!commit_instr_i[1].ex.valid && (commit_instr_i[1].fu inside {ALU, LOAD, CTRL_FLOW, MULT, FPU, FPU_VEC})) begin
329                     
330        unreachable            if (CVA6Cfg.RVZCMP && commit_instr_i[1].is_macro_instr && commit_instr_i[1].is_last_macro_instr)
331        unreachable              commit_macro_ack[1] = 1'b1;
332        unreachable            else commit_macro_ack[1] = 1'b0;
333                     
334        unreachable            commit_ack_o[1] = 1'b1;
335                     
336        unreachable            if (!commit_drop_i[1]) begin
337        unreachable              if (CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(commit_instr_i[1].op))
338        unreachable                we_fpr_o[1] = 1'b1;
339        unreachable              else we_gpr_o[1] = 1'b1;
340                     
341                                 // additionally check if we are retiring an FPU instruction because we need to make sure that we write all
342                                 // exception flags
343        unreachable              if (CVA6Cfg.FpPresent) begin
344        unreachable                if (commit_instr_i[1].fu inside {FPU, FPU_VEC}) begin
345        unreachable                  if (csr_write_fflags_o)
346        unreachable                    csr_wdata_o = {
347                                         {CVA6Cfg.XLEN - 5{1'b0}},
348                                         (commit_instr_i[0].ex.cause[4:0] | commit_instr_i[1].ex.cause[4:0])
349                                       };
350        unreachable                  else csr_wdata_o = {{CVA6Cfg.XLEN - 5{1'b0}}, commit_instr_i[1].ex.cause[4:0]};
351        unreachable                  csr_write_fflags_o = 1'b1;
352                                   end
                   ==>  MISSING_ELSE
353                                 end
                   ==>  MISSING_ELSE
354                               end
                   ==>  MISSING_ELSE
355                             end
                   ==>  MISSING_ELSE
356                           end
                   ==>  MISSING_ELSE
357                         end
                        MISSING_ELSE
358        1/1              if (CVA6Cfg.RVZCMP) begin
359        unreachable        for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin
360        unreachable          commit_macro_ack_o[i] = commit_instr_i[i].is_macro_instr ? commit_macro_ack[i] : commit_ack_o[i];
361                           end
362        1/1              end else commit_macro_ack_o = commit_ack_o;
363                       end
364                     
365                       // -----------------------------
366                       // Exception & Interrupt Logic
367                       // -----------------------------
368                       // here we know for sure that we are taking the exception
369                       always_comb begin : exception_handling
370                         // Multiple simultaneous interrupts and traps at the same privilege level are handled in the following decreasing
371                         // priority order: external interrupts, software interrupts, timer interrupts, then finally any synchronous traps. (1.10 p.30)
372                         // interrupts are correctly prioritized in the CSR reg file, exceptions are prioritized here
373        1/1              exception_o.valid = 1'b0;
374        1/1              exception_o.cause = '0;
375        1/1              exception_o.tval  = '0;
376        1/1              exception_o.tval2 = '0;
377        1/1              exception_o.tinst = '0;
378        1/1              exception_o.gva   = 1'b0;
379                     
380                         // we need a valid instruction in the commit stage
381        1/1              if (commit_instr_i[0].valid && !(CVA6Cfg.SpeculativeSb && commit_drop_i[0])) begin
382                           // ------------------------
383                           // check for CSR exception
384                           // ------------------------
385        1/1                if (csr_exception_i.valid) begin
386        1/1                  exception_o      = csr_exception_i;
387                             // if no earlier exception happened the commit instruction will still contain
388                             // the instruction bits from the ID stage. If a earlier exception happened we don't care
389                             // as we will overwrite it anyway in the next IF bl
390        1/1                  exception_o.tval = commit_instr_i[0].ex.tval;
391        1/1                  if (CVA6Cfg.RVH) begin
392        unreachable            exception_o.tinst = commit_instr_i[0].ex.tinst;
393        unreachable            exception_o.tval2 = commit_instr_i[0].ex.tval2;
394        unreachable            exception_o.gva   = commit_instr_i[0].ex.gva;
395                             end
                        MISSING_ELSE
396                           end
                        MISSING_ELSE
397                           // ------------------------
398                           // Earlier Exceptions
399                           // ------------------------
400                           // but we give precedence to exceptions which happened earlier e.g.: instruction page
401                           // faults for example
402        1/1                if (commit_instr_i[0].ex.valid) begin
403        1/1                  exception_o = commit_instr_i[0].ex;
404                           end
                        MISSING_ELSE
405                         end
                        MISSING_ELSE
406                         // Don't take any exceptions iff:
407                         // - If we halted the processor
408        1/1              if (halt_i) begin
409        1/1                exception_o.valid = 1'b0;
410                         end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : commit_stage

               Total   Covered  Percent
Conditions         13       13   100.00
Logical            13       13   100.00
Non-Logical         0        0
Event               0        0

 LINE       162
 EXPRESSION (commit_instr_i[0].valid && ((!halt_i)))
             -----------1-----------    -----2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       187
 EXPRESSION ((commit_instr_i[0].fu == STORE) && ((!(1'b0 && instr_0_is_amo))))
             ---------------1---------------    --------------2--------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       187
 SUB-EXPRESSION (commit_instr_i[0].fu == STORE)
                ---------------1---------------

-1- Status
 0  Covered
 1  Covered

 LINE       213
 EXPRESSION (commit_instr_i[0].fu == CSR)
            --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       288
 EXPRESSION (commit_instr_i[0].op == FENCE)
            ---------------1---------------

-1- Status
 0  Covered
 1  Covered

 LINE       320
 EXPRESSION 
 Number  Term
      1  commit_ack_o[0] && 
      2  commit_instr_i[1].valid && 
      3  ((!halt_i)) && 
      4  ((!(commit_instr_i[0].fu inside {CSR}))) && 
      5  ((!flush_dcache_i)) && 
      6  ((!(1'b0 && instr_0_is_amo))) && 
      7  ((!single_step_i)))

-1- -2- -3- -4- -5- -6- -7- Status
 0   1   1   1   1   1   1  Unreachable
 1   0   1   1   1   1   1  Unreachable
 1   1   0   1   1   1   1  Unreachable
 1   1   1   0   1   1   1  Unreachable
 1   1   1   1   0   1   1  Unreachable
 1   1   1   1   1   0   1  Unreachable
 1   1   1   1   1   1   0  Unreachable
 1   1   1   1   1   1   1  Unreachable

 LINE       328
 EXPRESSION (((!commit_instr_i[1].ex.valid)) && (commit_instr_i[1].fu inside {ALU, LOAD, CTRL_FLOW, MULT, FPU, FPU_VEC}))
             ---------------1---------------    ------------------------------------2-----------------------------------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       360
 EXPRESSION (commit_instr_i[i].is_macro_instr ? commit_macro_ack[i] : commit_ack_o[i])
             ----------------1---------------

-1- Status
 0  Unreachable
 1  Unreachable

 LINE       381
 EXPRESSION (commit_instr_i[0].valid && ((!(1'b0 && commit_drop_i[0]))))
             -----------1-----------    ---------------2---------------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.commit_stage_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME         
100.00 100.00 100.00 --     commit_stage 


Parent : 

SCORE  LINE   COND   ASSERT NAME                               
100.00 100.00 100.00 --     cva6_only_pipeline.i_cva6_pipeline 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : store_buffer
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/store_buffer.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                                         
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i.i_store_unit.store_buffer_i 



-------------------------------------------------------------------------------
Line Coverage for Module : store_buffer

             Line No.   Total   Covered  Percent
TOTAL                       75       75   100.00
ALWAYS             88       23       23   100.00
ALWAYS            172       23       23   100.00
ALWAYS            233       11       11   100.00
ALWAYS            260        9        9   100.00
ALWAYS            275        9        9   100.00

87                          automatic logic [$clog2(DEPTH_SPEC):0] speculative_status_cnt;
88         1/1              speculative_status_cnt      = speculative_status_cnt_q;
89                      
90                          // default assignments
91         1/1              speculative_read_pointer_n  = speculative_read_pointer_q;
92         1/1              speculative_write_pointer_n = speculative_write_pointer_q;
93         1/1              speculative_queue_n         = speculative_queue_q;
94                          // LSU interface
95                          // we are ready to accept a new entry and the input data is valid
96         1/1              if (valid_i) begin
97         1/1                speculative_queue_n[speculative_write_pointer_q].address = paddr_i;
98         1/1                speculative_queue_n[speculative_write_pointer_q].data = data_i;
99         1/1                speculative_queue_n[speculative_write_pointer_q].be = be_i;
100        1/1                speculative_queue_n[speculative_write_pointer_q].data_size = data_size_i;
101        1/1                speculative_queue_n[speculative_write_pointer_q].valid = 1'b1;
102                           // advance the write pointer
103        1/1                speculative_write_pointer_n = speculative_write_pointer_q + 1'b1;
104        1/1                speculative_status_cnt++;
105                         end
                        MISSING_ELSE
106                     
107                         // evict the current entry out of this queue, the commit queue will thankfully take it and commit it
108                         // to the memory hierarchy
109        1/1              if (commit_i) begin
110                           // invalidate
111        1/1                speculative_queue_n[speculative_read_pointer_q].valid = 1'b0;
112                           // advance the read pointer
113        1/1                speculative_read_pointer_n = speculative_read_pointer_q + 1'b1;
114        1/1                speculative_status_cnt--;
115                         end
                        MISSING_ELSE
116                     
117        1/1              speculative_status_cnt_n = speculative_status_cnt;
118                     
119                         // when we flush evict the speculative stores
120        1/1              if (flush_i) begin
121                           // reset all valid flags
122        2/2                for (int unsigned i = 0; i < DEPTH_SPEC; i++) speculative_queue_n[i].valid = 1'b0;
123                     
124        1/1                speculative_write_pointer_n = speculative_read_pointer_q;
125                           // also reset the status count
126        1/1                speculative_status_cnt_n = 'b0;
127                         end
                        MISSING_ELSE
128                     
129                         // we are ready if the speculative and the commit queue have a space left
130        1/1              ready_o = CVA6Cfg.MmuPresent ? (speculative_status_cnt_n < (DEPTH_SPEC)) || commit_i : speculative_status_cnt_q < (DEPTH_SPEC);
131                       end
132                     
133                       // ----------------------------------------
134                       // Commit Queue - Memory Interface
135                       // ----------------------------------------
136                     
137                       logic direct_req_from_speculative;
138                       // we will never kill a request in the store buffer since we already know that the translation is valid
139                       // e.g.: a kill request will only be necessary if we are not sure if the requested memory address will result in a TLB fault
140                     
141                       assign rvfi_mem_paddr_o = direct_req_from_speculative ? speculative_queue_q[speculative_read_pointer_q].address : commit_queue_n[commit_read_pointer_n].address;
142                     
143                       assign obi_store_req_o.reqpar = !obi_store_req_o.req;
144                       assign obi_store_req_o.a.addr = direct_req_from_speculative ? speculative_queue_q[speculative_read_pointer_q].address : commit_queue_q[commit_read_pointer_q].address;
145                       assign obi_store_req_o.a.we = 1'b1;
146                       assign obi_store_req_o.a.be = direct_req_from_speculative ? speculative_queue_q[speculative_read_pointer_q].be : commit_queue_q[commit_read_pointer_q].be;
147                       assign obi_store_req_o.a.wdata = direct_req_from_speculative ? speculative_queue_q[speculative_read_pointer_q].data : commit_queue_q[commit_read_pointer_q].data;
148                       assign obi_store_req_o.a.aid = '0;
149                       assign obi_store_req_o.a.a_optional.auser = '0;
150                       assign obi_store_req_o.a.a_optional.wuser = '0;
151                       assign obi_store_req_o.a.a_optional.atop = '0;
152                       assign obi_store_req_o.a.a_optional.memtype[0] = '0;
153                       assign obi_store_req_o.a.a_optional.memtype[1] = config_pkg::is_inside_cacheable_regions(
154                           CVA6Cfg,
155                           {
156                             {64 - CVA6Cfg.PLEN{1'b0}},
157                             direct_req_from_speculative ? speculative_queue_q[speculative_read_pointer_q].address : commit_queue_q[commit_read_pointer_q].address
158                           }  //TO DO CHECK GRANULARITY
159                       );
160                       assign obi_store_req_o.a.a_optional.mid = '0;
161                       assign obi_store_req_o.a.a_optional.prot[2:1] = 2'b11;
162                       assign obi_store_req_o.a.a_optional.prot[0] = 1'b1;  //data
163                       assign obi_store_req_o.a.a_optional.dbg = '0;
164                       assign obi_store_req_o.a.a_optional.achk = '0;
165                     
166                       //TODO check parity : obi_store_rsp_i.gntpar != obi_store_rsp_i.gnt
167                       assign obi_store_req_o.rready = '1;  //always ready
168                       assign obi_store_req_o.rreadypar = '0;
169                     
170                       always_comb begin : store_if
171                         automatic logic [$clog2(DEPTH_COMMIT):0] commit_status_cnt;
172        1/1              commit_status_cnt           = commit_status_cnt_q;
173                     
174        1/1              commit_ready_o              = (commit_status_cnt_q < DEPTH_COMMIT);
175                         // no store is pending if we don't have any element in the commit queue e.g.: it is empty
176        1/1              no_st_pending_o             = (commit_status_cnt_q == 0);
177                         // default assignments
178        1/1              commit_read_pointer_n       = commit_read_pointer_q;
179        1/1              commit_write_pointer_n      = commit_write_pointer_q;
180                     
181        1/1              commit_queue_n              = commit_queue_q;
182                     
183        1/1              obi_store_req_o.req         = 1'b0;
184                     
185        1/1              direct_req_from_speculative = 1'b0;
186                     
187                         // there should be no commit when we are flushing
188                         // if the entry in the commit queue is valid and not speculative anymore we can issue this instruction
189        1/1              if (commit_queue_q[commit_read_pointer_q].valid && !stall_st_pending_i) begin
190        1/1                obi_store_req_o.req = 1'b1;
191        1/1                if (obi_store_rsp_i.gnt) begin
192                             // we can evict it from the commit buffer
193        1/1                  commit_queue_n[commit_read_pointer_q].valid = 1'b0;
194                             // advance the read_pointer
195        1/1                  commit_read_pointer_n = commit_read_pointer_q + 1'b1;
196        1/1                  commit_status_cnt--;
197                           end
                        MISSING_ELSE
198        1/1              end else if (speculative_queue_q[speculative_read_pointer_q].valid) begin
199        1/1                if (commit_i && (commit_write_pointer_q == speculative_read_pointer_q) && !stall_st_pending_i) begin
200        1/1                  obi_store_req_o.req = 1'b1;
201        1/1                  direct_req_from_speculative = 1'b1;
202                           end
                        MISSING_ELSE
203                         end
                        MISSING_ELSE
204                         // we ignore the rvalid signal for now as we assume that the store
205                         // happened if we got a grant
206                     
207                         // shift the store request from the speculative buffer to the non-speculative
208        1/1              if (commit_i && !(obi_store_rsp_i.gnt && direct_req_from_speculative)) begin
209        1/1                commit_queue_n[commit_write_pointer_q] = speculative_queue_q[speculative_read_pointer_q];
210        1/1                commit_write_pointer_n = commit_write_pointer_n + 1'b1;
211        1/1                commit_status_cnt++;
212                         end
                        MISSING_ELSE
213                     
214        1/1              commit_status_cnt_n = commit_status_cnt;
215                       end
216                     
217                       // ------------------
218                       // Address Checker
219                       // ------------------
220                       // The load should return the data stored by the most recent store to the
221                       // same physical address.  The most direct way to implement this is to
222                       // maintain physical addresses in the store buffer.
223                     
224                       // Of course, there are other micro-architectural techniques to accomplish
225                       // the same thing: you can interlock and wait for the store buffer to
226                       // drain if the load VA matches any store VA modulo the page size (i.e.
227                       // bits 11:0).  As a special case, it is correct to bypass if the full VA
228                       // matches, and no younger stores' VAs match in bits 11:0.
229                       //
230                       // checks if the requested load is in the store buffer
231                       // page offsets are virtually and physically the same
232                       always_comb begin : address_checker
233        1/1              page_offset_matches_o = 1'b0;
234                     
235                         // check if the LSBs are identical and the entry is valid
236        1/1              for (int unsigned i = 0; i < DEPTH_COMMIT; i++) begin
237                           // Check if the page offset matches and whether the entry is valid, for the commit queue
238        1/1                if ((page_offset_i[11:3] == commit_queue_q[i].address[11:3]) && commit_queue_q[i].valid) begin
239        1/1                  page_offset_matches_o = 1'b1;
240        1/1                  break;
241                           end
                        MISSING_ELSE
242                         end
243                     
244        1/1              for (int unsigned i = 0; i < DEPTH_SPEC; i++) begin
245                           // do the same for the speculative queue
246        1/1                if ((page_offset_i[11:3] == speculative_queue_q[i].address[11:3]) && speculative_queue_q[i].valid) begin
247        1/1                  page_offset_matches_o = 1'b1;
248        1/1                  break;
249                           end
                        MISSING_ELSE
250                         end
251                         // or it matches with the entry we are currently putting into the queue
252        1/1              if ((page_offset_i[11:3] == paddr_i[11:3]) && valid_without_flush_i) begin
253        1/1                page_offset_matches_o = 1'b1;
254                         end
                        MISSING_ELSE
255                       end
256                     
257                     
258                       // registers
259                       always_ff @(posedge clk_i or negedge rst_ni) begin : p_spec
260        1/1              if (~rst_ni) begin
261        1/1                speculative_queue_q         <= '{default: 0};
262        1/1                speculative_read_pointer_q  <= '0;
263        1/1                speculative_write_pointer_q <= '0;
264        1/1                speculative_status_cnt_q    <= '0;
265                         end else begin
266        1/1                speculative_queue_q         <= speculative_queue_n;
267        1/1                speculative_read_pointer_q  <= speculative_read_pointer_n;
268        1/1                speculative_write_pointer_q <= speculative_write_pointer_n;
269        1/1                speculative_status_cnt_q    <= speculative_status_cnt_n;
270                         end
271                       end
272                     
273                       // registers
274                       always_ff @(posedge clk_i or negedge rst_ni) begin : p_commit
275        1/1              if (~rst_ni) begin
276        1/1                commit_queue_q         <= '{default: 0};
277        1/1                commit_read_pointer_q  <= '0;
278        1/1                commit_write_pointer_q <= '0;
279        1/1                commit_status_cnt_q    <= '0;
280                         end else begin
281        1/1                commit_queue_q         <= commit_queue_n;
282        1/1                commit_read_pointer_q  <= commit_read_pointer_n;
283        1/1                commit_write_pointer_q <= commit_write_pointer_n;
284        1/1                commit_status_cnt_q    <= commit_status_cnt_n;

-------------------------------------------------------------------------------
Cond Coverage for Module : store_buffer

               Total   Covered  Percent
Conditions         46       46   100.00
Logical            46       46   100.00
Non-Logical         0        0
Event               0        0

 LINE       176
 EXPRESSION (commit_status_cnt_q == 3'b0)
            --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       189
 EXPRESSION (commit_queue_q[commit_read_pointer_q].valid && ((!stall_st_pending_i)))
             ---------------------1---------------------    -----------2-----------

-1- -2- Status
 0   1  Covered
 1   0  Unreachable
 1   1  Covered

 LINE       199
 EXPRESSION (commit_i && (commit_write_pointer_q == speculative_read_pointer_q) && ((!stall_st_pending_i)))
             ----1---    ---------------------------2--------------------------    -----------3-----------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Unreachable
 1   1   1  Covered

 LINE       199
 SUB-EXPRESSION (commit_write_pointer_q == speculative_read_pointer_q)
                ---------------------------1--------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       208
 EXPRESSION (commit_i && ( ! (obi_store_rsp_i.gnt && direct_req_from_speculative) ))
             ----1---    -----------------------------2----------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       208
 SUB-EXPRESSION ( ! (obi_store_rsp_i.gnt && direct_req_from_speculative) )
                    --------------------------1-------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       208
 SUB-EXPRESSION (obi_store_rsp_i.gnt && direct_req_from_speculative)
                 ---------1---------    -------------2-------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       238
 EXPRESSION ((page_offset_i[11:3] == commit_queue_q[i].address[11:3]) && commit_queue_q[i].valid)
             ----------------------------1---------------------------    -----------2-----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       238
 SUB-EXPRESSION (page_offset_i[11:3] == commit_queue_q[i].address[11:3])
                ----------------------------1---------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       246
 EXPRESSION ((page_offset_i[11:3] == speculative_queue_q[i].address[11:3]) && speculative_queue_q[i].valid)
             ------------------------------1------------------------------    --------------2-------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       246
 SUB-EXPRESSION (page_offset_i[11:3] == speculative_queue_q[i].address[11:3])
                ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       252
 EXPRESSION ((page_offset_i[11:3] == paddr_i[11:3]) && valid_without_flush_i)
             -------------------1------------------    ----------2----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       252
 SUB-EXPRESSION (page_offset_i[11:3] == paddr_i[11:3])
                -------------------1------------------

-1- Status
 0  Covered
 1  Covered

 LINE       82
 EXPRESSION ((speculative_status_cnt_q == 3'b0) & ((!valid_i)) & no_st_pending_o)
             -----------------1----------------   ------2-----   -------3-------

-1- -2- -3- Status
 0   1   1  Covered
 1   0   1  Covered
 1   1   0  Covered
 1   1   1  Covered

 LINE       82
 SUB-EXPRESSION (speculative_status_cnt_q == 3'b0)
                -----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       141
 EXPRESSION (direct_req_from_speculative ? speculative_queue_q[speculative_read_pointer_q].address : commit_queue_n[commit_read_pointer_n].address)
             -------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       144
 EXPRESSION (direct_req_from_speculative ? speculative_queue_q[speculative_read_pointer_q].address : commit_queue_q[commit_read_pointer_q].address)
             -------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       146
 EXPRESSION (direct_req_from_speculative ? speculative_queue_q[speculative_read_pointer_q].be : commit_queue_q[commit_read_pointer_q].be)
             -------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       147
 EXPRESSION (direct_req_from_speculative ? speculative_queue_q[speculative_read_pointer_q].data : commit_queue_q[commit_read_pointer_q].data)
             -------------1-------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i.i_store_unit.store_buffer_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME         
100.00 100.00 100.00 --     store_buffer 


Parent : 

SCORE  LINE   COND   ASSERT NAME         
100.00 100.00 100.00 --     i_store_unit 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : store_unit
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/store_unit.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                          
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i.i_store_unit 



-------------------------------------------------------------------------------
Line Coverage for Module : store_unit

             Line No.   Total   Covered  Percent
TOTAL                       53       53   100.00
ROUTINE            94        9        9   100.00
ALWAYS            162       22       22   100.00
ALWAYS            223        5        5   100.00
ALWAYS            321       17       17   100.00

93                          // Set addr[2] to 1'b0 when 32bits
94         1/1              logic [ 2:0] addr_tmp = {(addr[2] && CVA6Cfg.IS_XLEN64), addr[1:0]};
95         1/1              logic [63:0] data_tmp = {64{1'b0}};
96         1/1              case (addr_tmp)
97         1/1                3'b000: data_tmp[CVA6Cfg.XLEN-1:0] = {data[CVA6Cfg.XLEN-1:0]};
98                            3'b001:
99         1/1                data_tmp[CVA6Cfg.XLEN-1:0] = {data[CVA6Cfg.XLEN-9:0], data[CVA6Cfg.XLEN-1:CVA6Cfg.XLEN-8]};
100                           3'b010:
101        1/1                data_tmp[CVA6Cfg.XLEN-1:0] = {data[CVA6Cfg.XLEN-17:0], data[CVA6Cfg.XLEN-1:CVA6Cfg.XLEN-16]};
102                           3'b011:
103        1/1                data_tmp[CVA6Cfg.XLEN-1:0] = {data[CVA6Cfg.XLEN-25:0], data[CVA6Cfg.XLEN-1:CVA6Cfg.XLEN-24]};
104                           default:
105        1/1                if (CVA6Cfg.IS_XLEN64) begin
106        unreachable          case (addr_tmp)
107        unreachable            3'b100:  data_tmp = {data[31:0], data[63:32]};
108        unreachable            3'b101:  data_tmp = {data[23:0], data[63:24]};
109        unreachable            3'b110:  data_tmp = {data[15:0], data[63:16]};
110        unreachable            3'b111:  data_tmp = {data[7:0], data[63:8]};
111        unreachable            default: data_tmp = {data[63:0]};
112                             endcase
113                           end
                        MISSING_ELSE
114                         endcase
115        1/1              return data_tmp[CVA6Cfg.XLEN-1:0];
116                       endfunction
117                     
118                       // it doesn't matter what we are writing back as stores don't return anything
119                       assign result_o   = lsu_ctrl_i.data;
120                     
121                       // directly forward exception fields (valid bit is set below)
122                       assign ex_o.cause = ex_i.cause;
123                       assign ex_o.tval  = ex_i.tval;
124                       assign ex_o.tval2 = CVA6Cfg.RVH ? ex_i.tval2 : '0;
125                       assign ex_o.tinst = CVA6Cfg.RVH ? ex_i.tinst : '0;
126                       assign ex_o.gva   = CVA6Cfg.RVH ? ex_i.gva : 1'b0;
127                     
128                       // store buffer control signals
129                       logic instr_is_amo;
130                       assign instr_is_amo = is_amo(lsu_ctrl_i.operation);
131                       // keep the data and the byte enable for the second cycle (after address translation)
132                       logic [CVA6Cfg.XLEN-1:0] st_data, st_data_n, st_data_q;
133                       logic [(CVA6Cfg.XLEN/8)-1:0] st_be, st_be_n, st_be_q;
134                       logic [1:0] st_data_size, st_data_size_n, st_data_size_q;
135                       amo_t amo_op, amo_op_d, amo_op_q;
136                     
137                       logic store_buffer_valid, store_buffer_valid_d, store_buffer_valid_q;
138                       logic store_buffer_valid_no_flush, store_buffer_valid_no_flush_d, store_buffer_valid_no_flush_q;
139                     
140                       logic amo_buffer_valid, amo_buffer_valid_d, amo_buffer_valid_q;
141                     
142                       logic store_buffer_ready, amo_buffer_ready;
143                     
144                       logic [CVA6Cfg.TRANS_ID_BITS-1:0] trans_id_n, trans_id_q;
145                     
146                       logic ex_s0, ex_s1;
147                       logic stall_translation;
148                     
149                       // output assignments
150                       assign vaddr_o = lsu_ctrl_i.vaddr;  // virtual address
151                       assign hs_ld_st_inst_o = CVA6Cfg.RVH ? lsu_ctrl_i.hs_ld_st_inst : 1'b0;
152                       assign hlvx_inst_o = CVA6Cfg.RVH ? lsu_ctrl_i.hlvx_inst : 1'b0;
153                       assign tinst_o = CVA6Cfg.RVH ? lsu_ctrl_i.tinst : '0;  // transformed instruction
154                     
155                       assign stall_translation = CVA6Cfg.MmuPresent ? translation_req_o && !dtlb_hit_i : 1'b0;
156                     
157                       assign ex_s0 = CVA6Cfg.MmuPresent && stall_translation && ex_i.valid;
158                       assign ex_s1 = CVA6Cfg.MmuPresent ? (store_buffer_valid_q || (CVA6Cfg.RVA && amo_buffer_valid_q)) && ex_i.valid : valid_i && ex_i.valid;
159                     
160                       always_comb begin : store_control
161                         // default assignment
162        1/1              translation_req_o             = 1'b0;
163        1/1              valid_o                       = 1'b0;
164        1/1              amo_buffer_valid_d            = 1'b0;
165        1/1              store_buffer_valid_d          = 1'b0;
166        1/1              store_buffer_valid_no_flush_d = 1'b0;
167        1/1              pop_st_o                      = 1'b0;
168        1/1              ex_o.valid                    = 1'b0;
169        1/1              trans_id_n                    = lsu_ctrl_i.trans_id;
170        1/1              trans_id_o                    = lsu_ctrl_i.trans_id;
171                     
172                         // REQUEST
173        1/1              if (valid_i) begin
174        1/1                translation_req_o = 1'b1;
175        1/1                if (!CVA6Cfg.MmuPresent || !stall_translation) begin
176        1/1                  if (CVA6Cfg.RVA && instr_is_amo) begin
177        unreachable            if (amo_buffer_ready) begin
178        unreachable              pop_st_o = 1'b1;
179        unreachable              amo_buffer_valid_d = !flush_i;
180                                 // RETIRE STORE NO MMU
181        unreachable              if (!CVA6Cfg.MmuPresent) begin
182        unreachable                trans_id_o = lsu_ctrl_i.trans_id;
183        unreachable                valid_o    = 1'b1;
184        unreachable                ex_o.valid = ex_s1;
185                                 end
                   ==>  MISSING_ELSE
186                               end
                   ==>  MISSING_ELSE
187                             end else begin
188        1/1                    if (store_buffer_ready) begin
189        1/1                      pop_st_o = 1'b1;
190        1/1                      store_buffer_valid_d = !flush_i;
191        1/1                      store_buffer_valid_no_flush_d = 1'b1;
192                                 // RETIRE STORE NO MMU
193        1/1                      if (!CVA6Cfg.MmuPresent) begin
194        1/1                        trans_id_o = lsu_ctrl_i.trans_id;
195        1/1                        valid_o    = 1'b1;
196        1/1                        ex_o.valid = ex_s1;
197                                 end
                   ==>  MISSING_ELSE
198                               end
                   ==>  MISSING_ELSE
199                             end
200                           end
                   ==>  MISSING_ELSE
201                         end
                        MISSING_ELSE
202                         // RETIRE STORE WITH MMU
203        1/1              if (CVA6Cfg.MmuPresent) begin
204        unreachable        if (store_buffer_valid_q || (CVA6Cfg.RVA && amo_buffer_valid_q)) begin
205        unreachable          trans_id_o = trans_id_q;
206        unreachable          valid_o    = 1'b1;
207        unreachable          ex_o.valid = ex_s1;
208                           end
                   ==>  MISSING_ELSE
209        unreachable        if (ex_s0) begin
210        unreachable          trans_id_o = lsu_ctrl_i.trans_id;
211        unreachable          valid_o    = 1'b1;
212        unreachable          ex_o.valid = 1'b1;
213        unreachable          pop_st_o = 1'b1;
214                           end
                   ==>  MISSING_ELSE
215                         end
                        MISSING_ELSE
216                       end
217                     
218                       // -----------
219                       // Re-aligner
220                       // -----------
221                       // re-align the write data to comply with the address offset
222                       always_comb begin
223        1/1              st_be_n = lsu_ctrl_i.be;
224                         // don't shift the data if we are going to perform an AMO as we still need to operate on this data
225        1/1              st_data_n = (CVA6Cfg.RVA && instr_is_amo) ? lsu_ctrl_i.data[CVA6Cfg.XLEN-1:0] :
226                             data_align(lsu_ctrl_i.vaddr[2:0], {{64 - CVA6Cfg.XLEN{1'b0}}, lsu_ctrl_i.data});
227        1/1              st_data_size_n = extract_transfer_size(lsu_ctrl_i.operation);
228                         // save AMO op for next cycle
229        1/1              if (CVA6Cfg.RVA) begin
230        unreachable        case (lsu_ctrl_i.operation)
231        unreachable          AMO_LRW, AMO_LRD:     amo_op_d = AMO_LR;
232        unreachable          AMO_SCW, AMO_SCD:     amo_op_d = AMO_SC;
233        unreachable          AMO_SWAPW, AMO_SWAPD: amo_op_d = AMO_SWAP;
234        unreachable          AMO_ADDW, AMO_ADDD:   amo_op_d = AMO_ADD;
235        unreachable          AMO_ANDW, AMO_ANDD:   amo_op_d = AMO_AND;
236        unreachable          AMO_ORW, AMO_ORD:     amo_op_d = AMO_OR;
237        unreachable          AMO_XORW, AMO_XORD:   amo_op_d = AMO_XOR;
238        unreachable          AMO_MAXW, AMO_MAXD:   amo_op_d = AMO_MAX;
239        unreachable          AMO_MAXWU, AMO_MAXDU: amo_op_d = AMO_MAXU;
240        unreachable          AMO_MINW, AMO_MIND:   amo_op_d = AMO_MIN;
241        unreachable          AMO_MINWU, AMO_MINDU: amo_op_d = AMO_MINU;
242        unreachable          default:              amo_op_d = AMO_NONE;
243                           endcase
244                         end else begin
245        1/1                amo_op_d = AMO_NONE;
246                         end
247                       end
248                     
249                       assign st_be = CVA6Cfg.MmuPresent ? st_be_q : st_be_n;
250                       assign st_data = CVA6Cfg.MmuPresent ? st_data_q : st_data_n;
251                       assign st_data_size = CVA6Cfg.MmuPresent ? st_data_size_q : st_data_size_n;
252                       assign amo_op = CVA6Cfg.MmuPresent ? amo_op_q : amo_op_d;
253                       assign store_buffer_valid = CVA6Cfg.MmuPresent ? store_buffer_valid_q && !ex_s1 : store_buffer_valid_d;
254                       assign store_buffer_valid_no_flush = CVA6Cfg.MmuPresent ? store_buffer_valid_no_flush_q && !ex_s1 : store_buffer_valid_no_flush_d;
255                       assign amo_buffer_valid = CVA6Cfg.MmuPresent ? amo_buffer_valid_q && !ex_s1 : amo_buffer_valid_d;
256                     
257                       // ---------------
258                       // Store Queue
259                       // ---------------
260                       store_buffer #(
261                           .CVA6Cfg(CVA6Cfg),
262                           .obi_store_req_t(obi_store_req_t),
263                           .obi_store_rsp_t(obi_store_rsp_t)
264                       ) store_buffer_i (
265                           .clk_i,
266                           .rst_ni,
267                           .flush_i,
268                           .stall_st_pending_i,
269                           .no_st_pending_o,
270                           .store_buffer_empty_o,
271                           .page_offset_i,
272                           .page_offset_matches_o,
273                           .commit_i,
274                           .commit_ready_o,
275                           .ready_o              (store_buffer_ready),
276                           .valid_i              (store_buffer_valid),
277                           // the flush signal can be critical and we need this valid
278                           // signal to check whether the page_offset matches or not,
279                           // functionaly it doesn't make a difference whether we use
280                           // the correct valid signal or not as we are flushing
281                           // the whole pipeline anyway
282                           .valid_without_flush_i(store_buffer_valid_no_flush),
283                           .paddr_i              (paddr_i),
284                           .rvfi_mem_paddr_o     (rvfi_mem_paddr_o),
285                           .data_i               (st_data),
286                           .be_i                 (st_be),
287                           .data_size_i          (st_data_size),
288                           .obi_store_req_o      (obi_store_req_o),
289                           .obi_store_rsp_i      (obi_store_rsp_i)
290                       );
291                     
292                       if (CVA6Cfg.RVA) begin
293                         amo_buffer #(
294                             .CVA6Cfg(CVA6Cfg),
295                             .obi_amo_req_t(obi_amo_req_t),
296                             .obi_amo_rsp_t(obi_amo_rsp_t)
297                         ) i_amo_buffer (
298                             .clk_i,
299                             .rst_ni,
300                             .flush_i,
301                             .valid_i           (amo_buffer_valid),
302                             .ready_o           (amo_buffer_ready),
303                             .paddr_i           (paddr_i),
304                             .amo_op_i          (amo_op),
305                             .data_i            (st_data),
306                             .data_size_i       (st_data_size),
307                             .obi_amo_req_o     (obi_amo_req_o),
308                             .obi_amo_rsp_i     (obi_amo_rsp_i),
309                             .amo_valid_commit_i(amo_valid_commit_i),
310                             .no_st_pending_i   (no_st_pending_o)
311                         );
312                       end else begin
313                         assign amo_buffer_ready = '1;
314                         assign obi_amo_req_o    = '0;
315                       end
316                     
317                       // ---------------
318                       // Registers
319                       // ---------------
320                       always_ff @(posedge clk_i or negedge rst_ni) begin
321        1/1              if (~rst_ni) begin
322        1/1                st_be_q                       <= '0;
323        1/1                st_data_q                     <= '0;
324        1/1                st_data_size_q                <= '0;
325        1/1                trans_id_q                    <= '0;
326        1/1                amo_op_q                      <= AMO_NONE;
327        1/1                amo_buffer_valid_q            <= '0;
328        1/1                store_buffer_valid_q          <= '0;
329        1/1                store_buffer_valid_no_flush_q <= '0;
330                         end else begin
331        1/1                st_be_q                       <= st_be_n;
332        1/1                st_data_q                     <= st_data_n;
333        1/1                trans_id_q                    <= trans_id_n;
334        1/1                st_data_size_q                <= st_data_size_n;
335        1/1                amo_op_q                      <= amo_op_d;
336        1/1                amo_buffer_valid_q            <= amo_buffer_valid_d;
337        1/1                store_buffer_valid_q          <= store_buffer_valid_d;
338        1/1                store_buffer_valid_no_flush_q <= store_buffer_valid_no_flush_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : store_unit

               Total   Covered  Percent
Conditions          3        3   100.00
Logical             3        3   100.00
Non-Logical         0        0
Event               0        0

 LINE       204
 EXPRESSION (store_buffer_valid_q || ((1'b0 && amo_buffer_valid_q)))
             ----------1---------    ---------------2--------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       158
 SUB-EXPRESSION ((store_buffer_valid_q || ((1'b0 && amo_buffer_valid_q))) && ex_i.valid)
                 ----------------------------1---------------------------    -----2----

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       158
 SUB-EXPRESSION (store_buffer_valid_q || ((1'b0 && amo_buffer_valid_q)))
                 ----------1---------    ---------------2--------------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

 LINE       158
 SUB-EXPRESSION (valid_i && ex_i.valid)
                 ---1---    -----2----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i.i_store_unit
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     store_unit 


Parent : 

SCORE  LINE   COND   ASSERT NAME  
 98.75  97.50 100.00 --     lsu_i 


Subtrees :

SCORE  LINE   COND   ASSERT NAME           
100.00 100.00 100.00 --     store_buffer_i 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : branch_unit
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/branch_unit.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                     
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.branch_unit_i 



-------------------------------------------------------------------------------
Line Coverage for Module : branch_unit

             Line No.   Total   Covered  Percent
TOTAL                       33       33   100.00
ALWAYS             61       25       25   100.00
ALWAYS            120        8        8   100.00

60                          // IMPROVEMENT: The ALU can be used to calculate the branch target
61         1/1              jump_base = (fu_data_i.operation == ariane_pkg::JALR) ? fu_data_i.operand_a[CVA6Cfg.VLEN-1:0] : pc_i;
62                      
63         1/1              resolve_branch_o = 1'b0;
64         1/1              resolved_branch_o.target_address = {CVA6Cfg.VLEN{1'b0}};
65         1/1              resolved_branch_o.is_taken = 1'b0;
66         1/1              resolved_branch_o.valid = branch_valid_i;
67         1/1              resolved_branch_o.is_mispredict = 1'b0;
68         1/1              resolved_branch_o.cf_type = branch_predict_i.cf;
69                          // calculate next PC, depending on whether the instruction is compressed or not this may be different
70                          // IMPROVEMENT: We already calculate this a couple of times, maybe re-use?
71         1/1              next_pc                          = pc_i + ((is_compressed_instr_i) ? {{CVA6Cfg.VLEN-2{1'b0}}, 2'h2} : {{CVA6Cfg.VLEN-3{1'b0}}, 3'h4});
72                          // calculate target address simple 64 bit addition
73         1/1              target_address = $unsigned($signed(jump_base) + $signed(fu_data_i.imm[CVA6Cfg.VLEN-1:0]));
74                          // on a JALR we are supposed to reset the LSB to 0 (according to the specification)
75         2/2              if (fu_data_i.operation == ariane_pkg::JALR) target_address[0] = 1'b0;
                        MISSING_ELSE
76                          // we need to put the branch target address into rd, this is the result of this unit
77         1/1              branch_result_o = next_pc;
78         1/1              resolved_branch_o.pc = pc_i;
79                          // There are only three sources of mispredicts:
80                          // 1. Branches
81                          // 2. Jumps to register addresses
82                          // 3. Zcmt instructions
83         1/1              if (branch_valid_i) begin
84                            // write target address which goes to PC Gen or select target address if zcmt
85         1/1                resolved_branch_o.target_address = (branch_comp_res_i) ? target_address : next_pc;
86         1/1                resolved_branch_o.is_taken = branch_comp_res_i;
87         1/1                if (CVA6Cfg.RVZCMT) begin
88         unreachable          if (is_zcmt_i) begin
89                                // Unconditional jump handling
90         unreachable            resolved_branch_o.is_mispredict = 1'b1;  // miss prediction for ZCMT 
91         unreachable            resolved_branch_o.cf_type = ariane_pkg::JumpR;
92                              end
                   ==>  MISSING_ELSE
93                            end
                        MISSING_ELSE
94                            // check the outcome of the branch speculation
95         1/1                if (ariane_pkg::op_is_branch(fu_data_i.operation)) begin
96                              // Set the `cf_type` of the output as `branch`, this will update the BHT.
97         1/1                  resolved_branch_o.cf_type = ariane_pkg::Branch;
98                              // If the ALU comparison does not agree with the BHT prediction set the resolution as mispredicted.
99         1/1                  resolved_branch_o.is_mispredict  = branch_comp_res_i != (branch_predict_i.cf == ariane_pkg::Branch);
100                           end
                        MISSING_ELSE
101        1/1                if (fu_data_i.operation == ariane_pkg::JALR
102                               // check if the address of the jump register is correct and that we actually predicted
103                               && (branch_predict_i.cf == ariane_pkg::NoCF || target_address != branch_predict_i.predict_address)) begin
104        1/1                  resolved_branch_o.is_mispredict = 1'b1;
105                             // update BTB only if this wasn't a return
106        1/1                  if (branch_predict_i.cf != ariane_pkg::Return)
107        1/1                    resolved_branch_o.cf_type = ariane_pkg::JumpR;
                        MISSING_ELSE
108                           end
                        MISSING_ELSE
109                           // to resolve the branch in ID
110        1/1                resolve_branch_o = 1'b1;
111                         end
                        MISSING_ELSE
112                       end
113                       // use ALU exception signal for storing instruction fetch exceptions if
114                       // the target address is not aligned to a 2 byte boundary
115                       //
116                       logic jump_taken;
117                       always_comb begin : exception_handling
118                     
119                         // Do a jump if it is either unconditional jump (JAL | JALR) or `taken` conditional jump
120        1/1              branch_exception_o.cause = riscv::INSTR_ADDR_MISALIGNED;
121        1/1              branch_exception_o.valid = 1'b0;
122        1/1              if (CVA6Cfg.TvalEn)
123        unreachable        branch_exception_o.tval = {{CVA6Cfg.XLEN - CVA6Cfg.VLEN{pc_i[CVA6Cfg.VLEN-1]}}, pc_i};
124        1/1              else branch_exception_o.tval = '0;
125        1/1              branch_exception_o.tval2 = {CVA6Cfg.GPLEN{1'b0}};
126        1/1              branch_exception_o.tinst = '0;
127        1/1              branch_exception_o.gva   = CVA6Cfg.RVH ? v_i : 1'b0;
128                         // Only throw instruction address misaligned exception if this is indeed a `taken` conditional branch or
129                         // an unconditional jump
130        1/1              if (!CVA6Cfg.RVC) begin
131        unreachable        jump_taken = !(ariane_pkg::op_is_branch(fu_data_i.operation)) ||
132                               ((ariane_pkg::op_is_branch(fu_data_i.operation)) && branch_comp_res_i);
133        unreachable        if (branch_valid_i && (target_address[0] || target_address[1]) && jump_taken) begin
134        unreachable          branch_exception_o.valid = 1'b1;
135                           end
                   ==>  MISSING_ELSE
136                         end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : branch_unit

               Total   Covered  Percent
Conditions         26       26   100.00
Logical            26       26   100.00
Non-Logical         0        0
Event               0        0

 LINE       61
 EXPRESSION ((fu_data_i.operation == JALR) ? fu_data_i.operand_a[32'b00000000000000000000000000011111:0] : pc_i)
             --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       61
 SUB-EXPRESSION (fu_data_i.operation == JALR)
                --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       71
 EXPRESSION 
 Number  Term
      1  is_compressed_instr_i ? ({{(32'b00000000000000000000000000100000 - 2) {1'b0}}, 2'h2}) : ({{(32'b00000000000000000000000000100000 - 3) {1'b0}}, 3'h4}))

-1- Status
 0  Covered
 1  Covered

 LINE       75
 EXPRESSION (fu_data_i.operation == JALR)
            --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       85
 EXPRESSION (branch_comp_res_i ? target_address : next_pc)
             --------1--------

-1- Status
 0  Covered
 1  Covered

 LINE       99
 EXPRESSION (branch_comp_res_i != (branch_predict_i.cf == Branch))
            ---------------------------1--------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       101
 EXPRESSION ((fu_data_i.operation == JALR) && ((branch_predict_i.cf == NoCF) || (target_address != branch_predict_i.predict_address)))
             --------------1--------------    -------------------------------------------2-------------------------------------------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       101
 SUB-EXPRESSION (fu_data_i.operation == JALR)
                --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       101
 SUB-EXPRESSION ((branch_predict_i.cf == NoCF) || (target_address != branch_predict_i.predict_address))
                 --------------1--------------    --------------------------2-------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       101
 SUB-EXPRESSION (branch_predict_i.cf == NoCF)
                --------------1--------------

-1- Status
 0  Covered
 1  Covered

 LINE       101
 SUB-EXPRESSION (target_address != branch_predict_i.predict_address)
                --------------------------1-------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       106
 EXPRESSION (branch_predict_i.cf != Return)
            ---------------1---------------

-1- Status
 0  Covered
 1  Covered

 LINE       133
 EXPRESSION (branch_valid_i && (target_address[0] || target_address[1]) && jump_taken)
             -------1------    --------------------2-------------------    -----3----

-1- -2- -3- Status
 0   1   1  Unreachable
 1   0   1  Unreachable
 1   1   0  Unreachable
 1   1   1  Unreachable

 LINE       133
 SUB-EXPRESSION (target_address[0] || target_address[1])
                 --------1--------    --------2--------

-1- -2- Status
 0   0  Unreachable
 0   1  Unreachable
 1   0  Unreachable

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.branch_unit_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME        
100.00 100.00 100.00 --     branch_unit 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     ex_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : controller
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/controller.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                         
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.controller_i 



-------------------------------------------------------------------------------
Line Coverage for Module : controller

             Line No.   Total   Covered  Percent
TOTAL                       47       47   100.00
ALWAYS             92       41       41   100.00
ALWAYS            245        1        1   100.00
ALWAYS            252        5        5   100.00

91                        always_comb begin : flush_ctrl
92         1/1              fence_active_d         = fence_active_q;
93         1/1              set_pc_commit_o        = 1'b0;
94         1/1              flush_if_o             = 1'b0;
95         1/1              flush_unissued_instr_o = 1'b0;
96         1/1              flush_id_o             = 1'b0;
97         1/1              flush_ex_o             = 1'b0;
98         1/1              flush_dcache           = 1'b0;
99         1/1              flush_icache_o         = 1'b0;
100        1/1              flush_tlb_o            = 1'b0;
101        1/1              flush_tlb_vvma_o       = 1'b0;
102        1/1              flush_tlb_gvma_o       = 1'b0;
103        1/1              flush_bp_o             = 1'b0;
104                         // ------------
105                         // Mis-predict
106                         // ------------
107                         // flush on mispredict
108        1/1              if (resolved_branch_i.is_mispredict) begin
109                           // flush only un-issued instructions
110        1/1                flush_unissued_instr_o = 1'b1;
111                           // and if stage
112        1/1                flush_if_o             = 1'b1;
113                         end
                        MISSING_ELSE
114                     
115                         // ---------------------------------
116                         // FENCE
117                         // ---------------------------------
118        1/1              if (fence_i) begin
119                           // this can be seen as a CSR instruction with side-effect
120        1/1                set_pc_commit_o        = 1'b1;
121        1/1                flush_if_o             = 1'b1;
122        1/1                flush_unissued_instr_o = 1'b1;
123        1/1                flush_id_o             = 1'b1;
124        1/1                flush_ex_o             = 1'b1;
125                           // this is not needed in the case since we
126                           // have a write-through cache in this case
127        1/1                if (CVA6Cfg.DcacheFlushOnFence) begin
128        unreachable          flush_dcache   = 1'b1;
129        unreachable          fence_active_d = 1'b1;
130                           end
                        MISSING_ELSE
131                         end
                        MISSING_ELSE
132                     
133                         // ---------------------------------
134                         // FENCE.I
135                         // ---------------------------------
136        1/1              if (fence_i_i && (CVA6Cfg.RVZifencei || CVA6Cfg.DCacheType == config_pkg::WB)) begin  /* FIXME */ //confirm that it's only config_pkg::WB and not others caches configurations
137        unreachable        set_pc_commit_o        = 1'b1;
138        unreachable        flush_if_o             = 1'b1;
139        unreachable        flush_unissued_instr_o = 1'b1;
140        unreachable        flush_id_o             = 1'b1;
141        unreachable        flush_ex_o             = 1'b1;
142        unreachable        flush_icache_o         = 1'b1;
143                           // this is not needed in the case since we
144                           // have a write-through cache in this case
145        unreachable        if (CVA6Cfg.DcacheFlushOnFence) begin
146        unreachable          flush_dcache   = 1'b1;
147        unreachable          fence_active_d = 1'b1;
148                           end
                   ==>  MISSING_ELSE
149                         end
                        MISSING_ELSE
150                     
151                         // this is not needed in the case since we
152                         // have a write-through cache in this case
153        1/1              if (CVA6Cfg.DcacheFlushOnFence) begin
154                           // wait for the acknowledge here
155        unreachable        if (flush_dcache_ack_i && fence_active_q) begin
156        unreachable          fence_active_d = 1'b0;
157                             // keep the flush dcache signal high as long as we didn't get the acknowledge from the cache
158        unreachable        end else if (fence_active_q) begin
159        unreachable          flush_dcache = 1'b1;
160                           end
                   ==>  MISSING_ELSE
161                         end
                        MISSING_ELSE
162                         // ---------------------------------
163                         // SFENCE.VMA
164                         // ---------------------------------
165        1/1              if (CVA6Cfg.RVS && sfence_vma_i) begin
166        unreachable        set_pc_commit_o        = 1'b1;
167        unreachable        flush_if_o             = 1'b1;
168        unreachable        flush_unissued_instr_o = 1'b1;
169        unreachable        flush_id_o             = 1'b1;
170        unreachable        flush_ex_o             = 1'b1;
171                     
172        unreachable        if (CVA6Cfg.RVH && v_i) flush_tlb_vvma_o = 1'b1;
173        unreachable        else flush_tlb_o = 1'b1;
174                         end
                        MISSING_ELSE
175                     
176                         // ---------------------------------
177                         // HFENCE.VVMA
178                         // ---------------------------------
179        1/1              if (CVA6Cfg.RVH && hfence_vvma_i) begin
180        unreachable        set_pc_commit_o        = 1'b1;
181        unreachable        flush_if_o             = 1'b1;
182        unreachable        flush_unissued_instr_o = 1'b1;
183        unreachable        flush_id_o             = 1'b1;
184        unreachable        flush_ex_o             = 1'b1;
185                     
186        unreachable        flush_tlb_vvma_o       = 1'b1;
187                         end
                        MISSING_ELSE
188                     
189                         // ---------------------------------
190                         // HFENCE.GVMA
191                         // ---------------------------------
192        1/1              if (CVA6Cfg.RVH && hfence_gvma_i) begin
193        unreachable        set_pc_commit_o        = 1'b1;
194        unreachable        flush_if_o             = 1'b1;
195        unreachable        flush_unissued_instr_o = 1'b1;
196        unreachable        flush_id_o             = 1'b1;
197        unreachable        flush_ex_o             = 1'b1;
198                     
199        unreachable        flush_tlb_gvma_o       = 1'b1;
200                         end
                        MISSING_ELSE
201                     
202                         // ---------------------------------
203                         // CSR side effects and accelerate port
204                         // ---------------------------------
205                         // Set PC to commit stage and flush pipeline
206        1/1              if (flush_csr_i || flush_acc_i) begin
207        1/1                set_pc_commit_o        = 1'b1;
208        1/1                flush_if_o             = 1'b1;
209        1/1                flush_unissued_instr_o = 1'b1;
210        1/1                flush_id_o             = 1'b1;
211        1/1                flush_ex_o             = 1'b1;
212        1/1              end else if (CVA6Cfg.RVA && flush_commit_i) begin
213        unreachable        set_pc_commit_o        = 1'b1;
214        unreachable        flush_if_o             = 1'b1;
215        unreachable        flush_unissued_instr_o = 1'b1;
216        unreachable        flush_id_o             = 1'b1;
217        unreachable        flush_ex_o             = 1'b1;
218                         end
                        MISSING_ELSE
219                     
220                         // ---------------------------------
221                         // 1. Exception
222                         // 2. Return from exception
223                         // ---------------------------------
224        1/1              if (ex_valid_i || eret_i || (CVA6Cfg.DebugEn && set_debug_pc_i)) begin
225                           // don't flush pcgen as we want to take the exception: Flush PCGen is not a flush signal
226                           // for the PC Gen stage but instead tells it to take the PC we gave it
227        1/1                set_pc_commit_o        = 1'b0;
228        1/1                flush_if_o             = 1'b1;
229        1/1                flush_unissued_instr_o = 1'b1;
230        1/1                flush_id_o             = 1'b1;
231        1/1                flush_ex_o             = 1'b1;
232                           // this potentially reduces performance, but is needed
233                           // to suppress speculative fetches to virtual memory from
234                           // machine mode. TODO: remove when PMA checkers have been
235                           // added to the system
236        1/1                flush_bp_o             = 1'b1;
237                         end
                        MISSING_ELSE
238                       end
239                     
240                       // ----------------------
241                       // Halt Logic
242                       // ----------------------
243                       always_comb begin
244                         // halt the core if the fence is active
245        1/1              halt_o = halt_csr_i || halt_acc_i || (CVA6Cfg.DcacheFlushOnFence && fence_active_q);
246                       end
247                     
248                       // ----------------------
249                       // Registers
250                       // ----------------------
251                       always_ff @(posedge clk_i or negedge rst_ni) begin
252        1/1              if (~rst_ni) begin
253        1/1                fence_active_q <= 1'b0;
254        1/1                flush_dcache_o <= 1'b0;
255                         end else begin
256        1/1                fence_active_q <= fence_active_d;
257                           // register on the flush signal, this signal might be critical
258        1/1                flush_dcache_o <= flush_dcache;

-------------------------------------------------------------------------------
Cond Coverage for Module : controller

               Total   Covered  Percent
Conditions          7        7   100.00
Logical             7        7   100.00
Non-Logical         0        0
Event               0        0

 LINE       155
 EXPRESSION (flush_dcache_ack_i && fence_active_q)
             ---------1--------    -------2------

-1- -2- Status
 0   1  Unreachable
 1   0  Unreachable
 1   1  Unreachable

 LINE       206
 EXPRESSION (flush_csr_i || flush_acc_i)
             -----1-----    -----2-----

-1- -2- Status
 0   0  Covered
 0   1  Unreachable
 1   0  Covered

 LINE       224
 EXPRESSION (ex_valid_i || eret_i || ((1'b0 && set_debug_pc_i)))
             -----1----    ---2--    -------------3------------

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Unreachable
 0   1   0  Covered
 1   0   0  Covered

 LINE       245
 EXPRESSION (halt_csr_i || halt_acc_i || ((1'b0 && fence_active_q)))
             -----1----    -----2----    -------------3------------

-1- -2- -3- Status
 0   0   0  Covered
 0   0   1  Unreachable
 0   1   0  Unreachable
 1   0   0  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.controller_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     controller 


Parent : 

SCORE  LINE   COND   ASSERT NAME                               
100.00 100.00 100.00 --     cva6_only_pipeline.i_cva6_pipeline 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : lsu_bypass
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/lsu_bypass.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                          
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i.lsu_bypass_i 



-------------------------------------------------------------------------------
Line Coverage for Module : lsu_bypass

             Line No.   Total   Covered  Percent
TOTAL                       38       38   100.00
ALWAYS             68       26       26   100.00
ALWAYS            110        3        3   100.00
ALWAYS            119        9        9   100.00

67                      
68         1/1              status_cnt = status_cnt_q;
69         1/1              write_pointer = write_pointer_q;
70         1/1              read_pointer = read_pointer_q;
71                      
72         1/1              mem_n = mem_q;
73                          // we've got a valid LSU request
74         1/1              if (lsu_req_valid_i) begin
75         1/1                mem_n[write_pointer_q] = lsu_req_i;
76         1/1                write_pointer++;
77         1/1                status_cnt++;
78                          end
                        MISSING_ELSE
79                      
80         1/1              if (pop_ld_i) begin
81                            // invalidate the result
82         1/1                mem_n[read_pointer_q].valid = 1'b0;
83         1/1                read_pointer++;
84         1/1                status_cnt--;
85                          end
                        MISSING_ELSE
86                      
87         1/1              if (pop_st_i) begin
88                            // invalidate the result
89         1/1                mem_n[read_pointer_q].valid = 1'b0;
90         1/1                read_pointer++;
91         1/1                status_cnt--;
92                          end
                        MISSING_ELSE
93                      
94         2/2              if (pop_st_i && pop_ld_i) mem_n = '0;
                        MISSING_ELSE
95                      
96         1/1              if (flush_i) begin
97         1/1                status_cnt = '0;
98         1/1                write_pointer = '0;
99         1/1                read_pointer = '0;
100        1/1                mem_n = '0;
101                         end
                        MISSING_ELSE
102                         // default assignments
103        1/1              read_pointer_n  = read_pointer;
104        1/1              write_pointer_n = write_pointer;
105        1/1              status_cnt_n    = status_cnt;
106                       end
107                     
108                       // output assignment
109                       always_comb begin : output_assignments
110        1/1              if (empty) begin
111        1/1                lsu_ctrl_o = lsu_req_i;
112                         end else begin
113        1/1                lsu_ctrl_o = mem_q[read_pointer_q];
114                         end
115                       end
116                     
117                       // registers
118                       always_ff @(posedge clk_i or negedge rst_ni) begin
119        1/1              if (~rst_ni) begin
120        1/1                mem_q           <= '0;
121        1/1                status_cnt_q    <= '0;
122        1/1                write_pointer_q <= '0;
123        1/1                read_pointer_q  <= '0;
124                         end else begin
125        1/1                mem_q           <= mem_n;
126        1/1                status_cnt_q    <= status_cnt_n;
127        1/1                write_pointer_q <= write_pointer_n;
128        1/1                read_pointer_q  <= read_pointer_n;

-------------------------------------------------------------------------------
Cond Coverage for Module : lsu_bypass

               Total   Covered  Percent
Conditions          5        5   100.00
Logical             5        5   100.00
Non-Logical         0        0
Event               0        0

 LINE       94
 EXPRESSION (pop_st_i && pop_ld_i)
             ----1---    ----2---

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       60
 EXPRESSION (status_cnt_q == 2'b0)
            -----------1----------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.lsu_i.lsu_bypass_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     lsu_bypass 


Parent : 

SCORE  LINE   COND   ASSERT NAME  
 98.75  97.50 100.00 --     lsu_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : id_stage
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/id_stage.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                       
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.id_stage_i 



-------------------------------------------------------------------------------
Line Coverage for Module : id_stage

             Line No.   Total   Covered  Percent
TOTAL                       20       20   100.00
ALWAYS            281        7        7   100.00
ALWAYS            417       10       10   100.00
ALWAYS            448        3        3   100.00

280                         // No CVXIF, No ZCMP, No ZCMT => Connect directly compressed decoder to decoder
281        1/1              is_illegal_deco    = is_illegal_rvc;
282        1/1              instruction_deco   = instruction_rvc;
283        1/1              is_compressed_deco = is_compressed_rvc;
284        1/1              if (CVA6Cfg.CvxifEn) begin
285        1/1                is_illegal_deco[0]    = is_illegal_cvxif_o;
286        1/1                instruction_deco[0]   = instruction_cvxif_o;
287        1/1                is_compressed_deco[0] = is_compressed_cvxif_o;
288        unreachable      end else if (!CVA6Cfg.CvxifEn && (CVA6Cfg.RVZCMP || CVA6Cfg.RVZCMT)) begin
289        unreachable        is_illegal_deco[0]    = is_illegal_cvxif_i;
290        unreachable        instruction_deco[0]   = instruction_cvxif_i;
291        unreachable        is_compressed_deco[0] = is_compressed_cvxif_i;
292                         end
                   ==>  MISSING_ELSE
293                       end
294                     
295                     
296                       for (genvar i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
297                         decoder #(
298                             .CVA6Cfg(CVA6Cfg),
299                             .branchpredict_sbe_t(branchpredict_sbe_t),
300                             .exception_t(exception_t),
301                             .irq_ctrl_t(irq_ctrl_t),
302                             .scoreboard_entry_t(scoreboard_entry_t),
303                             .interrupts_t(interrupts_t),
304                             .INTERRUPTS(INTERRUPTS)
305                         ) decoder_i (
306                             .debug_req_i,
307                             .irq_ctrl_i,
308                             .irq_i,
309                             .pc_i                      (fetch_entry_i[i].address),
310                             .is_compressed_i           (is_compressed_deco[i]),
311                             .is_macro_instr_i          (is_macro_instr[i]),
312                             .is_zcmt_i                 (is_zcmt_instr[i]),
313                             .is_last_macro_instr_i     (is_last_macro_instr),
314                             .is_double_rd_macro_instr_i(is_double_rd_macro_instr),
315                             .jump_address_i            (jump_address),
316                             .is_illegal_i              (is_illegal_deco[i]),
317                             .instruction_i             (instruction_deco[i]),
318                             .compressed_instr_i        (fetch_entry_i[i].instruction[15:0]),
319                             .branch_predict_i          (fetch_entry_i[i].branch_predict),
320                             .ex_i                      (fetch_entry_i[i].ex),
321                             .priv_lvl_i                (priv_lvl_i),
322                             .v_i                       (v_i),
323                             .debug_mode_i              (debug_mode_i),
324                             .fs_i,
325                             .vfs_i,
326                             .frm_i,
327                             .vs_i,
328                             .tvm_i,
329                             .tw_i,
330                             .vtw_i,
331                             .tsr_i,
332                             .hu_i,
333                             .instruction_o             (decoded_instruction[i]),
334                             .orig_instr_o              (orig_instr[i]),
335                             .is_control_flow_instr_o   (is_control_flow_instr[i])
336                         );
337                       end
338                     
339                       // ------------------
340                       // 3. Pipeline Register
341                       // ------------------
342                       for (genvar i = 0; i < CVA6Cfg.NrIssuePorts; i++) begin
343                         assign issue_entry_o[i] = issue_q[i].sbe;
344                         assign issue_entry_o_prev[i] = CVA6Cfg.FpgaAlteraEn ? issue_n[i].sbe : '0;
345                         assign issue_entry_valid_o[i] = issue_q[i].valid;
346                         assign is_ctrl_flow_o[i] = issue_q[i].is_ctrl_flow;
347                         assign orig_instr_o[i] = issue_q[i].orig_instr;
348                         assign was_compressed_o[i] = issue_q[i].was_compressed;
349                       end
350                     
351                       if (CVA6Cfg.SuperscalarEn) begin
352                         always_comb begin
353                           issue_n = issue_q;
354                           fetch_entry_ready_o = '0;
355                           // instruction is not valid if we stall due to ZCMT or CVXIF
356                           decoded_instruction_valid[0] = (CVA6Cfg.RVZCMT && is_zcmt_instr[0] && stall_macro_deco_zcmt) ||
357                                                          (CVA6Cfg.CvxifEn && is_illegal_cvxif_i && ~stall_macro_deco) && stall_instr_fetch[0]
358                                                          ? 1'b0 : 1'b1;
359                           // Instruction on port 1 are always valid. It is either 32bits or legal 16bits.
360                           decoded_instruction_valid[1] = ~stall_instr_fetch[1];
361                     
362                           // Clear the valid flag if issue has acknowledged the instruction
363                           if (issue_instr_ack_i[0]) begin
364                             issue_n[0].valid = 1'b0;
365                           end
366                           if (issue_instr_ack_i[1]) begin
367                             issue_n[1].valid = 1'b0;
368                           end
369                     
370                           if (!issue_n[0].valid) begin
371                             if (issue_n[1].valid) begin
372                               issue_n[0] = issue_n[1];
373                               issue_n[1].valid = 1'b0;
374                             end else if (fetch_entry_valid_i[0]) begin
375                               fetch_entry_ready_o[0] = ~stall_instr_fetch[0];
376                               issue_n[0] = '{
377                                   decoded_instruction_valid[0],
378                                   decoded_instruction[0],
379                                   orig_instr[0],
380                                   is_control_flow_instr[0],
381                                   is_compressed_rvc[0]
382                               };
383                             end
384                           end
385                     
386                           if (!issue_n[1].valid) begin
387                             if (fetch_entry_ready_o[0]) begin
388                               if (fetch_entry_valid_i[1]) begin
389                                 fetch_entry_ready_o[1] = ~stall_instr_fetch[1];
390                                 issue_n[1] = '{
391                                     decoded_instruction_valid[1],
392                                     decoded_instruction[1],
393                                     orig_instr[1],
394                                     is_control_flow_instr[1],
395                                     is_compressed_rvc[1]
396                                 };
397                               end
398                             end else if (fetch_entry_valid_i[0]) begin
399                               fetch_entry_ready_o[0] = ~stall_instr_fetch[0];
400                               issue_n[1] = '{
401                                   decoded_instruction_valid[0],
402                                   decoded_instruction[0],
403                                   orig_instr[0],
404                                   is_control_flow_instr[0],
405                                   is_compressed_rvc[0]
406                               };
407                             end
408                           end
409                     
410                           if (flush_i) begin
411                             issue_n[0].valid = 1'b0;
412                             issue_n[1].valid = 1'b0;
413                           end
414                         end
415                       end else begin
416                         always_comb begin
417        1/1                issue_n = issue_q;
418        1/1                fetch_entry_ready_o = '0;
419                           // instruction is not valid if we stall due to ZCMT or CVXIF
420        1/1                decoded_instruction_valid[0] = (CVA6Cfg.RVZCMT && is_zcmt_instr[0] && stall_macro_deco_zcmt) ||
421                                                          (CVA6Cfg.CvxifEn && is_illegal_cvxif_i && ~stall_macro_deco && stall_instr_fetch[0])
422                                                          ? 1'b0 : 1'b1;
423                           // Clear the valid flag if issue has acknowledged the instruction
424        2/2                if (issue_instr_ack_i[0]) issue_n[0].valid = 1'b0;
                        MISSING_ELSE
425                     
426                           // if we have a space in the register and the fetch is valid, go get it
427                           // or the issue stage is currently acknowledging an instruction, which means that we will have space
428                           // for a new instruction
429        1/1                if (!issue_n[0].valid && fetch_entry_valid_i[0]) begin
430        1/1                  fetch_entry_ready_o[0] = ~stall_instr_fetch[0];
431        1/1                  issue_n[0] = '{
432                                 decoded_instruction_valid[0],
433                                 decoded_instruction[0],
434                                 orig_instr[0],
435                                 is_control_flow_instr[0],
436                                 is_compressed_rvc[0]
437                             };
438                           end
                        MISSING_ELSE
439                     
440                           // invalidate the pipeline register on a flush
441        2/2                if (flush_i) issue_n[0].valid = 1'b0;
                   ==>  MISSING_ELSE
442                         end
443                       end
444                       // -------------------------
445                       // Registers (ID <-> Issue)
446                       // -------------------------
447                       always_ff @(posedge clk_i or negedge rst_ni) begin
448        1/1              if (~rst_ni) begin
449        1/1                issue_q <= '0;
450                         end else begin
451        1/1                issue_q <= issue_n;

-------------------------------------------------------------------------------
Cond Coverage for Module : id_stage

               Total   Covered  Percent
Conditions         10       10   100.00
Logical            10       10   100.00
Non-Logical         0        0
Event               0        0

 LINE       420
 EXPRESSION 
 Number  Term
      1  ((((1'b0 && is_zcmt_instr[0]) && stall_macro_deco_zcmt)) || (1'b1 && is_illegal_cvxif_i && ((~stall_macro_deco)) && stall_instr_fetch[0])) ? 1'b0 : 1'b1)

-1- Status
 0  Covered
 1  Covered

 LINE       420
 SUB-EXPRESSION ((((1'b0 && is_zcmt_instr[0]) && stall_macro_deco_zcmt)) || (1'b1 && is_illegal_cvxif_i && ((~stall_macro_deco)) && stall_instr_fetch[0]))
                 ---------------------------1---------------------------    --------------------------------------2--------------------------------------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Unreachable

 LINE       420
 SUB-EXPRESSION (1'b1 && is_illegal_cvxif_i && ((~stall_macro_deco)) && stall_instr_fetch[0])
                 --1-    ---------2--------    ----------3----------    ----------4---------

-1- -2- -3- -4- Status
 -   0   1   1  Covered
 -   1   0   1  Unreachable
 -   1   1   0  Covered
 -   1   1   1  Covered

 LINE       429
 EXPRESSION (((!issue_n[0].valid)) && fetch_entry_valid_i[0])
             ----------1----------    -----------2----------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.id_stage_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.12  99.42  98.81 --     


Module : 

SCORE  LINE   COND   ASSERT NAME     
100.00 100.00 100.00 --     id_stage 


Parent : 

SCORE  LINE   COND   ASSERT NAME                               
100.00 100.00 100.00 --     cva6_only_pipeline.i_cva6_pipeline 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                                           
 99.06  98.11 100.00 --     genblk1.genblk1[0].compressed_decoder_i        
100.00 100.00 100.00 --     genblk1.genblk6.i_cvxif_compressed_if_driver_i 
 99.12  99.73  98.51 --     genblk2[0].decoder_i                           



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : cvxif_fu
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/cvxif_fu.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                            
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.gen_cvxif.cvxif_fu_i 



-------------------------------------------------------------------------------
Line Coverage for Module : cvxif_fu

             Line No.   Total   Covered  Percent
TOTAL                        3        3   100.00
ALWAYS             67        3        3   100.00

66                        always_comb begin
67         1/1              x_exception_o.valid = x_illegal_i;
68         1/1              x_exception_o.cause = x_illegal_i ? riscv::ILLEGAL_INSTR : '0;
69         1/1(1 unreachable)      if (CVA6Cfg.TvalEn) x_exception_o.tval = x_off_instr_i;
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : cvxif_fu

               Total   Covered  Percent
Conditions          7        7   100.00
Logical             7        7   100.00
Non-Logical         0        0
Event               0        0

 LINE       68
 EXPRESSION (x_illegal_i ? riscv::ILLEGAL_INSTR : '0)
             -----1-----

-1- Status
 0  Covered
 1  Covered

 LINE       59
 EXPRESSION (x_illegal_i || result_valid_i)
             -----1-----    -------2------

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       61
 EXPRESSION (x_illegal_i ? x_trans_id_i : result_i.id)
             -----1-----

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.gen_cvxif.cvxif_fu_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME     
100.00 100.00 100.00 --     cvxif_fu 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     ex_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : issue_stage
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 --     100.00 --     

Source File(s) : 

cva6/core/issue_stage.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                          
100.00 --     100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i 



-------------------------------------------------------------------------------
Cond Coverage for Module : issue_stage

               Total   Covered  Percent
Conditions          3        3   100.00
Logical             3        3   100.00
Non-Logical         0        0
Event               0        0

 LINE       186
 EXPRESSION (issue_instr_valid_sb_iro[0] & issue_ack_iro_sb[0])
             -------------1-------------   ---------2---------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.issue_stage_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 97.36  99.62  95.10 --     


Module : 

SCORE  LINE   COND   ASSERT NAME        
100.00 --     100.00 --     issue_stage 


Parent : 

SCORE  LINE   COND   ASSERT NAME                               
100.00 100.00 100.00 --     cva6_only_pipeline.i_cva6_pipeline 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                  
 97.46 100.00  94.92 --     i_issue_read_operands 
 97.78  98.18  97.37 --     i_scoreboard          



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : csr_buffer
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/csr_buffer.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                    
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.csr_buffer_i 



-------------------------------------------------------------------------------
Line Coverage for Module : csr_buffer

             Line No.   Total   Covered  Percent
TOTAL                       14       14   100.00
ALWAYS             56       11       11   100.00
ALWAYS             76        3        3   100.00

55                        always_comb begin : write
56         1/1              csr_reg_n   = csr_reg_q;
57                          // by default we are ready
58         1/1              csr_ready_o = 1'b1;
59                          // if we have a valid uncomiited csr req or are just getting one WITHOUT a commit in, we are not ready
60         2/2              if ((csr_reg_q.valid || csr_valid_i) && ~csr_commit_i) csr_ready_o = 1'b0;
                        MISSING_ELSE
61                          // if we got a valid from the scoreboard
62                          // store the CSR address
63         1/1              if (csr_valid_i) begin
64         1/1                csr_reg_n.csr_address = fu_data_i.operand_b[11:0];
65         1/1                csr_reg_n.valid       = 1'b1;
66                          end
                        MISSING_ELSE
67                          // if we get a commit and no new valid instruction -> clear the valid bit
68         1/1              if (csr_commit_i && ~csr_valid_i) begin
69         1/1                csr_reg_n.valid = 1'b0;
70                          end
                        MISSING_ELSE
71                          // clear the buffer if we flushed
72         2/2              if (flush_i) csr_reg_n.valid = 1'b0;
                        MISSING_ELSE
73                        end
74                        // sequential process
75                        always_ff @(posedge clk_i or negedge rst_ni) begin
76         1/1              if (~rst_ni) begin
77         1/1                csr_reg_q <= '{default: 0};
78                          end else begin
79         1/1                csr_reg_q <= csr_reg_n;

-------------------------------------------------------------------------------
Cond Coverage for Module : csr_buffer

               Total   Covered  Percent
Conditions          9        9   100.00
Logical             9        9   100.00
Non-Logical         0        0
Event               0        0

 LINE       60
 EXPRESSION ((csr_reg_q.valid || csr_valid_i) && ((~csr_commit_i)))
             ----------------1---------------    --------2--------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

 LINE       60
 SUB-EXPRESSION (csr_reg_q.valid || csr_valid_i)
                 -------1-------    -----2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       68
 EXPRESSION (csr_commit_i && ((~csr_valid_i)))
             ------1-----    --------2-------

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.csr_buffer_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     csr_buffer 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     ex_stage_i 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : instr_realign
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/instr_realign.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                       
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_realign 



-------------------------------------------------------------------------------
Line Coverage for Module : instr_realign

             Line No.   Total   Covered  Percent
TOTAL                       36       36   100.00
ALWAYS             68       25       25   100.00
ALWAYS            348       11       11   100.00

67                          always_comb begin : re_align
68         1/1                unaligned_d = unaligned_q;
69         1/1                unaligned_address_d = {address_i[CVA6Cfg.VLEN-1:2], 2'b10};
70         1/1                unaligned_instr_d = data_i[31:16];
71                      
72         1/1                valid_o[0] = valid_i;
73         1/1                instr_o[0] = unaligned_q ? {data_i[15:0], unaligned_instr_q} : data_i[31:0];
74         1/1                addr_o[0] = unaligned_q ? unaligned_address_q : address_i;
75                      
76         1/1                if (CVA6Cfg.INSTR_PER_FETCH != 1) begin
77         1/1                  valid_o[CVA6Cfg.INSTR_PER_FETCH-1] = 1'b0;
78         1/1                  instr_o[CVA6Cfg.INSTR_PER_FETCH-1] = '0;
79         1/1                  addr_o[CVA6Cfg.INSTR_PER_FETCH-1]  = {address_i[CVA6Cfg.VLEN-1:2], 2'b10};
80                            end
                   ==>  MISSING_ELSE
81                            // this instruction is compressed or the last instruction was unaligned
82         1/1                if (instr_is_compressed[0] || unaligned_q) begin
83                              // check if this is instruction is still unaligned e.g.: it is not compressed
84                              // if its compressed re-set unaligned flag
85                              // for 32 bit we can simply check the next instruction and whether it is compressed or not
86                              // if it is compressed the next fetch will contain an aligned instruction
87                              // is instruction 1 also compressed
88                              // yes? -> no problem, no -> we've got an unaligned instruction
89         1/1                  if (instr_is_compressed[CVA6Cfg.INSTR_PER_FETCH-1] && CVA6Cfg.RVC) begin
90         1/1                    unaligned_d = 1'b0;
91         1/1                    valid_o[CVA6Cfg.INSTR_PER_FETCH-1] = valid_i;
92         1/1                    instr_o[CVA6Cfg.INSTR_PER_FETCH-1] = {16'b0, data_i[31:16]};
93                              end else begin
94                                // save the upper bits for next cycle
95         1/1                    unaligned_d = 1'b1;
96         1/1                    unaligned_instr_d = data_i[31:16];
97         1/1                    unaligned_address_d = {address_i[CVA6Cfg.VLEN-1:2], 2'b10};
98                              end
99                            end  // else -> normal fetch
                        MISSING_ELSE
100                     
101                           // we started to fetch on a unaligned boundary with a whole instruction -> wait until we've
102                           // received the next instruction
103        1/1                if (valid_i && address_i[1]) begin
104                             // the instruction is not compressed so we can't do anything in this cycle
105        1/1                  if (!instr_is_compressed[0]) begin
106        1/1                    valid_o = '0;
107        1/1                    unaligned_d = 1'b1;
108        1/1                    unaligned_address_d = {address_i[CVA6Cfg.VLEN-1:2], 2'b10};
109        1/1                    unaligned_instr_d = data_i[15:0];
110                               // the instruction isn't compressed but only the lower is ready
111                             end else begin
112        1/1                    valid_o = {{CVA6Cfg.INSTR_PER_FETCH - 1{1'b0}}, 1'b1};
113                             end
114                           end
                        MISSING_ELSE
115                         end
116                       end else if (CVA6Cfg.FETCH_WIDTH == 64) begin : realign_bp_64
117                         always_comb begin : re_align
118                           unaligned_d         = 1'b0;
119                           unaligned_address_d = unaligned_address_q;
120                           unaligned_instr_d   = unaligned_instr_q;
121                     
122                           valid_o             = '0;
123                           instr_o[0]          = '0;
124                           addr_o[0]           = '0;
125                           instr_o[1]          = '0;
126                           addr_o[1]           = '0;
127                           instr_o[2]          = '0;
128                           addr_o[2]           = '0;
129                           instr_o[3]          = {16'b0, data_i[63:48]};
130                           addr_o[3]           = {address_i[CVA6Cfg.VLEN-1:3], 3'b110};
131                     
132                           case (address_i[2:1])
133                             2'b00: begin
134                               valid_o[0]  = valid_i;
135                               valid_o[1]  = valid_i;
136                     
137                               unaligned_d = unaligned_q;
138                     
139                               // last instruction was unaligned
140                               // TODO how are jumps + unaligned managed?
141                               if (unaligned_q) begin
142                                 // for 64 bit there exist the following options:
143                                 //     64  48  32  16  0
144                                 //     | 3 | 2 | 1 | 0 | <- instruction slot
145                                 // |   I   |   I   |   U   | -> again unaligned
146                                 // | * | C |   I   |   U   | -> aligned
147                                 // | * |   I   | C |   U   | -> aligned
148                                 // |   I   | C | C |   U   | -> again unaligned
149                                 // | * | C | C | C |   U   | -> aligned
150                                 // Legend: C = compressed, I = 32 bit instruction, U = unaligned upper half
151                     
152                                 instr_o[0] = {data_i[15:0], unaligned_instr_q};
153                                 addr_o[0]  = unaligned_address_q;
154                     
155                                 instr_o[1] = data_i[47:16];
156                                 addr_o[1]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b010};
157                     
158                                 if (instr_is_compressed[1]) begin
159                                   instr_o[2] = data_i[63:32];
160                                   addr_o[2]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b100};
161                                   valid_o[2] = valid_i;
162                     
163                                   if (instr_is_compressed[2]) begin
164                                     if (instr_is_compressed[3]) begin
165                                       unaligned_d = 1'b0;
166                                       valid_o[3]  = valid_i;
167                                     end else begin
168                                       unaligned_instr_d   = instr_o[3];
169                                       unaligned_address_d = addr_o[3];
170                                     end
171                                   end else begin
172                                     unaligned_d = 1'b0;
173                                     valid_o[2]  = valid_i;
174                                   end
175                                 end else begin
176                                   instr_o[2] = instr_o[3];
177                                   addr_o[2]  = addr_o[3];
178                                   if (instr_is_compressed[3]) begin
179                                     unaligned_d = 1'b0;
180                                     valid_o[2]  = valid_i;
181                                   end else begin
182                                     unaligned_instr_d   = instr_o[3];
183                                     unaligned_address_d = addr_o[3];
184                                   end
185                                 end
186                               end else begin
187                                 instr_o[0] = data_i[31:0];
188                                 addr_o[0]  = address_i;
189                     
190                                 if (instr_is_compressed[0]) begin
191                                   instr_o[1] = data_i[47:16];
192                                   addr_o[1]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b010};
193                     
194                                   //     64  48  32  16  0
195                                   //     | 3 | 2 | 1 | 0 | <- instruction slot
196                                   // |   I   |   I   | C | -> again unaligned
197                                   // | * | C |   I   | C | -> aligned
198                                   // | * |   I   | C | C | -> aligned
199                                   // |   I   | C | C | C | -> again unaligned
200                                   // | * | C | C | C | C | -> aligned
201                                   if (instr_is_compressed[1]) begin
202                                     instr_o[2] = data_i[63:32];
203                                     addr_o[2]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b100};
204                                     valid_o[2] = valid_i;
205                     
206                                     if (instr_is_compressed[2]) begin
207                                       if (instr_is_compressed[3]) begin
208                                         valid_o[3] = valid_i;
209                                       end else begin
210                                         unaligned_d         = 1'b1;
211                                         unaligned_instr_d   = instr_o[3];
212                                         unaligned_address_d = addr_o[3];
213                                       end
214                                     end
215                                   end else begin
216                                     instr_o[2] = instr_o[3];
217                                     addr_o[2]  = addr_o[3];
218                     
219                                     if (instr_is_compressed[3]) begin
220                                       valid_o[2] = valid_i;
221                                     end else begin
222                                       unaligned_d         = 1'b1;
223                                       unaligned_instr_d   = instr_o[3];
224                                       unaligned_address_d = addr_o[3];
225                                     end
226                                   end
227                                 end else begin
228                                   //     64     32       0
229                                   //     | 3 | 2 | 1 | 0 | <- instruction slot
230                                   // |   I   | C |   I   |
231                                   // | * | C | C |   I   |
232                                   // | * |   I   |   I   |
233                                   instr_o[1] = data_i[63:32];
234                                   addr_o[1]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b100};
235                     
236                                   instr_o[2] = instr_o[3];
237                                   addr_o[2]  = addr_o[3];
238                     
239                                   if (instr_is_compressed[2]) begin
240                                     if (instr_is_compressed[3]) begin
241                                       valid_o[2] = valid_i;
242                                     end else begin
243                                       unaligned_d         = 1'b1;
244                                       unaligned_instr_d   = instr_o[3];
245                                       unaligned_address_d = addr_o[3];
246                                     end
247                                   end
248                                 end
249                               end
250                             end
251                             // this means the previous instruction was either compressed or unaligned
252                             // in any case we don't care
253                             // TODO input is actually right-shifted so the code below is wrong
254                             2'b01: begin
255                               // 64  48  32  16  0
256                               // | 3 | 2 | 1 | 0 | <- instruction slot
257                               // |   I   |   I   | -> again unaligned
258                               // | * | C |   I   | -> aligned
259                               // | * |   I   | C | -> aligned
260                               // |   I   | C | C | -> again unaligned
261                               // | * | C | C | C | -> aligned
262                               //   000 110 100 010 <- unaligned address
263                     
264                               instr_o[0] = data_i[31:0];
265                               addr_o[0]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b010};
266                               valid_o[0] = valid_i;
267                     
268                               instr_o[2] = data_i[63:32];
269                               addr_o[2]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b110};
270                     
271                               if (instr_is_compressed[0]) begin
272                                 instr_o[1] = data_i[47:16];
273                                 addr_o[1]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b100};
274                                 valid_o[1] = valid_i;
275                     
276                                 if (instr_is_compressed[1]) begin
277                                   if (instr_is_compressed[2]) begin
278                                     valid_o[2] = valid_i;
279                                   end else begin
280                                     unaligned_d         = 1'b1;
281                                     unaligned_instr_d   = instr_o[2];
282                                     unaligned_address_d = addr_o[2];
283                                   end
284                                 end
285                               end else begin
286                                 instr_o[1] = instr_o[2];
287                                 addr_o[1]  = addr_o[2];
288                     
289                                 if (instr_is_compressed[2]) begin
290                                   valid_o[1] = valid_i;
291                                 end else begin
292                                   unaligned_d         = 1'b1;
293                                   unaligned_instr_d   = instr_o[2];
294                                   unaligned_address_d = addr_o[2];
295                                 end
296                               end
297                             end
298                             2'b10: begin
299                               // 64  48  32  16  0
300                               // | 3 | 2 | 1 | 0 | <- instruction slot
301                               // | * |   I   | C | <- unaligned
302                               // |   *   | C | C | <- aligned
303                               // |   *   |   I   | <- aligned
304                               //      1000 110 100 <- unaligned address
305                     
306                               instr_o[0] = data_i[31:0];
307                               addr_o[0]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b100};
308                               valid_o[0] = valid_i;
309                     
310                               instr_o[1] = data_i[47:16];
311                               addr_o[1]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b110};
312                     
313                               if (instr_is_compressed[0]) begin
314                                 if (instr_is_compressed[1]) begin
315                                   valid_o[1] = valid_i;
316                                 end else begin
317                                   unaligned_d         = 1'b1;
318                                   unaligned_instr_d   = instr_o[1];
319                                   unaligned_address_d = addr_o[1];
320                                 end
321                               end
322                             end
323                             // we started to fetch on a unaligned boundary with a whole instruction -> wait until we've
324                             // received the next instruction
325                             2'b11: begin
326                               //     64  48  32  16  0
327                               // | 3 | 2 | 1 | 0 | <- instruction slot
328                               // |   *   |   I   | <- unaligned
329                               // |     *     | C | <- aligned
330                               //          1000 110 <- unaligned address
331                     
332                               instr_o[0] = data_i[31:0];
333                               addr_o[0]  = {address_i[CVA6Cfg.VLEN-1:3], 3'b110};
334                     
335                               if (instr_is_compressed[0]) begin
336                                 valid_o[0] = valid_i;
337                               end else begin
338                                 unaligned_d         = 1'b1;
339                                 unaligned_instr_d   = instr_o[0];
340                                 unaligned_address_d = addr_o[0];
341                               end
342                             end
343                           endcase
344                         end
345                       end
346                     
347                       always_ff @(posedge clk_i or negedge rst_ni) begin
348        1/1              if (~rst_ni) begin
349        1/1                unaligned_q         <= 1'b0;
350        1/1                unaligned_address_q <= '0;
351        1/1                unaligned_instr_q   <= '0;
352                         end else begin
353        1/1                if (valid_i) begin
354        1/1                  unaligned_address_q <= unaligned_address_d;
355        1/1                  unaligned_instr_q   <= unaligned_instr_d;
356                           end
                        MISSING_ELSE
357                     
358        1/1                if (flush_i) begin
359        1/1                  unaligned_q <= 1'b0;
360        1/1                end else if (valid_i) begin
361        1/1                  unaligned_q <= unaligned_d;
362                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : instr_realign

               Total   Covered  Percent
Conditions         12       12   100.00
Logical            12       12   100.00
Non-Logical         0        0
Event               0        0

 LINE       73
 EXPRESSION (unaligned_q ? ({data_i[15:0], unaligned_instr_q}) : data_i[31:0])
             -----1-----

-1- Status
 0  Covered
 1  Covered

 LINE       74
 EXPRESSION (unaligned_q ? unaligned_address_q : address_i)
             -----1-----

-1- Status
 0  Covered
 1  Covered

 LINE       82
 EXPRESSION (instr_is_compressed[0] || unaligned_q)
             -----------1----------    -----2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       89
 EXPRESSION (instr_is_compressed[(32'b00000000000000000000000000000010 - 1)] && 1'b1)
             -------------------------------1-------------------------------    --2-

-1- -2- Status
 0   -  Covered
 1   -  Covered

 LINE       103
 EXPRESSION (valid_i && address_i[1])
             ---1---    ------2-----

-1- -2- Status
 0   1  Covered
 1   0  Covered
 1   1  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.i_frontend.i_instr_realign
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME          
100.00 100.00 100.00 --     instr_realign 


Parent : 

SCORE  LINE   COND   ASSERT NAME       
 99.24 100.00  98.47 --     i_frontend 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : multiplier
===============================================================================
SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     

Source File(s) : 

cva6/core/multiplier.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                                                                                           
100.00 100.00 100.00 --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_multiplier 



-------------------------------------------------------------------------------
Line Coverage for Module : multiplier

             Line No.   Total   Covered  Percent
TOTAL                       33       33   100.00
ALWAYS             66        3        3   100.00
ALWAYS             93        9        9   100.00
ALWAYS            122        7        7   100.00
ALWAYS            136        5        5   100.00
ALWAYS            149        9        9   100.00

65                          always_comb begin
66         1/1                clmul_d = '0;
67         1/1                for (int i = 0; i <= CVA6Cfg.XLEN; i++) begin
68         1/1                  clmul_d = (|((operand_b >> i) & 1)) ? clmul_d ^ (operand_a << i) : clmul_d;
69                            end
70                          end
71                      
72                          // clmulr + clmulh result generator
73                          for (genvar i = 0; i < CVA6Cfg.XLEN; i++) begin
74                            assign clmulr_d[i] = clmul_d[(CVA6Cfg.XLEN-1)-i];
75                          end
76                        end
77                      
78                        // Pipeline register
79                        logic [CVA6Cfg.TRANS_ID_BITS-1:0] trans_id_q;
80                        logic                             mult_valid_q;
81                        fu_op operator_d, operator_q;
82                        logic [CVA6Cfg.XLEN*2-1:0] mult_result_d, mult_result_q;
83                      
84                        // control registers
85                        logic sign_a, sign_b;
86                      
87                        // control signals
88                        assign mult_valid_o = mult_valid_q;
89                        assign mult_trans_id_o = trans_id_q;
90                      
91                        // Sign Select MUX
92                        always_comb begin
93         1/1              sign_a = 1'b0;
94         1/1              sign_b = 1'b0;
95                      
96                          // signed multiplication
97         1/1              if (operation_i == MULH) begin
98         1/1                sign_a = 1'b1;
99         1/1                sign_b = 1'b1;
100                           // signed - unsigned multiplication
101        1/1              end else if (operation_i == MULHSU) begin
102        1/1                sign_a = 1'b1;
103                           // unsigned multiplication
104                         end else begin
105        1/1                sign_a = 1'b0;
106        1/1                sign_b = 1'b0;
107                         end
108                       end
109                     
110                     
111                       // single stage version
112                       assign mult_result_d = $signed(
113                           {operand_a_i[CVA6Cfg.XLEN-1] & sign_a, operand_a_i}
114                       ) * $signed(
115                           {operand_b_i[CVA6Cfg.XLEN-1] & sign_b, operand_b_i}
116                       );
117                     
118                     
119                       assign operator_d = operation_i;
120                     
121                       always_comb begin : p_selmux
122        1/1              unique case (operator_q)
123        1/1                MULH, MULHU, MULHSU: result_o = mult_result_q[CVA6Cfg.XLEN*2-1:CVA6Cfg.XLEN];
124        1/1                CLMUL:               result_o = clmul_q;
125        1/1                CLMULH:              result_o = clmulr_q >> 1;
126        1/1                CLMULR:              result_o = clmulr_q;
127                           // MUL performs an CVA6Cfg.XLEN-bitCVA6Cfg.XLEN-bit multiplication and places the lower CVA6Cfg.XLEN bits in the destination register
128                           default: begin
129        1/1(1 unreachable)          if (operator_q == MULW && CVA6Cfg.IS_XLEN64) result_o = sext32to64(mult_result_q[31:0]);
130        1/1                  else result_o = mult_result_q[CVA6Cfg.XLEN-1:0];  // including MUL
131                           end
132                         endcase
133                       end
134                       if (CVA6Cfg.RVB) begin
135                         always_ff @(posedge clk_i or negedge rst_ni) begin
136        1/1                if (~rst_ni) begin
137        1/1                  clmul_q  <= '0;
138        1/1                  clmulr_q <= '0;
139                           end else begin
140        1/1                  clmul_q  <= clmul_d;
141        1/1                  clmulr_q <= clmulr_d;
142                           end
143                         end
144                       end
145                       // -----------------------
146                       // Output pipeline register
147                       // -----------------------
148                       always_ff @(posedge clk_i or negedge rst_ni) begin
149        1/1              if (~rst_ni) begin
150        1/1                mult_valid_q  <= '0;
151        1/1                trans_id_q    <= '0;
152        1/1                operator_q    <= MUL;
153        1/1                mult_result_q <= '0;
154                         end else begin
155                           // Input silencing
156        1/1                trans_id_q    <= trans_id_i;
157                           // Output Register
158        1/1                mult_valid_q  <= mult_valid_i;
159        1/1                operator_q    <= operator_d;
160        1/1                mult_result_q <= mult_result_d;

-------------------------------------------------------------------------------
Cond Coverage for Module : multiplier

               Total   Covered  Percent
Conditions         20       20   100.00
Logical            20       20   100.00
Non-Logical         0        0
Event               0        0

 LINE       97
 EXPRESSION (operation_i == MULH)
            ----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       101
 EXPRESSION (operation_i == MULHSU)
            -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       68
 EXPRESSION (((|((operand_b >> i) & 1))) ? ((clmul_d ^ (operand_a << i))) : clmul_d)
             -------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       51
 EXPRESSION (operation_i == CLMULR)
            -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       52
 EXPRESSION (operation_i == CLMULH)
            -----------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       61
 EXPRESSION ((clmul_rmode | clmul_hmode) ? operand_a_rev : operand_a_i)
             -------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       61
 SUB-EXPRESSION (clmul_rmode | clmul_hmode)
                 -----1-----   -----2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

 LINE       62
 EXPRESSION ((clmul_rmode | clmul_hmode) ? operand_b_rev : operand_b_i)
             -------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       62
 SUB-EXPRESSION (clmul_rmode | clmul_hmode)
                 -----1-----   -----2-----

-1- -2- Status
 0   0  Covered
 0   1  Covered
 1   0  Covered

-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i.cva6_only_pipeline.i_cva6_pipeline.ex_stage_i.i_mult.i_multiplier
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
100.00 100.00 100.00 --     


Module : 

SCORE  LINE   COND   ASSERT NAME       
100.00 100.00 100.00 --     multiplier 


Parent : 

SCORE  LINE   COND   ASSERT NAME   
100.00 100.00 100.00 --     i_mult 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : uvma_obi_memory_assert_if_wrp
===============================================================================
SCORE  LINE   COND   ASSERT 
--     --     --     --     

Source File(s) : 

cva6/verif/sim//../core-v-verif/lib/uvm_agents/uvma_obi_memory/src/uvma_obi_memory_assert_if_wrp.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                        
--     --     --     --     uvmt_cva6_tb.cva6_dut_wrap.obi_fetch_assert 
--     --     --     --     uvmt_cva6_tb.cva6_dut_wrap.obi_store_assert 
--     --     --     --     uvmt_cva6_tb.cva6_dut_wrap.obi_load_assert  



-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_fetch_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
--     --     --     --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 61.29 --     --      61.29 


Module : 

SCORE  LINE   COND   ASSERT NAME                          
--     --     --     --     uvma_obi_memory_assert_if_wrp 


Parent : 

SCORE  LINE   COND   ASSERT NAME          
--     --     --     --     cva6_dut_wrap 


Subtrees :

SCORE  LINE   COND   ASSERT NAME     
 61.29 --     --      61.29 u_assert 



-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_store_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
--     --     --     --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 61.29 --     --      61.29 


Module : 

SCORE  LINE   COND   ASSERT NAME                          
--     --     --     --     uvma_obi_memory_assert_if_wrp 


Parent : 

SCORE  LINE   COND   ASSERT NAME          
--     --     --     --     cva6_dut_wrap 


Subtrees :

SCORE  LINE   COND   ASSERT NAME     
 61.29 --     --      61.29 u_assert 



-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.obi_load_assert
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
--     --     --     --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 61.29 --     --      61.29 


Module : 

SCORE  LINE   COND   ASSERT NAME                          
--     --     --     --     uvma_obi_memory_assert_if_wrp 


Parent : 

SCORE  LINE   COND   ASSERT NAME          
--     --     --     --     cva6_dut_wrap 


Subtrees :

SCORE  LINE   COND   ASSERT NAME     
 61.29 --     --      61.29 u_assert 



===============================================================================
Module : cva6_tb_wrapper
===============================================================================
SCORE  LINE   COND   ASSERT 
--     --     --     --     

Source File(s) : 

cva6/verif/tb/uvmt/cva6_tb_wrapper.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                                         
--     --     --     --     uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i 



-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap.cva6_tb_wrapper_i
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
--     --     --     --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 99.09  99.79  98.39 --     


Module : 

SCORE  LINE   COND   ASSERT NAME            
--     --     --     --     cva6_tb_wrapper 


Parent : 

SCORE  LINE   COND   ASSERT NAME          
--     --     --     --     cva6_dut_wrap 


Subtrees :

SCORE  LINE   COND   ASSERT NAME                               
 99.09  99.79  98.39 --     cva6_only_pipeline.i_cva6_pipeline 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : uvmt_cva6_dut_wrap
===============================================================================
SCORE  LINE   COND   ASSERT 
--     --     --     --     

Source File(s) : 

cva6/verif/tb/uvmt/uvmt_cva6_dut_wrap.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME                       
--     --     --     --     uvmt_cva6_tb.cva6_dut_wrap 



-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb.cva6_dut_wrap
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
--     --     --     --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 88.08  99.79  98.39  66.06 


Module : 

SCORE  LINE   COND   ASSERT NAME               
--     --     --     --     uvmt_cva6_dut_wrap 


Parent : 

SCORE  LINE   COND   ASSERT NAME         
--     --     --     --     uvmt_cva6_tb 


Subtrees :

SCORE  LINE   COND   ASSERT NAME              
 99.09  99.79  98.39 --     cva6_tb_wrapper_i 
 92.31 --     --      92.31 cvxif_assert      
100.00 --     --     100.00 interrupt_assert  
 61.29 --     --      61.29 obi_fetch_assert  
 61.29 --     --      61.29 obi_load_assert   
 61.29 --     --      61.29 obi_store_assert  



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : uvmt_cva6_tb
===============================================================================
SCORE  LINE   COND   ASSERT 
--     --     --     --     

Source File(s) : 

cva6/verif/tb/uvmt/uvmt_cva6_tb.sv

Module self-instances :

SCORE  LINE   COND   ASSERT NAME         
--     --     --     --     uvmt_cva6_tb 



-------------------------------------------------------------------------------
===============================================================================
Module Instance : uvmt_cva6_tb
===============================================================================

Instance :

SCORE  LINE   COND   ASSERT 
--     --     --     --     


Instance's subtree :

SCORE  LINE   COND   ASSERT 
 88.08  99.79  98.39  66.06 


Module : 

SCORE  LINE   COND   ASSERT NAME         
--     --     --     --     uvmt_cva6_tb 


Parent : 

none
----------------


Subtrees :

SCORE  LINE   COND   ASSERT NAME          
 88.08  99.79  98.39  66.06 cva6_dut_wrap 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
